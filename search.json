[{"title":"「Git」 入门总结","url":"/2022/05/18/%E3%80%8CGit%E3%80%8D%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/","content":"基础指令创建仓库\n在本地初始化一个仓库\ngit init\n\n从云端下载完整仓库到本地\ngit clone username@host:/path/to/repository\n\n\n\n本地git管理\n查看文件的修改状态\ngit status\n\n将文件从工作区移至暂存区\ngit add &lt;文件名&gt;\n\n将文件从从暂存区移至本地仓库\ngit commitgit commit -a # 可以把还没有执行add命令的文件也一起提交，即可以省去 git add 的过程（但是仅对于修改/删除文件有效，新文件还是要先 git add）git commit -m &quot;注释&quot; # 添加提交信息\n\n查看历史commit记录及其commit_id\ngit log\n\n回退至某个commit版本\ngit reset --hard commit_id\n\n将指定文件添加至忽略列表，不参与git的管理\n首先需要在工作目录下创建一个名为 .gitignore 的文件（必须是这个固定名）：\ntouch .gitignore\n\n然后在该文件中，指出需要忽略的文件（支持通配符），如 *.a ，那么所有 a 类型的文件都不再被git管理，自然也就不会提交至远端服务器了。\n\n\n\n\npush&#x2F;pull\n将本地仓库推送至云端\n首先，需要将你的本地仓库与远程仓库建立一个连接，例如：\ngit remote add origin username@host:/path/to/repository\n\n然后，就可以向这个远程仓库发送文件啦！\ngit push origin master# 将本地分支关联到远程分支上git push --set-upstream origin master# 后续就直接使用无参指令就可以了git push\n\npush有很多参数，其中有一个 -u 的参数比较实用。\n简单来说，使用了 git push -u origin master 后，就建立了一个和远端分支的关联关系。这样，就可以直接使用不带任何参数的 git pull 从之前push到的分支来pull，而不必再输入完整的 git pull origin master 了。同样，后续在推送代码时，也不必再完整输入 git push origin master ，而是直接 git push 就可以推送到这个远端分支了！\n后续，可以使用 git branch -vv 来查看这些关联关系。\n\n从云端仓库拉取文件\ngit pull\n\n其中，git pull &#x3D; git fetch + git merge，即先抓取，再与本地分支进行合并。\ngit fetch 就是将远程仓库中的更新内容都抓取到本地，但不会进行合并。\n\n\n可能会有疑惑：git pull 和 git clone 有什么区别呢，不都是从云端获取内容吗？\ngit clone 是一个从无到有的过程：在本地没有版本库的时候，从云端服务器获取整个版本库下载到本地。因此，它通常是初始时的第一步。\ngit pull 是在本地已有版本库的前提下，从云端服务抓取最新内容（如果有的话），再merge合并至本地。\n\n\n合并冲突：\nA和B修改了同一个文件的同一行代码，然后A先推送到了远程仓库，B后推送，那么这时候B就会发生合并冲突。\n解决合并冲突：\nB需要先 git pull 拉取一次远程仓库的提交，然后在本地完成合并冲突的处理，最后再提交推送至远程仓库。\n以上操作流程属于是一种经验了，可以在无论什么情况下都这么做（因为你不可能寄希望于自己是第一个提交推送的人）。\n\n\n\n\n使用分支使用分支，意味着可以把个人的工作与开发主线分离开，以免影响开发主线。当个人工作完成后，又可以再合并回开发主线。\n分支就好像单机游戏中的存档，可以创建分支（创建新存档），也可以切换至其他分支（读取其他存档），还可以合并分支（覆盖存档）。\n\n创建新分支\ngit branch &lt;新分支名称&gt;\n\n切换分支\ngit checkout &lt;目标分支名称&gt;\n\n如果你想切换至某个特定的版本，那么可以根据 commit id 来进行指代：\ngit checkout &lt;commit_id&gt;\n\n另外，也可以直接切换至一个不存在的分支（相当于创建+切换），加上参数 -b 即可：\ngit checkout -b &lt;目标分支名称&gt;\n\n将目标分支合并至当前分支\ngit merge &lt;目标分支名称&gt;\n\n删除分支\ngit branch -d &lt;目标分支名称&gt;\n\n这通常是在向主线分支合并完成后，就可以删除无用的副分支。\n\n查看分支\ngit branch # 本地分支git branch -r # 远程分支git brance -a # 查看所有分支\n\n\n\n经验总结\n在切换分支前，先提交本地的修改！！！\n勤提交，以保证不会丢失！！！\n\n\n\n一些trick自定义别名配置为那些常用但较长的指令，配置一个简短的别名，方便自己的命令书写！\n\n在用户目录下，创建 .bashrc 文件\ntouch ~/.bashrc\n\n在 .bashrc 文件中以键值对的形式，进行别名配置，如：\nalias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n使配置文件生效：\nsource ~/.bashrc\n\n\n\n我的常用git指令：\n查看git版本流水git log --pretty=oneline --abbrev-commit --all --graph# 自定义别名# 用于输出git提交日志# 以后，直接使用 git-log 就行了alias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n\n\n强制覆盖本地代码git fetch --allgit reset --hard origin/mastergit pull\n\n\n","tags":["Git"]},{"title":"「Git」 一机多Git账号","url":"/2022/06/19/%E3%80%8CGit%E3%80%8D%E4%B8%80%E6%9C%BA%E5%A4%9AGit%E8%B4%A6%E6%88%B7/","content":"前言最近找了一份实习工作，然后就多出了一个通过公司邮箱注册的新的GitHub账号，工作日都是用这个账号来提交内容的。\n但是我自己还有一个个人的GitHub账号，有时在工作之余我也会用个人账号提交一些自己的内容。如此一来，我需要频繁地切换账号。如果每次都要在切换使用前重置并生成新的SSH公钥&amp;私钥，就显得太麻烦了！所以，本文就记录一下「如何在一台机器上配置多个GitHub账号」。\n\n\n过程\n清空全局范围下的username和email：\ngit config --global --unset user.namegit config --global --unset user.email\n\n设置一个新的username和email（注意这里不带 --global 参数）：\ngit config user.name &quot;wqtang-sib&quot;git config user.email &quot;wqtang@standardintbank.com&quot;\n\n生成每个账号对应的SSH公钥&amp;私钥：\nssh-keygen -t rsa -f ~/.ssh/twq2000 -C &quot;twq2000&quot;ssh-keygen -t rsa -f ~/.ssh/wqtang-sib -C &quot;wqtang@standardintbank.com&quot;\n\n切换至用户目录下的 .ssh/ 文件夹，并创建一个名为 config 的文件：\ncd ~/.ssh/touch config\n\n编辑 config 文件，输入以下内容：\n# twq2000# Host 名是随意的，只是作为一个标识Host git1.github.com# HostName 填入你的远程仓库的所在域名HostName github.comPreferredAuthentications publickey# User 是任意的，可以选择与 GitHub 的账号名保持一致User twq2000# 指定该账号对应的 ssh 文件路径IdentityFile ~/.ssh/twq2000# wqtang-sib# Host 名是随意的，只是作为一个标识Host git2.github.com# HostName 填入你的远程仓库的所在域名HostName github.comPreferredAuthentications publickey# User 是任意的，可以选择与 GitHub 的账号名保持一致User wqtang-sib# 指定该账号对应的 ssh 文件路径IdentityFile ~/.ssh/wqtang-sib\n\n添加ssh文件记录：\nssh-agent bashssh-add -D # 先清空本地的 SSH 缓存ssh-add ~/.ssh/twq2000ssh-add ~/.ssh/wqtang-sib\n\n测试结果：\n# 这里的 git1.github.com 就是前面配置的 Host 名ssh -T git@git1.github.com# 这里的 git2.github.com 就是前面配置的 Host 名ssh -T git@git2.github.com\n\n如果能够分别显示正确的账号名与欢迎语句，那么就配置成功了！！~\n\n\n","tags":["Git","环境配置"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己读取yaml文件！","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，通过实现 PropertySourceFactory 接口，使Spring可以读取 yaml 格式的配置文件。\n\n@PropertySource我们知道，@PropertySource默认支持读取的是 .properties 和 .xml 格式的配置文件。\n不过就目前而言，更受欢迎且主流的配置文件格式是 .yml 。但很遗憾的是，Spring原生并不支持。\n那么，只好自己动手丰衣足食吧~ :thinking:\n所以接下来就自己实现一个可支持 .yml 格式的 @PropertySource ~\n\n\n源码分析首先点进来这个 @PropertySource 分析一番。可以看到这里需要的是一个解析器工厂类，接口为 PropertySourceFactory ，而框架提供的默认实现类是 DefaultPropertySourceFactory 。\n\n\n\n那么我们就照猫画虎，实现一个自己的 `CustomPropertySourceFactory` 。\n\n\n\n实现实现思路就是：将 yaml 文件解析并转为 properties 文件，然后再交由Spring去读取。\n这里我选择导入第三方依赖 snakeyaml ，以帮助我们解析 yaml 文件并转为 properties 文件。\n实现类代码/** * 自定义 PropertySourceFactory * 实现功能：允许读取yml格式的配置文件 */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // 创建一个yaml文件解析工厂    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // 将传入的资源解析为 properties 文件。这样，spring就支持读取了    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\n至此，就可以愉快地将配置文件改为 .yml 格式的啦。但是别忘了将 @PropertySource 的 factory 属性指向自己自定义的工厂解析类哦~\n\n\n配置类代码@Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Java","Spring"]},{"title":"「Spring」 框架知识点梳理宝典","url":"/2022/05/23/%E3%80%8CSpring%E3%80%8D%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%E5%AE%9D%E5%85%B8/","content":"Spring为什么要用Spring？\n控制反转\n通过依赖注入的方式，降低组件之间的耦合程度。由IoC容器来负责创建、管理对象的生命周期和配置。\nIoC的注入方式有两种：构造器注入、setter方法注入\n\nAOP技术\nSpring支持面向切面的编程方式，将一些与业务逻辑本身无关，且被多个业务所共用的操作（事务处理、打印日志、权限控制……）抽取出来。\n这样做的好处是可以减少重复代码，并且有利于未来的可拓展性和可维护性。\n它的原理是在编译时&#x2F;运行时，通过动态代理的方式实现程序功能的统一维护的一种技术。例如 AspectJ 就是在编译时进行动态代理的，SpringAOP 是在运行时进行动态代理的。\n\n支持事务管理\nSpring实现事务有两种方式：声明式和编码式。声明式事务又有两种方式：xml配置方式、@Transaction 注解方式。\n\n\n\n\n说说bean的声明周期流程？(todo…)todo…\n\n\nbean的作用域有哪些？\nsingleton：每一个bean只创建一个实例。这是默认的作用域。\n\n单例模式是线程安全的吗？\nSpring对于单例模式的实现，使用的是 volatile+DCL 的懒汉式。这种方式本身是可以保证读操作的线程安全的。\n也就是说：如果每个线程只有读操作而没有写操作，那么其实是可以保证线程安全的；否则，如果有多个线程同时进行写操作，那么就存在线程安全问题了。\n\n\n\nprototype：每次对bean的调用都会生成一个新的实例。\n\nrequest：在一个 http request 中，一个bean对应一个实例。 \n\nsession：在一个 http session 中，一个bean对应一个实例。 \n\nglobal session：在一个全局的 http session 中，一个bean对应一个实例。\n\n\n\n\nAOP的动态代理策略是怎样的？如果目标对象实现了接口，那么会默认采用JDK动态代理（也可以强制指定为CGLib动态代理）；否则，会强制采用CGLib动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n常用注解及其含义\n\n\n注解\n作用\n\n\n\n@Value\n将常量、配置文件中的变量值，注入到一个变量中\n\n\n@RequestMapping\n用于映射web请求，搭配@Controller一起使用\n\n\n@RequestParam\n接收请求路径中的参数，如 &#x2F;user?id&#x3D;123\n\n\n@PathVariable\n接收路径参数，如 &#x2F;user&#x2F;123\n\n\n@RequestBody\n接收json等格式数据，并注入给指定形参对象\n\n\n@ResponseBody\n将返回对象以某种形式的字符串返回给前端（一般是JSON、XML）\n\n\n@Qualifier\nby name匹配模式，搭配@Autowired一起使用，从而消除注入歧义\n\n\n@Component\n标注在类上，表示当前类是一个组件，要交由Spring来进行管理\n\n\n@Configuration\n标注当前类是一个Java Config类，Spring可以将它视作定义bean的配置类\n\n\n@Bean\n标注在具有返回值的方法上，将其返回值对象作为一个bean注册入IoC容器中\n\n\n\n\nSpringBootSpringBoot是什么？它基于Spring框架，可以帮助使用者快速构建一个准生产级别的项目。\n\n由于Spring框架中需要进行大量的配置，且很多都是固定重复的，因此，SpringBoot预先对这些部分已经做好了习惯性的配置，使用者可以不用或者只需进行很少的手动配置。\n引入了 SpringBoot Starters 来解决依赖之间可能因版本冲突导致的问题。\n\n\n\n@SpringBootApplication 注解的含义@SpringBootApplication 包含了：\n\n@ComponentScan\n\n@SpringBootConfiguration（本身就是一种 @Configuration）\n\n@EnableAutoConfiguration\n其中，最关键的是 @Import(EnableAutoConfigurationImportSelector.class)。借助它，SpringBoot可以将所有符合要求的 JavaConfig 配置类都加载到IoC容器中。\n\n\n\n\nSpringBoot加载配置文件的优先级顺序？由高到低：\n\nfile: .&#x2F;config&#x2F;application.properties\nfile: .&#x2F;application.properties\nclasspath: resource&#x2F;config&#x2F;application.properties\nclasspath: resource&#x2F;application.properties\n\n其中，file 代表项目文件的主目录；classpath 代表项目的类路径。\n\n\nSpringWebRestful风格是什么？Restful就是一个资源定位及资源操作的风格。它不是标准也不是协议，只是一种风格。\n\nURI只是作为资源的代表形式\n\n客户端使用 GET、POST、PUT、DELETE 这四种操作方式对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源\n在服务端，分别对应的注解标识是：&#96;&#96;@GetMapping, @PostMapping, @PutMapping, @DeleteMapping&#96;。\n以 @GetMapping 为例，它其实就是 @RequestMapping(method = RequestMethod.GET) 的缩写。其他同理。\n\n\n\n\nRestful风格的好处是，它允许请求路径相同，但请求参数不同或请求方式不同的情况。如果是传统方式，如果有两个相同的映射路径就会直接报错。\n在Restful风格下，根据不同的参数和请求方式，会执行不同的方法，最终产生的结果也不同，因此就不存在同路径时的冲突问题。\n以下是一个示例：\n@Controllerpublic class TestController &#123;    @GetMapping(&quot;/add&quot;)  @ResponseBody  public String add1(int a, int b) &#123;    return &quot;add1:&quot; + String.valueOf(a + b);  &#125;    @GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)  @ResponseBody  public String add2(@PathVariable int a, @PathVariable int b) &#123;    return &quot;add2:&quot; + String.valueOf(a + b);  &#125;    @PostMapping(&quot;/add&quot;)  @ResponseBody  public String add1(int a, int b) &#123;    return &quot;add3:&quot; + String.valueOf(a + b);  &#125;&#125;\n\n如果访问 “&#x2F;add?a&#x3D;1&amp;b&#x3D;2”，那么在页面上就会显示 “add1:3” 字符串；\n如果访问 “&#x2F;add&#x2F;3&#x2F;4”，那么在页面上就会显示 “add2:7” 字符串；\n如果访问 “&#x2F;add?a&#x3D;1&amp;b&#x3D;2”，且提交方式是POST请求，那么在页面上就会显示 “add3:3” 字符串。\n\n\n@RestController根据官方文档：\n\n@RestController is a stereotype annotation that combines @ResponseBody and @Controller.\n\n意思是：&#96;&#96;@RestController=@ResponseBody＋@Controller&#96;。\n也就是说：使用 @RestController，意味着这个类中的所有方法上面都加了 @ResponseBody。\n至于 @ResponseBody 的作用，就是将返回对象以某种形式的字符串返回给前端（一般是JSON、XML）。\n总之，用 @Controller，返回的是页面；用 @RestController，返回的是JSON、XML或其他文本格式的字符串。\n\n\n下面举个例子，来感受一下 @ResponseBody 的作用：\n@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/login1&quot;)  public String login1() &#123;    return &quot;login&quot;;  &#125;    @RequestMapping(&quot;/login2&quot;)  @ResponseBody  public String login2() &#123;    return &quot;login&quot;;  &#125;&#125;\n\n如果访问 “&#x2F;user&#x2F;login1”，那么返回的就是 login 页面，如 login.html；\n如果访问 “&#x2F;user&#x2F;login2”，那么在页面上就会显示 “login” 字符串。\n\n\n@RequestBody通过 @RequestBody，可以将请求体中的JSON字符串绑定到相应的方法参数上的对象。\n下面举个例子：\n前端请求发送代码：\n$.ajax(&#123;  url: &quot;/login&quot;,  type: &quot;POST&quot;,  data: &#123;    username: $(&quot;#username&quot;).val(),    password: $(&quot;#password&quot;).val()  &#125;,  success: function(data) &#123;    // ....  &#125;&#125;)\n\n后端接收代码：\n@RequestMapping(&quot;/login&quot;)public void login(@RequestBody String username, @RequestBody String password) &#123;  // ....&#125;\n\n这种情况是将请求中的JSON字符串的不同变量分配给了不同的形参对象来接收数据。\n但是如果将 username 和 password 字段进行封装，产生一个 User 类，那么上述代码可以改写为：\n@RequestMapping(&quot;/login&quot;)public void login(@RequestBody User user) &#123;  // ....&#125;\n\n会自动将JSON字符串中的每个值赋予到 user 对象中对应的属性上。不过，JSON字符串中的key必须对应对象中的属性名，否则是无法顺利接收的！\n","tags":["Spring","八股文"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己注册组件！","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，实现自动将组件注册入IOC容器（不用再为每个需要注册的类手写 @Component 、 @Service 等注解），只需要关心业务代码本身即可。\n\n@Import@Import 支持三种使用姿势：\n带有 @Configuration 的 JavaConfig 配置类这也是平时使用的最多的方式就是第一种了，例如有一个主配置类 SpringConfiguration ，现在还需要声明并注册一些数据库相关的组件Bean。当然可以继续写在当前主配置类中，但是组件一旦变得多起来，日后查找就相当烦恼了。更清晰的一种编写方式是：将数据库相关的内容拆分出去，例如新建一个类 JdbcConfiguration ，然后主配置类与数据库配置类之间可以通过 @Import 进行引入。\n\n\n实现 ImportSelector 接口，并自定义其中的规则可以通过实现 ImportSelector 接口和 ImportBeanDefinitionRegistrar 接口，并在其中自定义我们自己想要的注册规则，实现自动批量注册组件等操作。\n观察接口的源码，发现有一个名为 selectImports 的方法需要我们去实现。\n\n\n\n实现类代码/** * 自定义 ImportSelector * 实现功能：将组件批量注册入IOC容器 */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并初始化赋值全局变量   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：将类批量注册入IOC容器   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // 存储扫描包的集合    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\n可以看到，我在无参构造函数中，是通过读取配置文件来获取用户指定的扫描包的。\n配置文件# ImportSelector 相关# AspectJ表达式：twq包下的 任意子包的 任意类custom.importSelector.expression=twq..*# 在上述规则成立的前提下，用户可以指定具体的扫描包custom.importSelector.package=twq# ImportBeanDefinitionRegistrar 相关custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\n对应到我的项目的文件夹路径，是这样的：\n\n    \n    \n    红框部分，就是我配置文件中配置的扫描包范围：twq包（包括子包）下的所有类\n\n\n\n\n最后，在主配置类上引入 @Import(CustomImportBeanDefinitionRegistrar.class) 即可。\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\n可以看到，我既没有在配置类上写 @ComponentScan ，也没有在任何业务类上写例如 @Component 、 @Service 等注解。\n\n\n测试结果现在让我们去测试一下，看看是否可以同样达到组件注册的效果。\n\n    \n    \n    可以看到，这些组件都被成功注册，调用方法也正常执行\n\n\n\n    \n    \n    另外，通过输出当前IOC容器组件名可知：自动为它们分配的id是各自的全限定名。\n\n\n\n\n实现 ImportBeanDefinitionRegistrar 接口，并自定义其中的规则我们来看一下 ImportBeanDefinitionRegistrar 接口的实现姿势。其实它与 ImportSelector 的实现思路基本一致。\n实现类代码/** * 自定义 ImportBeanDefinitionRegistrar * 实现功能：将组件批量注册入IOC容器 */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并给一些全局变量赋值   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：通过指定扫描包，自动将组件注册入IOC容器   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // 扫描集合中的这些包    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\n配置类代码@Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\n测试结果\n\n这里要说明一下：虽然在上面的图片中，看到相关注解的属性爆红了：idea表示无法解析这个bean name。这是因为我们根本没有写任何 @Component ，idea 还以为不存在这些组件。但其实我们已经通过 ImportBeanDefinitionRegistrar 接口帮我们进行组件注册了，所以测试结果是没问题的~~ :laughing:\n\n\n总结：\nImportSelector 自动注册时，分配的组件名规则是：各自类的全限定名 。\n\nImportBeanDefinitionRegistrar 自动注册时，分配的组件名规则是：各自类的类短名+首字母小写的注入方式 。\n\n\n","tags":["Java","Spring"]},{"title":"「String」 String不可变类的原因","url":"/2022/06/02/%E3%80%8CString%E3%80%8DString%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/","content":"什么是不可变？《Effective Java》中对于不可变对象的定义是：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。这就意味着，一旦我们将一个对象分配给一个变量，就无法再通过任何方式更改对象的状态了。\n在 String 中，不可变的表现就是当我们试图对一个已有的对象 “abc” 修改为 “abcd” 时，会直接创建一个新对象：\nString s = &quot;abc&quot;;// 这里 s 的引用地址已经发生改变了，指向了一个新的对象s = &quot;abcd&quot;;\n\n\n\nString 是如何做到不可变的？String 真正存储字符内容的地方是一个 char 数组，并且被 final 所修饰，所以无法被修改：\nprivate final char[] value;\n\n但是！！！这里说的无法被修改，仅仅是指它的引用地址不可被修改，并不代表它本身的内容不可变！！\n引用地址不可被修改：\nfinal char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;// 编译器报错value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;\n\n本身的内容是可变的：\nfinal char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;// 这是完全可以的value[0] = &#x27;d&#x27;;\n\n\n\n这么说来，如果回答 ”String 真正存储字符内容的地方是一个 char 数组，并且被 final 所修饰，所以无法被修改“，就不完全正确。\n\nString 中的 char 数组是 private 的，并且 String 类没有对外提供修改这个数组的方法。所以在初始化之后，外界没有有效的手段去修改它；\nString 类被 final 修饰，也就是不可继承的，这样可以避免被子类继承后被破坏了不可变性；\n在 String 的所有方法里面，都很小心地避免直接修改 char 数组中的内容。所有涉及到对 char 数组中数据进行修改的操作，全部都会创建一个新的 String 对象。\n\n\n\n为什么要将 String 设计为不可变？\n字符串常量池\n回顾一下字符串常量池的定义。在大量频繁地创建字符串的场景下，会极大程度地影响程序的性能。JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：\n\n为字符串开辟了一个字符串常量池 String Pool，可以理解为缓存区。\n创建字符串常量时，首先检查字符串常量池中是否存在该字符串？\n若字符串常量池中存在该字符串，则直接返回该引用实例，无需重新实例化；若不存在，则先实例化该字符串，然后放入池中。\n\n下面的代码，只会在堆中创建一个实例：\nString str1 = &quot;hello&quot;;String str2 = &quot;hello&quot;;System.out.println(str1 == str2); // true\n\n\n试想一下：如果 String 是可变的，那么如果我们修改了 str1 的内容，那么 str2 也会被一起修改。但这显然不是我们想要的结果。\n\n保证线程安全\n作为最基础最常用的数据类型，String 被许多 Java 类库用来作为参数，如果 String 是可变的，就会引起各种线程安全的隐患。\n在多线程环境下，多个线程同时修改同一个资源，这是存在线程安全问题的。但 String 作为不可变对象，它不能被修改。想要修改，只能再创建一个新的对象；多个线程同时读同一个资源，是完全没有问题的。所以总的来说，这样做可以保证 String 是线程安全的。\n\n\n\n\nString 真的不可变吗？想要改变 String 无非就是改变 char 数组中的内容，但它是一个私有属性。那么在 Java 中有没有某种手段可以访问类的私有属性呢？\n那就是反射。使用反射当然可以直接修改 char 数组中的内容，从而修改 String 的内容，破坏了不可变性。\npublic void test() &#123;  String s = &quot;hello&quot;;  Field field = s.getClass().getDeclaredField(&quot;value&quot;);  // 允许获取私有属性  field.setAccessible(true);  // 获取 s 的 value 属性  char[] value = (char[]) field.get(s);  value[0] = &#x27;g&#x27;;  System.out.println(s); // &quot;gello&quot;&#125;\n\n只不过我们一般不会这么做，反射不在这里的讨论范围之内，毕竟 private 修饰符防君子不防小人！\n\n\n总结并不是因为 char 数组是 final 才使得 String 是不可变的，而是为了把 String 设计成不可变，所以才把 char 数组修饰为 final 的。\n\n\n一般来说，不可变类都遵循这些设计规则：\n\n不提供 setter 方法（包括修改字段的方法和修改字段引用对象的方法）\n将类的所有字段定义为 private final 的\n不允许子类重写方法。最简单的办法是将类声明为 final，更好的方法是将构造函数声明为私有的，对外界只提供工厂方法来创建对象\n\n","tags":["Java","八股文"]},{"title":"「macOS」 🍎懵逼指南","url":"/2022/05/28/%E3%80%8CmacOS%E3%80%8DmacOS%E4%B8%8A%E6%89%8B%E5%88%9D%E8%AE%BE%E7%BD%AE/","content":"自定义设置总体而言，几乎所有的自定义设置，都在「偏好设置」中。如果是系统级别的，就是「系统偏好设置」；如果是应用级别的，就是各应用中的「偏好设置」。\n\n\n系统偏好设置通用\n显示滚动条 —— 始终\n在滚动条中点按 —— 跳到点按的位置\n最近使用的项目 —— 关闭文稿时要求保存更改、退出App时关闭窗口\n\n\n\n程序坞\n打开文稿时首选标签页 —— 仅在全屏幕视图下\n连按窗口标题栏以 —— 缩放\n将窗口最小化为应用程序图标 —— 关闭\n弹跳打开应用程序 —— 打开\n为打开的应用程序显示指示灯 —— 打开\n在程序坞中显示最近使用的应用程序 —— 打开\n\n\n\n语言与地区 &amp; 日期与时间\n每周的第一天 —— 星期一\n时间格式 —— 24小时\n时钟 —— 使用24小时格式时钟\n\n\n\n用户与群组登录选项：\n\n自动登录 —— 关闭\n显示“睡眠”、“重新启动”和“关机”按钮 —— 打开\n将快速用户切换菜单显示为 —— 全名\n\n\n\n安全性与隐私\n允许从以下位置下载的App —— 任何来源\nsudo spctl --master-disable\n\n文件保险箱 —— 停用\n\n\n\n\n显示器\n排列 —— 主屏是上方有「白条」标识的\n\n\n\n节能\n此时间段后关闭显示器 —— 30分钟\n如果可能，使硬盘进入睡眠 —— 关闭\n使用电池电源时使显示屏略暗一些 —— 打开\n在菜单栏中显示电池状态 —— 打开\n当显示器关闭时，防止电脑自动进入睡眠 —— 打开\n\nApp推荐：Better Menubar\n\n\n访达高级：\n\n显示所有文件扩展名 —— 打开\n更改扩展名之前显示警告 —— 打开\n从iCloud云盘中移除前显示警告 —— 打开\n清倒废纸篓之前显示警告 —— 打开\n将以下位置的文件夹保持在顶部 —— 按名称排列时的窗口中\n执行搜索时 —— 搜索此Mac\n\n\n\n显示文件路径打开终端，输入以下命令：\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n这样就可以在Finder顶部看见完整地址了。复制路径使用 Option+Command+C\n右键地址栏区域，还可以直接访问路径中的任意一层。\n\n\n卸载方式\n应用程序自带的卸载程序\n使用第三方卸载工具（如 AppDelete），然后将需要卸载的应用图标拖入\n直接移除至废纸篓（可能会残留日志、用户数据缓存等文件）\n\n\n\n常用命令行查找目标文件的路径\n根据文件名查找路径\nmdfind -name &#x27;hello.txt&#x27;\n\n根据文件内容查找路径\nmdfind &#x27;hello world!&#x27;\n\n\n\n新建文本文件touch hello.txt\n\n\n\n推荐App工具列单 🏷️\nBetterAndBetter\n截图工具 iShot\n解压缩工具 Bandizip&#x2F;MyZip&#x2F;FastZip\n磁盘清理工具 CleanMyMac\n\n\n\n附图：Mac快捷键\n\n\n\n","tags":["环境搭建"]},{"title":"「vue」 基本语法小记","url":"/2022/06/06/%E3%80%8Cvue%E3%80%8D%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/","content":"前言参考链接：Vue基础语法\n这篇文章总结的实在是太！！好！！了！！（说实在的，看完它就根本不需要继续看本文继续看下去了😄）\n\n\n属性绑定主要的两种方式是 v-bind 和 v-model。\n它们的区别是：\n\nv-bind 是单向绑定，而 v-model 是双向绑定。\n这意味着：v-bind 只能将vue中的属性的数据同步到页面，而 v-model 不仅如此，还能将用户数据的数据赋值到vue中的属性；\n\nv-bind 可以与任何属性进行绑定，而 v-model 只能与具备了 value 属性的元素进行双向绑定（因此，它一般用于表单中的元素进行双向绑定）。\n\n\n\n\nv-bind\n绑定文本\n直接使用 v-bind 或 &#123;&#123;&#125;&#125;\n&lt;span v-bind=&quot;message&quot;&gt;&lt;/span&gt;&lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;\n\n绑定属性\n使用 v-bind:&lt;属性&gt;=&quot;value&quot;\n&lt;div v-bind:class=&quot;....&quot;&gt;&lt;/div&gt;&lt;div v-bind:src=&quot;....&quot;&gt;&lt;/div&gt;\n\n绑定表达式\n直接使用 &#123;&#123;&#125;&#125;，支持运算、三元表达式、函数调用等\n&#123;&#123;num + 1&#125;&#125;&#123;&#123;flag ? &quot;Yes&quot; : &quot;No&quot;&#125;&#125;&#123;&#123;message.split(&#x27; &#x27;).reverse()&#125;&#125;\n\n\n\nv-model 如前所述：v-model 一般用于表单中的元素进行双向绑定。所以，下面的代码示例全部都是基于表单情景的：\n\n绑定text\n&lt;input type=&quot;text&quot; v-model=&quot;val&quot; /&gt;&lt;p&gt;&#123;&#123;val&#125;&#125;&lt;/p&gt;\n\n绑定radio\n&lt;input type=&quot;radio&quot; value=&quot;one&quot; v-model=&quot;&quot;\n\n绑定checkBox\n&lt;!-- 单个勾选框架，最终的值为逻辑值true和false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkVal&quot;/&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;checkVal&#125;&#125;&lt;/label&gt;&lt;!-- 多个勾选框时，将值绑定到一个数组 --&gt;&lt;input type=&quot;checkbox&quot; value=&quot;apple&quot; v-model=&quot;checkArray&quot;/&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;apple&#125;&#125;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checkArray&quot;/&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;banana&#125;&#125;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;pear&quot; v-model=&quot;checkArray&quot;/&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;pear&#125;&#125;&lt;/label&gt;&lt;!-- checkArray中的值会根据是否选中而动态变化 --&gt;&lt;span&gt;&#123;&#123;checkArray&#125;&#125;&lt;/span&gt;\n\n绑定select\n\n….\n\n\n","tags":["前端","vue"]},{"title":"「二分法」最硬干货，速进！","url":"/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81/","content":"前言二分法是一个广泛应用于计算机世界的经典算法，相信没有哪个程序员会不知道它。\n二分查找的本质是通过不断的判断，决定区间的取舍，最终夹出所需答案。使用二分法，可以让你在有序数组中，以 O(logn) 的时间复杂度，找到想要的答案。\n但是，网上关于二分的教学满天飞，大致分为 while (left &lt;= right)  和 while (left &lt; right) ，然后更新式又是五花八门：有的是 left = middle + 1 和 right = middle - 1 ，有的是 left = middle + 1 和 right = middle ……\n稍有不慎写错了，二分就进入了死循环 😭 本来是为了加速查找，这下好了，反向加速了属于是。\n\n\n所以，不多逼逼，直接上干货！\n模板代码统一使用 while (left &lt; right) ，并且：\n\n寻找第一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  int middle = left + (right - left) / 2;  if (满足XXX) &#123;    right = middle;  &#125; else &#123;    left = middle + 1;  &#125;&#125;\n寻找最后一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  // +1是为了让相除结果向上取整，这个地方就是两套模板的区别之一  int middle = left + (right - left + 1) / 2;  if (满足XXX) &#123;    left = middle;  &#125; else &#123;    right = middle - 1;  &#125;&#125;\n\n\n\n最终的二分结果，返回 left 或 right 都可，因为退出循环时一定有 left==right 。\n\n你可以把这两种模板都记住，也可以只选择其中一套看着更顺眼的。因为这两种模板之间的结果是可以互相转化的。\n假设你只会用 寻找第一个满足XXX 这个模板，但是遇到的实际需求是 寻找最后一个满足XXX ，那你也完全可以将二分目标动态地修改为： 寻找第一个不满足XXX 的位置（也就是把 if 条件 改成对应相反的，其余都不用动）。可知它的上一个位置就是 最后一个满足XXX 的，即：把得到的二分结果减去1，就是答案了。反之同理，由 最后一个 -&gt; 第一个 是 加1操作。\n\n\n不过，这样得到的结果，很多时候都需要进行 后处理判断 ，否则会带来问题。\n\n如果你是由 一种情况 转化到 另一种情况 的话，可能会带来 索引越界 的问题。这是因为：在结果转化时一定会进行 -1 (或者 +1) 的操作。那么假设本身的二分结果是0，然后再减1，变成-1了。\n所以在最后返回前，必须判断一下这个下标究竟是否合法（如果题目保证一定存在答案，那么大可放心不必进行这些判断）：\n\n\n// 这里用 -1 表示下标非法时的返回结果return left &gt;= 0 &amp;&amp; left &lt; nums.length ? left : -1;\n\n\n另外，如果题目不保证一定存在答案，那么即使没有产生 索引越界 ，也可能得到 错误答案 。\n例如 寻找有序数组中元素值为 target 的元素所在位置，但是并不保证它一定存在 。拿到这题，我便设定二分目标是： 寻找第一个满足 nums[i] &gt;= target 的位置 i ，最终我得到的二分结果是 left (同样也可以是 right ) 。可是我只知道 nums[left] &gt;= target 是没错的，但不代表 nums[left] == target 也一定没错，因为可能 target 压根就不存在于数组中！！\n所以就必须要后处理判断：\n\n\n// 这里用 -1 表示数组中不存在 target 的返回结果return nums[left] == target ? left : -1;\n\n\n\n最后，还是要啰嗦一下：如果题目保证答案是存在的，那么以上这些后处理的判断都是不必的，你得到的结果一定是正确的。当然，你总是进行后判断处理，那也是很严谨的~\n","tags":["算法","二分查找"]},{"title":"「动态规划」 股神养成记","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n前言股票问题系列 是动态规划入门的经典系列了。\n本文将收录 LeetCode 上的所有相关问题，以此总结股票市场的操作经验。\n\n\n题单汇总 🏷️LeetCode.121题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例1：\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出。\n\n示例2：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成。\n\n\n\n分析本题的要点：最多允许一次交易（买入+卖出）。而数组本身的长度，满足 prices.length&gt;=1 ，即：你想在哪个点位买入，随意任君挑选~并且，你不用考虑当前交易会对下次交易产生影响（因为只有一次交易，不存在下一次）。\n所以，在这种情况下，可以不考虑dp思想，退化为最naive的贪心策略：选择一个价格差最大的交易即可。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.122题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以 尽可能地 完成更多的交易（多次买卖一支股票）。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出）。除了不能同时参与多笔交易，没有任何其他限制条件。\n这种情况下，也完全可以将问题 退化为贪心策略：只要今天价格比昨天高，那么我就认为昨天已买入，然后在今天卖出。\n为什么这个策略是正确的？万一明天更高，但是我今天就卖出了，岂不是卖早了嘛？？\n其实并不会。可以看 示例2 ，你会发现：即使我在1块钱买入、2块钱卖出；然后我可以在2块钱又买入、3块钱再卖出；然后再是3块钱买入、4块钱卖出……总之，我最后依然可以赚取4元的利润，不会少的。嗯，本质是叫我们去做短线高手。懂了，学会这个操作思路，股神就是在下了。实际：死于做t\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.309题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n示例1：\n\n输入：prices &#x3D; [1,2,3,0,2]输出：3\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出），但除了不能同时参与多笔交易以外，每两笔交易之间还存在一天的冷冻期。\n这种情况下，贪心策略就不再好使了。因为，你必须考虑到：当前的交易会使得明天无法交易，所以“无脑短线”并不见得一定正确。 从此开始，dp策略正式亮相~\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; 第i天持有股票时，可获得的最大利润    // dp2[i] -&gt; 第i天未持有股票且未处于冷冻期，可获得的最大利润    // dp3[i] -&gt; 第i天未持有股票且处于冷冻期，可获得的最大利润    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\nLeetCode.123题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：最多允许两次交易（买入+卖出），并且不能同时参与多笔交易。\n这种情况下，贪心策略也不再好使了。原因也很容易理解：一共只有两次交易机会，你必须选择利润最大的两笔，而不是“一高就卖”，随意挥霍机会。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * 在任意一天结束后，会处于以下五种状态中的一种：   * 未进行过任何操作，最大利润永远是0   * 只进行过一次买入操作，最大利润以buy1表示；   * 进行过一次买入、一次卖出操作，最大利润以sell1表示；   * 进行过两次买入、一次卖出操作，最大利润以buy2表示；   * 进行过两次买入、两次卖出操作，最大利润以sell2表示。   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\nLeetCode.188题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2\n\n示例2：\n\n输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7\n\n\n\n分析本题与之前的不同之处在于：最多允许 两次 交易（买入+卖出），并且不能同时参与多笔交易。\n本题实质上，就是 题目4 – LeetCode.123 的扩展版本：硬编码 2 次机会 --&gt;  任意给定的 k 次机会。\n同样地，这里也理应无法使用贪心策略。\n但事实上，由于 k 的范围是任意的，所以情况也不完全是这样。例如：k=9999999（此处自行脑补一亿个9…），那么我们就可以认为 k 是无限大的，此时交易次数视为：不受限。\n事实上，只要有 k &gt;= prices.length / 2 ，此时就可以 无视次数限制了，因为你一定来不及用完所有的交易机会！如果没有交易次数限制，那么问题又可以退化为“贪心策略”了。 于是问题又变成了 题目2 – LeetCode.122 。\n除此以外，普遍情况下还是需要使用 dp策略 。\n\n\n代码class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // 当可操作次数不少于数组的一半长度时，问题可以退化为“贪心策略”    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; 完成i次买入后，可获得的最大利润    // dp[i][1] -&gt; 完成i次卖出后，可获得的最大利润    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["算法","动态规划"]},{"title":"「树」根据给定的前/中/后序遍历，以恢复二叉树","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"今天来记录两道经典二叉树的问题：\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树\n\n\n\n首先，为了构建出这棵二叉树，我们肯定是自顶向下，从 位于顶端的树根节点 出发，在每个正确的位置构造出正确的节点。在每次处理中，我们只关注如何 构造出当前节点 。\n而这个 节点 ：\n\n对于 先序遍历 ，就是 第一个 元素 preorder[preLeft] ；\n\n对于 后序遍历 ，就是 最后一个 元素 postorder[postRight]\n\n\n现在，这个根节点的 val 属性已经确定了，我们可以构造出当前节点： TreeNode root = new TreeNode(val);\n但是其 left 和 right 属性都是不确定的，它们作为子节点，此时并不存在。需要在之后的处理中将它们构造出来 (也就是递归调用) ： \nroot.left = buildTree();root.right = buildTree();\n\n接下来，我们将开始利用 中序遍历的性质。据前所述，我们可以根据 先序遍历 (or 后序遍历) 得到当前的根节点。那么，它在 中序遍历 中的位置，其实将整棵树分为了两半。\n我们假定 该根节点在中序遍历中的位置 是 rootIdx ，那么我们可知 左子树的节点个数 leftSize = rootIdx - inLeft ，由此可得到左右子树的区间范围：\n\n左子树：\n先序遍历： [preLeft + 1, preLeft + leftSize]\n中序遍历： [inLeft, rootIdx - 1]\n后序遍历： [postLeft, postLeft + leftSize - 1]\n\n\n右子树：\n先序遍历： [preLeft + leftSize + 1, preRight]\n中序遍历： [rootIdx + 1, inRight]\n后序遍历： [postLeft + leftSize, postRight - 1]\n\n\n\n至于如何能快速地根据先序遍历&#x2F;后序遍历的元素定位至它在中序遍历中的位置？\n答案是：在开始时，使用哈希表来预处理存储先&#x2F;后序遍历数组中的每个元素在中序遍历数组中的位置。\n\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["算法","二叉树"]},{"title":"「正则表达式」 语法与使用","url":"/2022/05/27/%E3%80%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%8D%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"前言正则表达式，又称规则表达式。其英语为 Regular Expression，在代码中常简写为 regex 。它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，从而实现一种过滤的逻辑效果。\n正则表达式是一种文本模式，描述了在搜索文本时要匹配的字符串的“样子”，因此通常被用来检索、替换那些符合该模式规则的文本，或者是检验一个文本是否符合该模式规则。\n\n\n基本语法\n\n\n表达式\n匹配内容\n\n\n\n[…]\n匹配封闭字符集中的任一字符\n\n\n[\\^…]\n不匹配封闭字符集中的任一字符\n\n\n.\n代表任意字符\n\n\n\\.\n代表文字句号 ‘.’\n\n\n\\d\n匹配一个数字\n\n\n\\d+\n匹配一个整数（+表示一个或多个）\n\n\n\\d?\n匹配一个可能存在的数字（?表示零个或一个）\n\n\n\\d*\n匹配一个可能存在的整数（*表示零个或多个）\n\n\n\\d{m}\n匹配m个数字\n\n\n\\d{m,n}\n匹配m~n个数字\n\n\n\\w\n匹配一个字母字符\n\n\n其中,+,*,&#123;m&#125;,&#123;m,n&#125; 这些都是数量表达式，可以跟在 [...],\\w 等任意字符表达式的后面，两者结合成为更加详细的字符串匹配表达式。\n\n\n不过，需要注意的是：在Java中使用这些正则表达式的语法时，对于任何特殊字符（如\\ 和 .）都需要两级转义，变成 \\\\ 和 \\. 。这是因为正则表达式本身也是一种字符串，也会被javac编译。因此想要得到预期的效果，就必须转义。\n\n\n例题应用LeetCode.65 – 有效数字题面\n有效数字（按顺序）可以分成以下几个部分：\n\n一个 小数 或者 整数\n（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n下述格式之一：\n至少一位数字，后面跟着一个点 ‘.’\n至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字\n一个点 ‘.’ ，后面跟着至少一位数字\n\n\n\n整数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n至少一位数字\n\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n\n示例：\n\n部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]\n部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final Pattern PATTERN = Pattern.compile(&quot;[+-]?((\\\\d+)|(\\\\d+\\\\.\\\\d*)|(\\\\d*\\\\.\\\\d+))([eE][+-]?\\\\d+)?&quot;);  public boolean isNumber(String s) &#123;    return PATTERN.matcher(s).matches();  &#125;&#125;\n\n\n\nLeetCode.468 – 验证IP地址题面\n给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。\n有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;&#x3D; xi &lt;&#x3D; 255 且 xi 不能包含 前导零。\n一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:\n\n1 &lt;&#x3D; xi.length &lt;&#x3D; 4\nxi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )\n在 xi 中允许前导零。\n\n\n示例：\n\n有效的IPv4地址: “192.168.1.1”, “192.168.1.0”\n无效的IPv4地址: “192.168.01.1”, “192.168.1.00”, “&#49;&#x39;&#x32;&#x2e;&#x31;&#54;&#56;&#64;&#x31;&#46;&#49;”\n有效的IPv6地址: “2001:0db8:85a3:0000:0000:8a2e:0370:7334”, “2001:db8:85a3:0:0:8A2E:0370:7334”\n无效的IPv6地址: “2001:0db8:85a3::8A2E:037j:7334”, “02001:0db8:85a3:0000:0000:8a2e:0370:7334”\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final String IP4_REGEX = &quot;((\\\\d)|([1-9]\\\\d)|(1\\\\d\\\\d)|(2[0-4]\\\\d)|(25[0-5]))&quot;;  private static final String IP6_REGEX = &quot;([\\\\d|[a-f]|[A-F]]&#123;1,4&#125;)&quot;;  private static final Pattern IPV4_PATTERN = Pattern.compile(IP4_REGEX + &quot;(\\\\.&quot; + IP4_REGEX + &quot;)&#123;3&#125;&quot;);  private static final Pattern IPV6_PATTERN = Pattern.compile(IP6_REGEX + &quot;(:&quot; + IP6_REGEX + &quot;)&#123;7&#125;&quot;);  public String validIPAddress(String queryIP) &#123;    if (IPV4_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv4&quot;;    &#125;    if (IPV6_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv6&quot;;    &#125;    return &quot;Neither&quot;;  &#125;&#125;\n\n","tags":["字符串","正则表达式"]},{"title":"「进制转换」 题单总结！","url":"/2022/06/05/%E3%80%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%8D%E9%A2%98%E5%8D%95%E6%80%BB%E7%BB%93/","content":"前言「进制转换」问题算是比较简单但又十分常考的面试题了。它可以很好的考察一个人对于计算机进制的理解，同时涉及到一些位运算。\n\n\n题单汇总 🏷️LeetCode.504 – 七进制数题面\n给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。\n\n示例 1:\n\n输入: num &#x3D; 100\n输出: “202”\n\n示例 2:\n\n输入: num &#x3D; -7\n输出: “-10”\n\n\n\n代码class Solution &#123;  public String convertToBase7(int num) &#123;    boolean neg = num &lt; 0;    if (neg) &#123;      num = -num;    &#125;    StringBuilder sb = new StringBuilder();    while (num &gt; 0) &#123;      sb.append(num % 7);      num /= 7;    &#125;    if (neg) &#123;      sb.append(&#x27;-&#x27;);    &#125;    return sb.isEmpty() ? &quot;0&quot; : sb.reverse().toString();  &#125;&#125;\n\n\n\nLeetCode.1017 – 负二进制转换题面\n给出数字 N，返回由若干 “0” 和 “1”组成的字符串，该字符串为 N 的负二进制（base -2）表示。\n除非字符串就是 “0”，否则返回的字符串中不能含有前导零。\n\n示例 1：\n\n输入：2\n输出：”110”\n解释：(-2) ^ 2 + (-2) ^ 1 &#x3D; 2\n\n示例 2：\n\n输入：3\n输出：”111”\n解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 &#x3D; 3\n\n\n\n代码class Solution &#123;  public String baseNeg2(int n) &#123;    boolean neg = false;    StringBuilder sb = new StringBuilder();    while (n &gt; 0) &#123;      sb.append(n &amp; 1);      n = neg ? (n &gt;&gt; 1) + (n &amp; 1) : n &gt;&gt; 1;      neg ^= true;    &#125;    return sb.isEmpty() ? &quot;0&quot; : sb.reverse().toString();  &#125;&#125;\n\n\n\nLeetCode.1837 – K 进制表示下的各位数字总和题面\n给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。\n转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。\n\n示例 1：\n\n输入：n &#x3D; 34, k &#x3D; 6\n输出：9\n解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 &#x3D; 9 。\n\n示例 2：\n\n输入：n &#x3D; 10, k &#x3D; 10\n输出：1\n解释：n 本身就是 10 进制。 1 + 0 &#x3D; 1 。\n\n\n\n代码// todo","tags":["算法"]},{"title":"「链表」链表题总结","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"链表的基本套路：链表反转public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // 三指针  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\n找链表的中点public ListNode middleNode(ListNode head) &#123;  // 快慢双指针  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 至此，slow 移动至链表的中点  // 对于长度为奇数的链表，中点只有一个  // 对于长度为偶数的链表，中点有两个。此时 slow 位于第一个中点  return slow;&#125;\n\n\n找链表的倒数第 K 个节点 (使用前后双指针 former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // 让先指针 former 先走 k 步  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\n删除某节点// 找到待删除节点的前驱节点 prevprev.next = prev.next.next\n\n\n\n很多链表的中等题甚至是困难题，其实都是对于上述基本套路的缝合。\n例如，LeetCode.234 – 判断一个链表是否为回文链表 。\n\n很直观的一个做法是：使用 栈 的数据结构，先存储链表的前半部分，然后与后半部分逐个进行比对。但是这么做的话，空间复杂度就是 O(n) 了。\n存在一种空间复杂度 O(1) 的原地解法，即用到我们上面所说的基本套路操作。\n具体做法是：\n\n使用快慢指针，定位至链表的中点\n反转后半部分的链表\n比较前半部分与后半部分的链表是否完全一致public boolean isPalindrome(ListNode head) &#123;  // 定位至链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 反转后半部分的链表  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 比较两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\n常见链表面试题反转链表public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nK个一组翻转链表public ListNode reverseKGroup(ListNode head, int k) &#123;  // 判断剩余节点个数是否够 k 个  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // 翻转接下来的 k 个节点  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 尾部连接  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\n合并两个有序链表public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\n另外，也可以使用迭代法 (类似于归并排序) 。\n判断是否为环形链表public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n延伸问题： 找到环的入口节点\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\n相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // 保证两个链表的剩余长度一致  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\n链表相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // 不足补0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // 存在进位现象  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\n重排链表public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // 找到链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 由此，将整个链表分为两部分。  // 前半部分是 [head,mid] ；后半部分是 [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // 反转后半部分的链表  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 合并两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\n删除链表的重复元素public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // 去重    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\n两两交换链表中的节点public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\n链表排序public ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\n分隔链表public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["算法","链表"]},{"title":"「Java基础」 基础不牢，地动山摇！","url":"/2022/04/18/%E3%80%8CJava%E5%9F%BA%E7%A1%80%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%EF%BC%81/","content":"四种访问修饰符的作用范围？\n\n\n修饰符\n当前类\n同包下\n子类\n其他包下\n\n\n\npublic\n✔️\n✔️\n✔️\n✔️\n\n\nprotected\n✔️\n✔️\n✔️\n❌\n\n\ndefault\n✔️\n✔️\n❌\n❌\n\n\nprivate\n✔️\n❌\n❌\n❌\n\n\n\n\n基本类型转换\n向上转型没有任何问题。如 long b = 1;\n向下转向会造成精度损失，因此如果需要，必须显式地进行强制转换。如 float f = (float) 2.3;\n\n打个比喻：小杯的水倒进一个大杯里肯定没问题。但大杯的水倒进小杯就不行了，可能会溢出。\n\n\n常量池Java的基本类型的包装类大部分都实现了常量池技术。\n\n\n\nByte\nShort\nInteger\nLong\nCharacter\nBoolean\n\n\n\n[-128,127]\n[-128,127]\n[-128,127]\n[-128,127]\n[0,127]\nTrue&#x2F;False\n\n\nFloat 和 Double 没有使用常量池技术。\n简单地说，如果使用的对象的字面量的值在常量池的范围之内，那么就不会创建新的包装类型对象，而是直接引用常量池中的对象。\nInteger a = 100, b = 100, c = 1000, d = 1000;System.out.println(a == b);  // trueSystem.out.println(c == d);  // false\n\n\n\n同样地，String 也有对应的常量池，称为字符串常量池。不过这和上面提到的包装类型的常量池有些不同的是，字符串常量池事先不会缓存任何内容，而是在每次创建字符串时进行判断：如果已经在常量池中存在，那么就直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。维护字符串常量池的全局表叫做 StringTable，其实就是一个 HashSet&lt;String&gt;。它在JVM中仅有一份实例，并被所有类共享使用。\n在Java中，有两种创建字符串对象的方式：\n\nString str = &quot;hello&quot;;\n这种方式下，由于是通过字面量直接创建，所以在编译的时候对于JVM而言是可以确定的。如果 “hello” 已存在于常量池中，那么直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。\n\nString str = new String(&quot;hello&quot;);\n这种方式下，是通过构造器创建对象，在运行时在堆中创建的。所以它不仅会在常量池中创建一个 “hello” 实例，还会在堆中创建一个 String 对象。\n\n\n可以认为，后者包含了前者。\n\n\n重载和重写的区别？\n重载 Overload 是发生在同一个类中的：\n同名的方法，但是有着不同的参数列表 (参数类型不同&#x2F;参数个数不同)。\n\n重写 Override 是发生在父类与子类之间的：\n子类对父类中提供的某方法进行逻辑的重新定义。\n规定子类被重写方法和父类被重写方法的返回值必须相同，且不能比父类被重写方法声明更多的异常。\n\n\n\n\n为什么说重写 equals() 就要重写 hashCode() ？这其实是一种规定。\n换句话说，如果我们不遵守这样的规定，那么最直接的影响是使用哈希结构的容器就可能出现重大问题，因为它们的底层依赖的正是对象的 hashCode() 方法，而你却没有重写它。例如，HashSet 本身是具有去重功能的，但是现在就出问题了：逻辑上明明相同的两个对象，理应只会有一个存在于容器中，事实却是它们都会存在。\n\n\n另外提一句：equals() 相等的两个对象，hashCode() 要保证一定相等；但是 hashCode() 相等的两个对象，equals() 并不一定要相等。\n理由也很简单：因为 hashCode() 相等也有可能是哈希冲突导致的，实质上是两个不相干的对象。\n\n\nJVM 加载 class 文件的过程？JVM中的类加载过程，都是由类加载器来实现的。当Java程序需要使用某个类时，JVM需要确保这个类已经被加载进内存中，并被成功初始化。\n\n加载：\n在经过编译后，会生成 .class 的字节码文件。通常是使用字节数组来读入字节码文件，并在内存中产生与之对应的 Class 对象。\n\n检验：\n经过了加载的步骤，其实 Class 对象还是不完整的。还需要进行一些检验操作：\n\n该类是否存在父类？如果存在，那么必须要确保父类也已经初始化完毕。\n该类是否存在初始化语句块？如果存在，那么需要依次执行这些代码。\n\n\n\n总体顺序是这样的：\n\n父类到子类依次执行静态初始代码块\n父类执行非静态初始代码块和构造器方法，然后子类执行非静态初始代码块和构造器方法\n\n\n\nJVM的类加载器包括：\n\nBootstrapClassLoader 根加载器：负责加载JVM的基础核心类库\nExtensionClassLoader 扩展加载器：负责加载JVM的扩展类库\nApplicationClassLoader 应用类加载器：负责加载 classpath 下的类文件，即使用者编写的代码\n\n为了确保同一份字节码文件不会被多个类加载器重复加载，所以 JVM 还推出了一个叫做「双亲委派」的机制：当来了一个需要被加载的字节码文件时，当前类加载器不会直接加载它，而是向上抛给它的父加载器。只有当父加载器无法处理时，才返回由当前类加载器进行处理。这样就保证了一份字节码文件仅会被一个类加载器所处理。\n\n\n创建对象的几种方式？\nnew 创建新对象\n使用反射机制\n使用 clone 机制\n通过反序列化方式\n\n\n\n关键字 final 的作用？final 表示不可变的意思，可用于修饰类、属性和方法。\n\n被 final 修饰的类不可以被继承。\n\n被 final 修饰的方法不可以被重写。\n\n被 final 修饰的属性不可变，并且必须被显式地指定初始值。\n另外，这里的不可变指的是引用不可变，而不是引用指向的内容的不可变。\n例如 final int[] nums = new int[3]; 但是数组内部的元素是可以随意修改的啊。\n\n\n\n\n方法参数传递到底是引用传递还是值传递？值传递。\n如果参数是一个基本类型的数据，那么传递的是数据的字面值本身。\n如果参数是一个引用类型的对象，那么传递的是对象的引用地址值。在被调用的过程中，对象的属性可以被修改，并影响到调用者；对象的引用也可以被修改，但是不会影响到调用者。\n\n\n字符串拼接问题String 作为不可变类，它是只读的，对象的内容是无法被改变的。如果需要修改内容，那么只能再通过创建一个新的字符串对象。如果在修改操作十分频繁的场景下，性能就显得十分低下了。\n因此，JDK5开始，引入了 StringBuilder&#x2F;StringBuffer 类，专门用于字符串拼接、删除、插入等修改操作。两者的区别在于线程安全性，由于后者的所有方法都被 synchronized 修饰，因此是线程安全的，但是效率就不如前者了。\n\n\n在JDK8以前，如果在两个字符串对象之间使用 “+” 进行拼接，会生成中间对象。不过，在Java8开始，JVM在编译期对 “+” 进行了优化，变成了基于 StringBuilder 的 append() 方法。所以，经过编译器的处理，加号拼接的性能和 StringBuilder 是一样的！\n当然，如果是循环里进行拼接操作，那么还是建议用 StringBuilder 来显式地调用，否则每循环一次就会创建一个新的 StringBuilder 对象，这肯定不如把 StringBuilder 显式地放在循环外部来得好。\n\n\n抽象类和接口的区别？\n相同点：\n\n它们天生的作用就是被继承&#x2F;实现。不可以被实例化，即不能通过 new 来创建对象。\n可以使用抽象类&#x2F;接口类的引用。如 UserService service = new UserServiceImpl();\n一个类如果继承&#x2F;实现了抽象类&#x2F;接口，那么它就需要对其中的所有抽象方法进行 @Override 重写实现。\n\n\n不同点：\n抽象类和普通类的区别就在于：它可以声明抽象方法 (注意我这里的用词是可以，不是必须)。换句话说，抽象类不一定都要有抽象方法，但具有抽象方法的都一定是抽象类。\n\n接口比抽象类更加“抽象”：抽象类可以存在非抽象方法，但是接口中的方法都必须是抽象的。\n抽象类作为一种类，可以定义构造器、成员变量，并且可以用 public, protected, default, private 来修饰；接口不能定义构造器，成员变量只能用 public 来修饰 (而且，这种变量实质上都是常量)。\n\n\n\n\n\n另外一个容易困扰的问题是：如何确定我应该使用接口还是抽象类？\n\n如果你想标记一个类的某些特征，使用接口（例如 Serializable 接口用于标记可以进行序列化的类）。\n如果你需要调用的方法与类没有关系，使用接口。\n如果你需要向其他类提供一系列的模板方法并且希望它们都能提供一个自己的版本，使用抽象类。\n\n\n\ntry…catch…finally 坑爹题\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      System.out.print(&quot;3&quot;);    &#125;  &#125;&#125;\n\n答案：31\n在 try 返回前，会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的结果 1。\n\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      return 3;    &#125;  &#125;&#125;\n\n答案：3\n在 try 返回前，会先执行 finally 语句块。然而这里的 finally 却不按套路出牌，直接 return 了。\n\n\n\n\nI&#x2F;O流有哪些？\n按照流向：输入流、输出流\n按照操作单元：字节流、字符流\n\nInputStream&#x2F;Reader：所有输入流的基类。前者是字节输入流，后者是字符输入流。\nOutputStream&#x2F;Writer：所有输出流的基类。前者是字节输出流，后者是字符输出流。\n\n\n序列化什么是序列化&#x2F;反序列化？序列化：把Java对象转为二进制流，以方便在网络中进行传输。\n反序列化：把二进制流恢复为Java对象。\n好比生活中对一些大件物品的运输，在运输时将它拆分再打包，使用时再重新组装。\n\n\n如何实现序列化？需要让该Java对象所属的类实现 Serializable 接口。\nSerializable 接口没有什么具体的作用，它只是一个标识性接口。但是如果不实现这个接口，在一些序列化场景下会出错。\n所以一般建议，创建的JavaBean类都实现 Serializable 接口。\n\n\n可以不参与序列化吗？可以。对于那些不想进行序列化的变量，可以使用关键字 transient 进行修饰。\n\n\n常见的序列化手段？\nJava对象流：一般是对象输出流 ObjectOutputStream 和对象输入流 ObjectInputStream\nJSON：很多第三方JSON技术，如Jackson、FastJson、GSON\nProtoBuff：一种轻便高效的结构化数据存储格式，可以大大减少数据传输大小，提高系统性能。\n\n\n\n泛型泛型擦除是什么？Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。也就是说，在运行的时候是没有泛型的。\n这样做的目的，主要是为了能够使JVM向下兼容，因为在JDK5之前是没有泛型的。\n\n\n反射什么是反射？普通的创建对象，是通过 new 的方式。这种方式相当于在编译时已经确定了类型信息。\n如果想在运行时动态地获取类信息，进而创建对应的类型实例，那么就需要使用反射了。\n\n\n通过反射，可以获取任意一个类的任意属性和方法，并调用它们。\n通过设置 setAccessible(true)，就连 private 的属性也可以获取到。\n\n\n\n总结而言，反射的作用主要有：\n\n在运行时创建任意一个类的对象\n在运行时获取任意一个对象的类信息\n在运行时获取任意一个对象的属性和方法，并进行调用\n生成动态代理对象\n\n\n\n反射的原理是什么？在类加载时期，JVM使用类加载器将字节码文件加载入内存。反射就是在这个期间获取类信息，然后进行各种操作。\n\n\n反射有哪些使用场景？一般而言，我们很少会直接接触并编写反射代码。但是，这并不代表反射没有用。相反，正是因为反射，才能这么轻松地使用各种框架。\n\nSpring框架中，利用反射机制来注入属性、调用方法。\nJDBC中，利用反射机制来动态加载数据库的驱动类。\n\n\n\n反射的使用姿势\n通过全限定类名创建一个对象\nClass clazz1 = Class.forName(&quot;java.lang.String&quot;);Class clazz2 = &quot;hello&quot;.getClass();\n\n创建一个实例对象\n// 第一种方式：通过class对象的 newInstance() 方法Object obj1 = clazz.newInstance();// 第二种方式：通过class对象获得对应的构造器对象，再使用构造器对象的 newInstance() 方法Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(new Class[]&#123;String.class&#125;);Object obj2 = constructor.newInstance(new Object[]&#123;&quot;hello&quot;&#125;);\n\n通过class对象获得一个属性对象 Field\n// getFields 可以获取public属性Field field1 = clazz.getFields();// getDeclaredFields 可以获取所有属性Field field2 = clazz.getDeclaredFields();\n\n通过class对象获得一个方法对象 Method\n// getMethod 可以获取public方法Method method1 = clazz.getMethod(String methodName);// getDeclaredMethod 可以获取所有方法Method method2 = clazz.getDeclaredMethod(String methodName);// 可以执行private方法method2.setAccessible(true);\n\n执行方法\nmethod.invoke(obj);\n\n\n\n\n例子：\nimport java.lang.reflect.Method;public class Main &#123;  public static void main(String[] args) throws Exception &#123;    String s1 = &quot;hello&quot;;    // 通过对象.getClass()得到一个class对象，并获得指定的方法对象    Method method = s1.getClass().getMethod(&quot;toUpperCase&quot;);    // 调用该方法    String s2 = method.invoke(s1); // HELLO  &#125;&#125;\n\n\n\n设计模式手写个单例模式类？注意点：\n\n保证构造器方法是不对外暴露的，即：将默认无参构造方法声明为 private\n通过唯一的公开静态方法向外界提供单例实例\n\n\n\n\n饿汉式 (线程安全)\npublic class Singleton &#123;   private static Singleton singleton = new Singleton();    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    return singleton;  &#125;&#125;\n\n懒汉式1 (线程不安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n懒汉式2 (synchronized 线程安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static synchronized Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n懒汉式3 (volatile+DCL 线程安全)\npublic class Singleton &#123;   private static volatile Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n懒汉式4 (静态内部类 线程安全)\npublic class Singleton &#123;    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;    private static final Singleton SINGLETON = new Singleton();  &#125;    public static Singleton getSingleton() &#123;    return SingletonHolder.SINGLETON;  &#125;&#125;\n\n\n\n总结来说，使用哪种都是可以的。即使是饿汉式的单例模式，问题也不大，因为现在的内存也不再那么稀缺了，而且这种实现的代码可读性挺好的。\n\n\n设计模式及其实际应用\nSpring的IOC容器应用了工厂模式，通过 ApplicationContext 或 BeanFactory 来创建并管理对象，然后使用反射机制来获取对象。\n\n\n\nBeanFactory\nApplicationContext\n\n\n\n懒加载\n即时加载\n\n\n不支持注解形式的依赖\n支持注解形式的依赖\n\n\n一般使用的IOC容器实现类都是 ApplicationContext 接口，它扩展了 BeanFactory 接口。\n\nSpring的对象默认是单例模式的。Spring源码中对于单例模式的实现，使用的是 volatile+DCL 方式。\n\nSpringAOP 使用了代理模式。\n具体实现可能是JDK动态代理，也可能是CGLib动态代理。这取决于目标代理对象是否是一个接口的实现类，如果是则会使用JDK动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n\n\n","tags":["Java","八股文"]},{"title":"「MyBatis」 浅记一哈","url":"/2022/06/11/%E3%80%8CMyBatis%E3%80%8D%E6%B5%85%E8%AE%B0%E4%B8%80%E5%93%88/","content":"映射器配置我会配合着实例来说明，而几乎所有的例子都会使用一个 User 类型的 JavaBean，所以我需要先给出它的定义：\npublic class User &#123;    private Long id;    private String userName;    private String password;    private String address;        // getter &amp; setter...&#125;\n\n另外，创建一个与之对应的接口 UserMapper，其中定义了几个基本操作方法：\n@Mapperpublic interface UserMapper &#123;    public User getById(Long id);    public void insert(User user);    public void delete(Long id);&#125;\n\n\n\n&lt;select&gt;初识select 可以算作是最常用的元素了，因为几乎任何业务都会涉及查询操作。\n我们先看一下最基本的使用方式：\n&lt;select id=&quot;getById&quot; resultType=&quot;twq.entity.User&quot; parameterType=&quot;Long&quot;&gt;\tSELECT *     FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n我们直接从user表中查询一条数据出来，查询的结果是一个User对象，即：MyBatis会自动帮我们把查询的结果转成User对象。这是怎么做到的？是因为 JavaBean的属性名和数据库表中的字段名能够完全一致地对应上，那么就可以了。\n\n\n别名问题我们习惯于将 JavaBean 中的属性名使用驼峰式命名法（userName），而数据库中的字段使用下划线命名法（user_name）。那么这样不就会导致转换失败了吗？\n对于这种非常常见的场景问题，有三种解决方案：\n\n在 sql 语句中起别名\n&lt;select id=&quot;getById&quot; resultType=&quot;twq.entity.User&quot; parameterType=&quot;Long&quot;&gt;\tSELECT     \tid,    \tuser_name as userName,    \tpassword,    \taddress    FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n这样做的想法是：使数据库中的字段名向JavaBean属性名看齐。由此一来，两者之间的名字又完全对应上了~\n\n使用 mapUnderscoreToCamelCase 属性\n在 MyBatis 的配置文件中，有一个&lt;settings&gt; 节点，该节点中可包含多个 &lt;setting&gt; 节点。&lt;setting&gt; 节点有一个属性叫做mapUnderscoreToCamelCase，该属性表示是否开启自动驼峰命名规则映射，即从经典的数据库列名 A_COLUMN 映射为经典的JavaBean属性名 aColumn 的映射。\n要开启这个属性，只需要在 MyBatis 的配置文件中，添加如下代码：\n&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;\n\n但是使用这种方式，就要求我们的数据库字段命名和JavaBean属性命名都非常遵守命名规范才行，比较严格。但如果你确实是这么遵守的，那么就会变得很方便了~所以这个方案属于是见仁见智，视项目情况而言。\n\n使用 &lt;resultMap&gt; 元素\n这个方法算是别名问题的最终解决方案了。\n我们可以在Mapper中定义 &lt;resultMap&gt; 来解决一些复杂的字段映射问题。\n以 userMapper 为例：\n&lt;resultMap id=&quot;userMap&quot; type=&quot;twq.entity.User&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot; javaType=&quot;long&quot; jdbcType=&quot;NUMERIC&quot;/&gt;    &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;    &lt;result property=&quot;password&quot; column=&quot;password&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot; javaType=&quot;string&quot; jdbcType=&quot;VARCHAR&quot;/&gt;&lt;/resultMap&gt;\n关于上面的 &lt;resultMap&gt; 需要说明两点：\n\n\n&lt;resultMap&gt; 的id作为它自身的唯一标识符。如果后续想要引用这个 &lt;resultMap&gt; 的时候，就是通过指定这个id名来引用的。\n定义的 type 属性，用于指明这个 &lt;resultMap&gt; 对应的是哪个JavaBean。\n\n在一个 &lt;resultMap&gt; 节点中，存在一个 &lt;id&gt; 节点和多个 &lt;result&gt; 节点。前者是主键字段，后者是其他字段。\nproperty 表示JavaBean中的属性名，column 表示数据库中的字段名，javaType 表示JavaBean中的属性类型，jdbcType 表示数据库中的字段类型。\n\n\n\n\n\n如此定义完毕后，我们就可以很放心且简单地使用 &lt;select&gt; 查询了，只要记得引用这个 &lt;resultMap&gt;，那么别名问题就得到解决了：\n&lt;select id=&quot;getById&quot; resultMap=&quot;userMap&quot; parameterType=&quot;Long&quot;&gt;\tSELECT *     FROM user     WHERE id = #&#123;id&#125;&lt;/select&gt;\n\n\n\n多条件查询在真正开发中，多条件的查询语句是非常常见的需求。比如我现在需要根据用户名和地址来查找用户，那么我大致可以想象出来：我需要将 userName 和 address 作为方法参数传入，而方法的返回值是一个 User 对象。\n对于多条件参数的情况，可以有以下三种解决方案：\n\n使用 Map 集合对传递的所有参数进行封装\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(Map&lt;String, String&gt; map);\n\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    // 封装参数数据    Map&lt;String, String&gt; map = new HashMap&lt;&gt;(2);    map.put(&quot;addr&quot;, &quot;上海&quot;);    map.put(&quot;username&quot;, &quot;张三&quot;);    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(map);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，将 Map 的数据提取出来（其实就是 key 对应的 value），作为查询参数：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;&lt;/select&gt;\n\n\n\n不过，一般不使用这种方式，因为 Map 的 key 都是硬编码手写的，容易写错；而且以 Map 的方式作为传参也不够直观，可读性不高。\n\n使用 @Param 注解\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(@Param(&quot;username&quot;) String username, @Param(&quot;addr&quot;) String addr);\n\n如此一来，MyBatis 会以 @Param 提供的名称为准。相当于说，@Param 是key，传参是value。\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(&quot;张三&quot;, &quot;上海&quot;);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，将这些数据提取出来，作为查询参数：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;&lt;/select&gt;\n\n这种方式比较常用。因为从Java代码的角度看，这样的可读性高很多，十分直观，也不必像第一种方案，还需要考虑 Map 的key到底是什么。\n\n自定义一个JavaBean对象，封装其中的所有传递参数\n第二种方案其实已经很完美了。但是如果有一个需求，它的查询条件特别多，由此需要的传参也变得特别多。这种情况下，如果还按照第二种方案的写法，那么代码整体看上去就显得十分庞大了，你可能会看到满屏的 @Param 。。。\n其实，MyBatis 是支持用户在传参时直接传入对象的，将需要的数据字段封装起来：\npublic class UserParams &#123;    private String username;    private String addr;    // 你可以想象一下还有十多个属性...    // getter &amp; setter...&#125;\n\n在接口中定义如下方法：\nList&lt;User&gt; getByUsernameAndAddress(UserParams params);\n\n编写Java组装数据：\n@Autowiredprivate UserMapper userMapper;public void test() &#123;    UserParams params = new UserParams();    params.setUsername(&quot;张三&quot;);    params.setAddr(&quot;上海&quot;);    params.setXxxx(obj);    // ...    List&lt;User&gt; list = userMapper.getByUsernameAndAddress(params);    for (User user : list) &#123;        System.out.println(user);    &#125;&#125;\n\n在 userMappper 中，指定 parameterType 为 UserParams ，然后将其中的属性都提取出来：\n&lt;select id=&quot;getByUsernameAndAddress&quot; resultMap=&quot;userMap&quot; parameterType=&quot;twq.entity.UserParams&quot;&gt;\tSELECT *     FROM user     WHERE    \taddress = #&#123;addr&#125;    \tand user_name = #&#123;username&#125;    \tand xx_xx = #&#123;xxxx&#125;    \t&lt;!-- and .... --&gt;&lt;/select&gt;\n\n\n\n总的而言，第二种和第三种都是在开发中最常用的传参方式，根据需求的具体情况（参数多or少）自己进行选择。\n\n\n\n\n&lt;insert&gt;主键值回填一般来说，我们在创建表的时候，都会将主键id设置为自增长auto_increment。在这种情况下，当我插入一条新的数据时，是不需要指定id字段的值的（我也不知道id字段的值），传入null即可。但是当我插入成功后，我希望 MyBatis 会回填id字段，赋值给对象的id属性。\n这也是非常常见的一个需求，我需要知道刚刚插入成功的数据的id是多少。\n在 userMappper 中，指定数据库的主键字段、主键生成策略：\n&lt;insert id=&quot;insert&quot; parameterType=&quot;twq.entity.User&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;    INSERT INTO user(user_name,password,address)     VALUES (#&#123;userName&#125;,#&#123;password&#125;,#&#123;address&#125;)&lt;/insert&gt;\n\n\nkeyProperty 属性指定哪个是主键字段\nuseGeneratedKeys 就是告诉 MyBatis，这个主键是否使用了数据库内置的生成策略\n\n编写Java代码：\n@Autowwiredprivate UserMapper userMapper;public void test() &#123;    // 构造一个对象（注意，我没有给id属性赋值，意味着它的id属性是null）    User user = new User();    user.setUsername(&quot;张三&quot;);    user.setPassword(&quot;123456&quot;);    user.setAddress(&quot;上海&quot;);    userMapper.insert(user);    // 插入完成后，MyBatis 会自动回填id属性    // 不再是 null    System.out.println(user.getId());&#125;\n\n\n\n自定义主键值有的时候，我们不想让主键按照自增的规则来变化，而是想有一套自己的规则逻辑。\n解决方案：使用 &lt;selectKey&gt; 来自定义主键的生成策略。\n\n\n作为实例，我们先定义一个主键生成规则：初始时id为1，之后每个新的id自增2。\n在 userMapper 中使用 &lt;selectKey&gt; ：\n&lt;insert id=&quot;insert&quot; parameterType=&quot;twq.entity.User&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;long&quot; order=&quot;BEFORE&quot;&gt;    \tSELECT (ifnull(max(id), -1) + 2) as nextId        FROM user    &lt;/selectKey&gt;    INSERT INTO user(id, user_name, password, address)     VALUES (#&#123;id&#125;, #&#123;userName&#125;, #&#123;password&#125;, #&#123;address&#125;)&lt;/insert&gt;\n\n关于上面的 &lt;selectKey&gt; 需要说明几点：\n\n\n&lt;keyProperty&gt; 属性表示「查询语句的结果」所赋值的目标属性。在这里就是id\n\n&lt;resultType&gt; 属性表示查询结果的返回类型，注意这个类型要和 User 中id的类型保持一致。在这里就是 long\n\n&lt;order&gt; 属性表示「选择主键」和「插入操作」之间的顺序关系。\n\norder=&quot;BEFORE&quot;：在执行插入操作之前先选择主键\norder=&quot;AFTER&quot;：执行完插入操作之后再选择主键\n\n这里需要特别注意：诸如 MySQL 支持自增长类型的数据库，必须设置 order=&quot;AFTER&quot;；诸如 Oracle 取序列的数据库，必须设置 order=&quot;BEFORE&quot;\n\n\n\n\n\n编写Java代码：\n@Autowwiredprivate UserMapper userMapper;public void test() &#123;    // 构造一个对象（注意，我没有给id属性赋值，意味着它的id属性是null）    User user = new User();    user.setUsername(&quot;张三&quot;);    user.setPassword(&quot;123456&quot;);    user.setAddress(&quot;上海&quot;);    userMapper.insert(user);    // 插入完成后，MyBatis 会自动回填id属性    // 不再是 null    System.out.println(user.getId());&#125;\n\n\n\n&lt;delete&gt; &amp; &lt;update&gt;这两者没有什么特别需要说明的地方，要说的基本都在 &lt;select&gt; 和 &lt;insert&gt; 中涉及到了。所以不再赘述了。\n\n\n&lt;resultMap&gt;在前面，已经涉及到了 &lt;resultMap&gt; 的部分内容，包括 &lt;id&gt; 和 &lt;result&gt; 两个节点。但实际上，&lt;resultMap&gt; 还包含着更多的节点：\n&lt;resultMap&gt;    &lt;constructor&gt;        &lt;idArg/&gt;        &lt;arg/&gt;    &lt;/constructor&gt;    &lt;id/&gt;    &lt;result/&gt;    &lt;association property=&quot;&quot;/&gt;    &lt;collection property=&quot;&quot;/&gt;    &lt;discriminator javaType=&quot;&quot;&gt;        &lt;case value=&quot;&quot;&gt;&lt;/case&gt;    &lt;/discriminator&gt;&lt;/resultMap&gt;\n\n\n\n接下来，就一个个介绍。\n&lt;constructor&gt;它主要是用来配置构造方法的。\n在默认情况下，MyBatis 是调用实体类的无参构造方法来创建实体类对象，然后再给各个属性进行赋值。但是有些实体类可能并没有无参构造方法（只有显式的有参构造方法），这时候如果不做特殊的配置处理，那么 &lt;resultMap&gt; 在生成实体类的时候就会报错（因为它找不到无参构造方法！！）\n所以解决办法就很显然了：要么给实体类配置一个无参构造方法，要么就是在 &lt;constructor&gt; 中进行相应的配置。前者的实现就没什么好说的了，我们直接看后者是如何配置的：\n&lt;resultMap id=&quot;userResultMap&quot; type=&quot;twq.entity.User&quot;&gt;    &lt;constructor&gt;        &lt;idArg column=&quot;id&quot; javaType=&quot;long&quot;/&gt;        &lt;arg column=&quot;userName&quot; javaType=&quot;string&quot;/&gt;        &lt;arg column=&quot;password&quot; javaType=&quot;string&quot;/&gt;        &lt;arg column=&quot;address&quot; javaType=&quot;string&quot;/&gt;    &lt;/constructor&gt;&lt;/resultMap&gt;\n\n这样，MyBatis在构造实体类对象的时候，就会按照 &lt;constructor&gt; 的配置来对应地给属性赋值了。\n\n\n&lt;association&gt;它主要是用于一对一的联级查询。\n让我们现在开始，忘记之前的 User 实例。假设我现在有两张表：表province存储省份，另一张表province_abbr存储省份的简称。它们之间以一个字段 pid 的方式来连接，表示省份的id。\n这两张表对应的JavaBean如下给出：\npublic class Province &#123;    private Long id;    private String name;    private ProvinceAbbr provinceAbbr;        // getter &amp; setter...&#125;\n\npublic class ProvinceAbbr &#123;    private Long id;    private String name;    // 对应于 Province 中的id    private Long pid;        // getter &amp; setter...&#125;\n\n创建 ProvinceAbbrMapper 接口 &amp; 编写 provinceAbbrMapper.xml：\n@Mapperpublic interface ProvinceAbbrMapper &#123;    ProvinceAbbr getProvinceAbbrByPid(Long id);&#125;\n\n&lt;select id = &quot;getProvinceAbbrByPid&quot; parameterType=&quot;long&quot; resultType=&quot;twq.entity.Province&quot;&gt;    SELECT *     FROM province_abbr    WHERE pid = #&#123;id&#125;&lt;/select&gt;\n\n创建 ProvinceMapper 接口 &amp; 编写 provinceMapper.xml：\n@Mapperpublic interface ProvinceMapper &#123;       List&lt;Province&gt; getAllProvince();&#125;\n\n&lt;resultMap id=&quot;provinceResultMapper&quot; type=&quot;twq.entity.Province&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;association property=&quot;provinceAbbr&quot; column=&quot;id&quot; select=&quot;twq.mapper.ProvinceAbbrMapper.getProvinceAbbrByPid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllProvince&quot; resultMap=&quot;provinceResultMapper&quot;&gt;    SELECT *     FROM province&lt;/select&gt;\n\n对于 &lt;association&gt; 需要说明几点：\n\n\nselect 属性表示一个具体的执行方法，即一个具体的SQL语句，然后将这个执行结果再赋值给这里的 property 指定的属性\ncolumn 属性表示方法传参的属性名。在这里，我应传入省份id作为查询条件\nproperty 属性表示将 select 的执行结果赋值给哪个属性。在这里，应该赋值给 provinceAbbr\n\n\n\n\n&lt;collection&gt;它主要是用于一对多的联级查询。\n还是使用上面的省份例子。不过现在又多了一张城市表city，因为每个省份下包含着很多城市。city表中也有一个pid字段，用于表示这个城市是属于哪个省份的。\ncity表对应的JavaBean如下给出：\npublic class City &#123;    private Long id;    private String name;    private Long pid;        // getter &amp; setter...&#125;\n\n另外，我们还需要去更新一下 Province，增加一个 cities 属性：\npublic class Province &#123;    private Long id;    private String name;    private ProvinceAbbr provinceAbbr;    private List&lt;City&gt; cities;        // getter &amp; setter...&#125;\n\n创建 CityMapper 接口 &amp; 编写 cityMapper.xml：\n@Mapperpublic interface CityMapper &#123;    List&lt;City&gt; findCitiesByPid(Long id);&#125;\n\n&lt;select id=&quot;findCitiesByPid&quot; parameterType=&quot;long&quot; resultType=&quot;twq.entity.City&quot;&gt;    SELECT *     FROM city     WHERE pid=#&#123;id&#125;&lt;/select&gt;\n\n更新 provinceMapper.xml：\n&lt;resultMap id=&quot;provinceResultMapper&quot; type=&quot;twq.entity.Province&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;association property=&quot;provinceAbbr&quot; column=&quot;id&quot; select=&quot;twq.mapper.ProvinceAbbrMapper.getProvinceAbbrByPid&quot;/&gt;    &lt;collection property=&quot;cities&quot; column=&quot;id&quot; select=&quot;twq.mapper.CityMapper.findCitiesByPid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllProvince&quot; resultMap=&quot;provinceResultMapper&quot;&gt;    SELECT *     FROM province&lt;/select&gt;\n\n&lt;collection&gt; 中的各个属性的含义和 &lt;association&gt; 是一样的，所以就不再说明了。\n","tags":["MyBatis"]},{"title":"「多线程」 时间管理大师","url":"/2022/05/17/%E3%80%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8D%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%E7%A8%8B%E5%BA%8F%E6%8C%87%E5%8D%97/","content":"线程线程的几种状态？\n新建 New\n就绪 Runnable\n运行 Running\n阻塞 Blocked\nI&#x2F;O ：阻塞态，仅释放CPU资源，但不会释放占有着的锁。如 sleep()\nWaiting ：等待态，会释放CPU资源和占有着的锁。如 wait()\nTimed Waiting ：带有超时的等待态\n\n\n结束 Terminated\n\n\n\n线程和进程的区别是什么？\n首先，可以从宏观的角度看待它们的关系：一个程序至少有一个进程，一个进程至少有一个线程。\n进程是操作系统进行资源分配的最小单元，每个进程都有自己独立的内存空间。进程与进程之间是不共享资源的。如果需要，那么就要使用通信技术（socket、channel）。\n线程是操作系统进行资源调度的最小单元。除了线程自己的函数堆栈等，线程与线程之间是共享资源的（这也是为什么会存在线程安全这一问题）。\n打个比喻：进程是水杯，线程是水杯里的水。人喝的是水而不是水杯，但是如果没有水杯来装水也是不行的。\n\n进程可以看作是重量级的线程。在多任务处理机的环境下，如果直接使用进程作为调度单元，那么在资源切换时的开销是比较大的。为了提高执行效率，所以引入了线程来取代进程的资源调度功能。\n\n\n\n\n上下文切换是什么？因为多线程是共用计算机上的CPU资源的，并且在一般情况下，线程数都是大于CPU核心数的。为了让所有线程都有执行的机会，所以需要进行线程之间的调度切换。这种切换就是上下文切换。在切换前，需要保存CPU的状态；在切换回来后，又需要恢复CPU的状态，使得线程能够正确地从中断处恢复执行。\n在Java中，线程调度采用的是抢占式的方式。一个线程的时间片到后，操作系统会根据线程优先级、线程饥饿情况、CPU空闲率等多方面因素，选出下一个线程，并分配时间片给它。\n可以通过 setPriority() 来设置线程的优先级。不过，你不能指望靠它来保证，因为最终权还是在底层的操作系统。但是，如果不是特别需求，就不要改动线程的优先级，因为这可能会因为设置不当，造成线程饥饿问题（当前线程被一个高优先级的线程吞噬掉了所有的CPU时间）。\n\n\n什么是线程饥饿？线程饥饿指的是：一个线程因为某种原因无法获得所需资源，导致一直无法执行下去。\n\n\n听起来和死锁有点像：死锁是指两个及以上的线程在执行时，因互相需要对方的资源，却又不肯先释放自己持有的资源，导致全都永远等待在原地。\n死锁和饥饿的相同点是：二者都是因为资源的竞争引起的问题。\n死锁和饥饿的不同点是：\n\n在死锁中，资源的占有方和资源的拥有方互相请求对方的资源；在饥饿中，当前线程只是迟迟得不到所需资源，但是并不在乎这个资源是谁给的！\n死锁一定涉及多个线程，而饥饿可能只有一个线程。\n当饥饿发生时，除了饥饿线程得不到执行机会，其他线程都还是正常执行的；当死锁发生时，可能最终会使整个系统都陷入死锁并崩溃。\n\n\n\nCallable 和 Future 的区别？Callable 接口类似于 Runnable (从名字也可以看得出) ，不过 Runnable 不会返回执行结果，也无法抛出返回结果的异常。但是 Callable 就弥补了这一缺陷，可以认为是带有回调功能的 Runnable ：能够返回异步执行的结果，然后由 Future 接收到。\n\n\n线程之间如何进行通信？\n使用 Object 类中提供的 wait() &amp; notify()/notifyAll() 、park() &amp; unpark() 机制\n使用 concurrent 包下的同步工具类，如 CountDownLatch 、CyclicBarrier 。\n\n\n\n为什么要把 wait()、notify() 这种方法定义在 Object 类中？\nJava 中的每个对象都有一个对应的 Monitor 对象。当该对象调用了 wait()、notify() 这些方法时，其实就是在向 Monitor 对象传达信息：等待对象的锁 &#x2F; 通知其他线程对象的 Monitor 是可用的。\n在 Java 的线程中，并没有提供线程同步的方法。为了使得每个类都具有线程间通信的能力，所以给每个类都应该提供一个类似 wait() 、 notify()/notifyAll() 的方法。而 Object 作为所有类的父类，将这样的方法直接放在 Object 中也是十分合适的。\n\n\n\n保证线程安全的方案？\n使用 synchronized 关键字\n\n使用 Lock 接口下的实现类\n\n使用线程的本地局部变量 ThreadLocal\n简单来说就是一种以空间换时间的数据隔离思想：在每个线程中，维护了一个 ThreadLocalMap，用 set() &#x2F; get() 来使用当前线程的数据，最后将这个 Map 挂到当前线程下，所以 Map 就只属于这个线程了。数据不再共享，自然就不存在线程安全的问题了。\n\n将对象设置为不可变的 (即对象一旦被创建，就不能再改变了)\n比如基本类型的包装类都是不可变类。另外，String类型也是不可变的，具体可以参考这篇文章：「String」不可变类的原因！\n\n另辟空间，在操作结束后替换引用地址 (如 CopyOnWriteArrayList)\n\n\n\n\n线程池为什么要用线程池？直接 new Thread() 不好吗？\n创建线程对象是一个开销较大的操作，无论是对CPU还是对内存占用。所以，如果一个任务就开辟一个新线程，性价比实在是太低了。\n\n通过 new Thread() 得到的线程是不易管理的（一般被称为野线程），甚至可以无限制的创建！如此一来，如果使用者使用不慎，可能就导致整个操作系统瘫痪了……🙃\n\n通过 new Thread() 得到的线程也不易于扩展。比如，想要定时执行、定期执行的话，都是不容易实现的。\n\n\n\n\n因此，引入了一个名为线程池的思想，完美解决了上述缺点。\n\n复用已创建好的那些线程，从而降低了资源消耗，并且便于管理\n可以很方便地进行功能扩展，达到定时执行等效果\n\n不过，如果阅读过阿里巴巴开发手册就会发现，不建议使用 Executors 来创建线程。主要原因是：用这样的方式来创建线程，使用者对于这个默认线程池的规则是不够了解的，这就有可能导致使用不当。\n所以，一般建议使用 ThreadPoolExecutor 来创建线程池，并由使用者来设置线程池的一些核心参数，保证使用者对于这个自定义线程池的规则是了解的。\n\n\n常用的线程池\nnewCachedThreadPool()：创建一个可缓存线程池，如果线程池的大小超过实际需要，在超时时间后会回收空闲线程。当任务数增加时，又可以动态地添加新线程来处理任务。\nnewFixedThreadPool()：创建一个大小固定的线程池。每次提交一个任务就会创建一个线程，直至到达线程池的最大大小。超出的线程会在阻塞队列中等待。\nnewSingleThreadExecutor()：创建一个单线程化的线程池，使用唯一的工作线程来执行所有任务。可以保证所有任务都是按照顺序来执行的。\nnewScheduledThreadPool()：创建一个大小固定的线程池。支持定时及周期性任务执行。\n\n\n\n解读一下线程池的7大核心参数？\ncorePoolSize : 核心线程数\nmaximumPoolSize : 最大线程数 (核心线程数+救急线程数)\nkeepAliveTime : 空闲的救急线程的最大存活时间\nTimeUnit : keepAliveTime 的时间单位\nworkQueue : 阻塞队列，用于存放那些待执行的任务\nthreadFactory : 创建线程池中的工作线程的线程工厂 (一般都是默认即可)\nrejectedHandler : 拒绝策略。当线程池中的阻塞队列已满，且线程数已达到最大线程数时，执行拒绝策略。\nAbortPolicy : 拒绝新任务并抛出异常\nDiscardPolicy : 拒绝新任务，但不抛出异常\nCallerRunsPolicy : 使用当前调用的线程来执行此任务 (相当于为了让任务不失败，于是让它插队)\nDiscardOldestPolicy : 抛弃阻塞队列头部 (最旧) 的一个任务，并执行当前任务\n\n\n\n\n\n对于阻塞队列的使用，需要进行一点说明：\n\n如果使用的是 LinkedBlockingQueue 等无界队列，那么可以无限地向线程池中添加任务 (因为阻塞队列不会满) 而不会触发拒绝策略。并且，也不会触发救急线程。所以，相当于 maximumPoolSize, keepAliveTime, TimeUnit, rejectedHandler 都是无意义的参数。\n如果使用的是 ArrayBlockingQueue 等有界队列，那么如果阻塞队列已满，就会触发救急线程。如果救急线程也达到了上限，那么再有新任务时就会触发拒绝策略。\n\n\n\n线程池的执行流程？\n当线程数小于 corePoolSize 时，使用核心线程来执行任务\n当线程数大于 corePoolSize 时，将多余的任务放入阻塞队列\n当阻塞队列已满时，启动救急线程来执行\n当阻塞队列已满，且线程数已达到 maximumPoolSize 时，执行拒绝策略\n当阻塞队列不再满时，已创建的那些救急线程就进入空闲状态。如果它们的空闲时间超过 keepAliveTime ，就会回收这些救急线程\n\n\n\nsubmit() 和 execute() 的区别？这两者都是用于向线程池提交任务的。\n区别在于：\n\nexecute() 没有返回值\nsubmit() 返回值是一个 Future 对象，从而可以得到异步执行的结果\n\n\n\nsynchronized 关键字synchronized 修饰在不同的位置，各代表什么？\n如果 synchronized 修饰的是一个实例方法，则上锁的是调用该方法的对象实例\n如果 synchronized 修饰的是一个静态方法，则上锁的是所在类的Class实例\n如果 synchronized 修饰的是一个代码块，则上锁的是传入 synchronized 括号内的对象实例\n\n请知道一条原则：同步块的作用范围越小越好。\n\n\nsynchronized 的底层原理是什么？前置知识点：Mark Word 、Monitor 对象\n无论 synchronized 修饰的是什么，对应的锁都是一个实例对象。\n一个对象，是由三部分组成的：对象头、对象实际内容、对齐填充字段。synchronized 的原理，就在于对象头之中的 Mark Word 部分。这部分就负责记录对象关于锁的信息。\n\n另外，每个对象都会有一个 Monitor 对象，存储着当前持有该 (对象) 锁的线程，并维护一个阻塞等待该 (对象) 锁的等待队列。\n\n\n\n\n锁的优化在JDK1.6之前，锁的操作都是重量级的：monitor对象直接存储持有着锁的线程的id，并设置 Mark Word 中的 monitor对象地址，把其他阻塞等待的线程都加入等待队列中。这个加锁的过程是依赖底层操作系统的 mutex 指令的，存在用户态与内核态之间的切换，所以性能损耗十分严重。\n在JDK1.6之后，引入了偏向锁、轻量级锁的概念，它们是在JVM层面的规定，所以就不依赖于底层操作系统，性能得到大幅提升。\n总体流程是：无锁 &#x3D;&#x3D;&gt;  偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁。并且，锁只有升级，不存在降级。\n从使用层面看，至始至终都是关键字 synchronized，即：这种优化是内部的，对于使用者而言是无感知的。引入了偏向锁和轻量级锁这两个概念，就是为了能够尽可能地提高并发执行时的效率问题。\n\n偏向锁\nJVM认为在同一时间，只会有一个线程来执行同步块中的代码，即：这是一个没有竞争的环境。\n所以直接在 Mark Word 中记录该线程。如果一个线程想要获得锁，就直接比对线程ID与 Mark Word 中存放的是否一致，一致就可以直接获得这个锁；否则，用CAS来尝试修改 Mark Word，将记录改为当前线程ID。\n如果CAS修改成功，那么线程仍旧可以获得这个锁；否则，说明当前环境是存在竞争的，于是升级为轻量级锁。\n\n轻量级锁\n当前线程会在栈帧下创建 Lock Record，把 Mark Word 的信息都拷贝进去。如果一个线程想要获得锁，先用CAS来尝试将 Mark Word 信息修改为该线程的 Lock Record。\n如果CAS修改成功，那么线程就获取到了这个锁 (轻量级) ；否则，进行自旋重试。当自旋一定次数后仍不能获得锁，就升级为重量级锁。\n\n\n总结：\n\n只有一个线程进入临界区：偏向锁\n多个线程交替进入临界区：轻量级锁\n多个线程同时进入临界区：重量级锁\n\n\n\n关于 java.util.concurrent乐观锁和悲观锁是如何理解的？\n乐观锁：非常乐观，认为每次拿到的数据都没有被人修改过，所以不会上锁。\n在进行更新的时候，使用的是CAS算法：先判断当前值是否是预期值，如果是，则可以进行写操作写入新值；否则，被告知这次竞争失败，然后进行再次尝试，直到成功。\n乐观锁的缺点是：\n\nABA 问题\n线程1读取了某变量的值是A 。此时线程2也读取了该变量，并且线程2将它改为了B ，后又改回为A 。\n然后线程1进行CAS操作，发现当前值与预期值一致，均为A ，于是放心地写入了新值。\n以上过程，线程1的CAS操作是成功的，但这是有潜在隐患的。\n从 JDK1.5 开始，提供了一个名为 AtomicStampedReference 的类来解决ABA问题，即增加了一个比对元素：版本号。每次操作后都会更新这个版本号。这样，即使是同一个值，如果版本号不一致，也被认为是CAS失败。\n\n如果资源竞争十分激烈，那么CAS自旋的概率会很高，从而导致大多数时间都是在浪费CPU资源，效率反而不如 synchronized 。\n\n只能保证对于一个变量的原子操作。如果需要保证对于多个变量的原子操作，那么就需要用锁了。\n\n\n\n悲观锁：非常悲观，总是做最坏的打算，认为每次拿到的数据都是被人修改过了的，所以每次在拿到数据时都会上锁，这样其他线程就拿不到了。\nJava 的同步关键字 synchronized 就是悲观锁的。此外，传统的关系型数据库 (例如MySQL) 里面的行锁、表锁、读锁、写锁等，用到的也都是悲观锁的机制。\n悲观锁是足够安全的，但是缺点也很明显：每次操作都要上锁，结束后再释放锁，比较耗时。\n\n\n在大多数情况下 (竞争不是特别激烈) ，乐观锁的性能是好于悲观锁的。\n\n\nLock 接口是什么？对比传统的同步，有什么优势？Lock 接口是同步的扩展，使用起来更加**灵活 **。典型的实现类是 ReentrantLock 。\n\n支持公平&#x2F;非公平的模式选择 (出于性能考虑，一般都是默认非公平模式)\n允许线程在等待锁时被中断\n允许让线程去尝试获得锁，如果无法获得，可以选择立即返回不再等待或是等待一段时间 (带有超时时间)\n配合条件变量 Condition 来使用，达到 wait&#x2F;notify 的效果，并且是支持中断、超时的\n\n不过，需要注意的是：使用 synchronized 无需考虑释放锁的操作，因为这是自动的；而 Lock 就必须要求使用者手动来释放锁资源。因此，最规范的写法就是在 finally 块中进行 unlock() 释放操作。\n\n\n公平锁和非公平锁的区别是什么？简单来说，公平锁模式是讲究先来后到的顺序的；非公平锁模式是谁准备好了就谁来。\n公平锁：在竞争环境下，先到达临界区的线程一定比后到达临界区的线程更早地获得锁。\n非公平锁：在竞争环境下，先到达临界区的线程未必比后到达临界区的线程更早地获得锁。\n所以，决定它们的因素就是：如果一个线程到达了临界区，它是否会直接尝试获得锁 (非公平) ，还是会直接进入等待队列 (公平) 。\n\n\n并发容器类\nCopyOnWriteArrayList (性能较差的同步容器是 Vector)\n主要特点是：读写分离。\n\n实际的写操作发生在复制的数组上，而读操作还是在原始数组中进行，从而实现读写分离，互不影响。\n在写操作时需要加锁，防止并发写入时导致写入数据丢失。\n在写操作结束后，把原始数组的引用指向新的复制数组。\n\n缺点是：\n\n由于每次写操作都会复制出一个新的数组，所以是比较耗费内存的。\n只能保证最终一致性，无法保证实时一致性。\n\n我们可以从中学到的线程安全解决思路是：通过另辟空间，来解决并发问题。\n\nConcurrentHashMap (性能较差的同步容器是 HashTable)\n底层数据结构与普通的 HashMap 一样，同为数组+链表&#x2F;红黑树。\n\n在 put() 写操作时需要加锁，不过使用的是 CAS算法 (在JDK8之前，使用的是分段锁的方式)\n在 get() 读操作时不加锁，value属性通过 volatile 关键字进行修饰，保证了内存可见性，即每次 get() 得到的都是最新值\n\n\n\n\n\n同步工具类\nCountDownLatch\n在创建时传入一个参数 new CountDownLatch(int initial) 作为计数次数。\n其他线程每调用一次 countDown() 方法，计数器减1。\n当计数器被减为0时，主线程从 latch.await() 处重新被唤醒，然后继续执行后续代码。\n\nCyclicBarrier\n和 CountDownLatch 的作用一样，只不过 CountDownLatch 只能使用一次，使用之后就会失效，而 CyclicBarrier 可以反复使用。\n\nSemaphore\n在不超过设定上限的线程数的情况下，允许多个线程并行执行。主要用于限流之类的操作，限制某段代码块的并发数。打个比喻：Semaphore 就好比是一个停车场，允许同时停放多辆车辆，但也总有一个上限。\n如果 Semaphore 的构造函数中传入的参数是 1 ，就相当于一个 synchronized 了。\n\n\n\n\nAQS是什么？全称是 AbstractQueuedSynchronizer 。作为一个抽象类，相当于是很多同步容器的框架模板，其中制定了很多用于保证线程安全的基本规则。\n常用的实现类有 ReentrantLock, Semaphore, FutureTask 等。\n\n\nAQS的原理底层是使用一个双向链表来维护一个FIFO的等待队列，还有一个 state 的状态变量。\n队列中存储的实体是 Node 节点，记录了当前的状态值、同步模式 (独占 &#x2F; 共享) 、前驱节点和后继节点。\n总体流程是：把需要等待的线程以 Node 节点的形式加入到等待队列中，用 state 变量来维护当前锁的状态。\n当调用了 lock() 方法时：\n\n使用CAS来尝试获得锁。如果成功，那么就可以执行同步块中的代码；\n\n否则，调用 acquire() 方法，判断 state 是否为0。如果等于0，说明没有其他线程持有这把锁，那么就再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n\n否则，说明有线程正在持有着这把锁。于是再判断当前线程是否持有着锁，如果是，那么更新 state 的值加1 (这里正是可重入的体现) ，然后就可以执行同步块中的代码；\n\n否则，只能将当前线程加入等待队列中，然后将自己 park() 挂起，等待后续被唤醒后再继续进行CAS尝试……直至成功，然后执行同步块中的代码。\n在加入等待队列的过程中，其实还有一些细节：\n\n节点入队后，会判断前驱节点是否为头节点。如果是头节点，那么就可以再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n否则，会把前驱节点的状态设置为 SIGNAL (-1) ，用以表示后续节点需要被唤醒，而这个任务就交给了前驱节点。\n\n\n\n当调用了 unlock() 方法时，就非常简单了：把 state 置0，然后唤醒等待队列中第一个需要被唤醒的节点 (节点的 state 小于0) ，然后这个节点就会进行CAS尝试来获得锁。\n\n\nAQS的同步方式是什么？AQS支持两种同步方式：独占式和共享式。\n独占式，锁只会被一个线程持有。如 ReentrantLock\n共享式，多个线程可以同时执行。如 Semaphore, CountDownLatch\n\n\nvolatile 关键字volatile 的作用是什么？\nvolatile 可以保证内存可见性。被 volatile 修饰的变量在进行写操作后，其他线程能马上读到最新值。\n简单地说，就是在对一个 volatile 变量进行写操作前，JMM会插入一个写屏障，保证所有线程都可以马上看见这个新值；在对一个 volatile 变量进行读操作前，JMM会插入一个读屏障，保证任何数据的更新对所有线程都是可见的。\n\nvolatile 可以保证不会发生指令重排序的问题。最典型的使用场景就是懒汉式的DCL单例模式。\n\n\nclass Singleton &#123;  /** 这里一定要使用 volatile 关键字来修饰单例实例，以防止指令重排序导致的线程不安全问题 */  public static volatile Singleton singleton;    /** 构造器使用 private 修饰，对外部进行屏蔽 */  private Singleton() &#123;&#125;    /** 对外暴露的唯一公开静态方法，以此提供单例实例。这里使用 volatile+DCL 来保证线程安全 */  public static Singleton getInstance() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n​\t线程安全的单例模式还可以是静态内部类；亦或是直接使用饿汉式，在类加载时就创建，由jvm保证了线程安全性。\n​\t不过就不展开了，毕竟本文的主要内容不是设计模式 :-)\n\n与CAS操作结合，保证线程安全性。\n\n\n\n为什么会发生指令重排序？这是出于性能最大化考虑，CPU常常会对指令进行重排序。当然，前提是不会改变程序的运行结果 🤣 否则编程就成为一个玄学问题了。\n\n\n一些编写多线程的最佳实践\n不要自己手动创建线程对象，而是使用线程池来管理线程对象，达到资源复用的效果。\n给线程命名，并开启打印线程名的功能。这有助于进行调试。\n尽可能最小化临界区的范围，而不是无脑地将整个方法进行同步。这有助于性能提升。\n尽可能使用 volatile 而不是 synchronized\n当需要进行线程间通信时，使用 concurrent 包下的那些同步工具类（如 CountDownLatch, Semaphore），而不是使用 wait() &amp; notify()。\n当需要使用线程安全的容器集合时，使用 concurrent 包下的那些并发容器类，而不是 util 包下的同步容器类。\n\n","tags":["Java","多线程"]},{"title":"「环境搭建」 步骤总结","url":"/2022/05/30/%E3%80%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%8D%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93/","content":"jdk安装阶段官网安装地址：Java Downloads | Oracle\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段\n配置环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 JAVA_HOME 的变量名，其值为 jdk 的安装目录路径。\n这里是一个示例：\n\n在系统变量的 Path 变量中，添加一条记录 %JAVA_HOME%\\bin。\n\n\n\nMac\n\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n在 .bash_profile 文件中进行编辑，配置 jdk 环境变量\nexport JAVA_HOME=your/path/to/jdkexport PATH=$JAVA_HOME/bin:$PATH:.export CLASS_PATH=$JAVA_HOME/lib# 使配置文件立即生效source ~/.bash_profile\n\n\n\n\n检验配置是否成功\n现在，让我们在终端输入 java -version 来测试是否一切都正常。如果能正确显示版本号，那么就配置成功了~ 否则，就需要重新检查 JAVA_HOME 和 Path 中的路径配置是否有问题。\n\n\n\n\n其实还有一个叫做 classpath 的配置项，不过官方表示：jdk1.5以后就不用配置它了。\n\n\nidea安装阶段官网安装地址：IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段总的来说，这篇文章已经很齐全了，标记一下：Idea安装与配置详解\n下面，说几个重点部分。\n\n导入 Settings 配置\nFile -&gt; Manage IDE Settings -&gt; Import Settings\n\n设置 Font 字体\nFont: JetBrains Mono, Size: 20.0, Line height: 1.35, Fallback font: SimHei\n\n导入 Color Scheme 配色方案（现在有了云同步功能，这一步基本上不再需要手动操作了）\n\n\n\n\nMySQL安装阶段官网安装地址：MySQL :: Download MySQL Community Server\n\n\n配置阶段\nWindows: 超级详细的mysql数据库安装指南\nMac: mac下mysql的安装步骤\n\n\n\nRedis安装阶段\nWindows\nRedis官网建议使用Linux进行部署，未提供Windows版本的Redis。\n但微软开发和维护着Windows64版本的Redis，可以在GitHub上进行下载：microsoftarchive&#x2F;redis\n\n下载 .zip 的压缩包文件，并解压至任意目录\n启动服务器程序 redis-server.exe，并保持窗口开启\n启动客户端程序 redis-cli.exe，然后执行 ping 命令。如果显示 PONG，那么说明连接成功。\n\n\nMac\n官网安装地址：Download | Redis\n\n下载压缩包文件，并解压至任意目录\n\n在Redis安装目录下，打开终端，并进行编译测试：\nsudo make test\n\n如果一切顺利，那么可以开始执行Redis的安装：\nsudo make install\n\n如果安装成功，则会有相应提示 :)\n\n\n\n\n\n\n配置阶段\n配置系统环境变量\n\nWindows: Redis下载安装与配置(windows)\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，在系统变量的 Path 变量中，添加一条记录，可以直接输入Redis的安装目录。 \n这里是一个示例：E:\\develop\\Redis-x64-3.2.100\n\n在Redis的安装目录下，打开终端窗口，输入以下命令：\nredis-server.exe --service-install redis.windows.conf --loglevel verbose\n\n提示 “Redis sucessfully installed as a service.” ，则表明Redis服务安装成功！\n如果后续需要卸载Redis服务，那么输入以下命令：\nredis-server --service-uninstall\n\n提示 “Redis service sucessfully uninstalled.” ，则表明Redis服务卸载成功！\n\n\n\nMac: Mac上redis下载安装与配置详细版\n\n打开终端并执行以下命令：\n# 在redis目录下创建 bin、etc、db 这三个目录sudo mkdir /usr/local/redis-6.2.2/binsudo mkdir /usr/local/redis-6.2.2/etcsudo mkdir /usr/local/redis-6.2.2/db\n\n把 /usr/local/redis/src 目录下的 mkreleasehdr.sh, redis-benchmark, redis-check-rdb, redis-cli, redis-server 拷贝到 bin 目录：\ncp /usr/local/redis-6.2.2/src/mkreleasehdr.sh /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-benchmark /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-check-rdb /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-cli /usr/local/redis-6.2.2/bincp /usr/local/redis-6.2.2/src/redis-server /usr/local/redis-6.2.2/bin\n\n拷贝 redis.conf 到 /usr/local/redis/etc 下：\ncp /usr/local/redis-6.2.2/redis.conf /usr/local/redis-6.2.2/etc\n\n编辑 etc 目录下的 redis.conf 配置文件：\nsudo vim /usr/local/redis-6.2.2/etc/redis.conf\n\n并在文件中添加如下代码：\n# 修改为守护模式daemonize yes# 设置进程锁文件pidfile  /Users/xxx/Desktop/Py/redis/redis.pid # 根据自己的路径进行相关配置# 端口port 6379# 客户端超时时间timeout 300# 日志级别loglevel debug# 日志文件位置logfile /Users/xxx/Desktop/Py/redis/log-redis.log # 根据自己的路径进行相关配置# 设置数据库的数量，默认数据库为16，可以使用SELECT 命令在连接上指定数据库iddatabases 16## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合# save# Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000# 指定存储至本地数据库时是否压缩数据，默认为yes# 如果为了节省CPU时间，可以改为no，但会导致数据库文件十分大rdbcompression yes# 指定本地数据库文件名dbfilename dump.rdb# 指定本地数据库路径dir  /Users/xxx/Desktop/Py/redis/db/ # 根据自己的路径进行相关配置# 指定是否在每次更新操作后进行日志记录# Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。appendonly no# 指定更新日志条件，共有3个可选值：# no：表示等操作系统进行数据缓存同步到磁盘（快）# always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）# everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec\n\n启动客户端程序 ./redis-cli，然后执行 ping 命令。如果显示 PONG，那么说明连接成功！\n\n\n\n\n\n\n\n\nMaven安装阶段官网安装地址：Maven – Download Apache Maven\n安装阶段没有太多需要额外说明的。\n\n\n配置阶段maven的使用是在jdk的基础上，因此，请先确保自己电脑已经有了jdk环境。\n\n配置环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 MAVEN_HOME 的变量名，其值为 maven 的安装目录路径。\n这里是一个示例：\n\n在系统变量的 Path 变量中，添加一条记录 %MAVEN_HOME%\\bin。\n\n\n\nMac\n\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n在 .bash_profile 文件中进行编辑，配置 jdk 环境变量\nexport MAVEN_HOME=your/path/to/mavenexport PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH:.# 使配置文件立即生效source ~/.bash_profile\n\n\n\n\n检验配置是否成功\n打开终端，输入命令 mvn -v 如果能正确显示版本号，那么就配置成功了~\n\n配置本地仓库的存储路径\n\n在maven的安装目录下，创建一个文件夹，用于作为仓库。（一般将这个文件夹起名为 repository）\n\n在核心配置文件 conf/settings.xml 中，将本地仓库路径设置为对应路径即可。\n这里是一个示例：&lt;localRepository&gt;E:\\develop\\apache-maven-3.8.3\\repository&lt;/localRepository&gt;\n\n\n\n配置中央仓库地址\n在mirrors节点添加新的mirror子节点，以下内容截取自我自己的配置文件：\n   &lt;mirrors&gt;     &lt;mirror&gt;       &lt;id&gt;central&lt;/id&gt;       &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;       &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;     &lt;!--  阿里仓库  --&gt;     &lt;mirror&gt;       &lt;id&gt;alimaven&lt;/id&gt;       &lt;name&gt;aliyun maven&lt;/name&gt;       &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;repo2&lt;/id&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       &lt;name&gt;Human Readable Name for this Mirror&lt;/name&gt;       &lt;url&gt;https://repo2.maven.org/maven2/&lt;/url&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;jboss-public-repository-group&lt;/id&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       &lt;name&gt;JBoss Public Repository Group&lt;/name&gt;       &lt;url&gt;https://repository.jboss.org/nexus/content/groups/public&lt;/url&gt;     &lt;/mirror&gt;     &lt;mirror&gt;       &lt;id&gt;google-maven-central&lt;/id&gt;       &lt;name&gt;Google Maven Central&lt;/name&gt;       &lt;url&gt;https://maven-central.storage.googleapis.com&lt;/url&gt;       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     &lt;/mirror&gt;   &lt;/mirrors&gt;5. 与 Idea 集成   关闭并重新打开 Idea ，找到 `Preferences -&gt; Build, Execution, Deployment -&gt; Maven`，自定义maven路径和配置文件路径。&lt;br&gt;# Git## 安装阶段官网安装地址：[Git (git-scm.com)](http://book.git-scm.com/)在安装过程中有很多可选项，当然你可以傻瓜式的不断next，但如果想要自定义，可以参考文章：[Git安装包教程（详解Git安装过程）](https://www.cnblogs.com/xueweisuoyong/p/11914045.html)。&lt;br&gt;## 配置阶段1. Git 提供了一个叫做 git config 的命令，专门用来配置或读取相应的工作环境变量。   git config 后面可以跟随一个参数，用于表示该配置变量的生效范围：   - `--system` 对系统上每一个用户及他们的仓库都生效   - `--global` 只针对当前用户的每个仓库生效   - `--local` 只对当前的仓库生效   并且，以上排列是按照优先级进行升序排序的。每一个级别会覆盖上一级别的配置，比如 `--global` 的配置变量会覆盖 `--system` 中的配置变量。2. 安装完 Git 之后，要做的第一件事就是设置你自己的用户名和邮件地址。   这一点很重要，因为每一个 Git 提交记录中都会显示这些信息，用于标识和区分代码的提交者。   由于这些都是与当前用户相关联的，因此将生效范围设置为 `--global` 比较合适：   ```bash   git config --global user.name &quot;你的名字&quot;   git config --global user.email &quot;你的邮箱@xxx.com&quot;\n\n查看配置信息\n如果你想查看之前配置过的东西，可以使用 git config --list 命令来列出所有 Git 可以找到的配置项。\n如果你是有针对性的查找某一项配置，也可以直接使用 git config &lt;key&gt; ，如 git config user.name 。\n\n配置SSH公钥\n\n生成一个密钥对。在用户盘的 .ssh 文件夹中，打开 Git Bash，然后输入：\nssh-keygen\n\n这时，.ssh文件夹中会生成两个密钥文件 id_rsa 和 id_rsa.pub。\n以文本编辑器（如记事本）的方式打开 id_rsa.pub，将文件内容全选并复制到 GitHub 上。\n\n登陆 GitHub，点击右上角头像，选择Settings，选择左侧菜单栏中的 SSH and GPG keys，再点击 New SSH key，将前面复制的内容粘贴在这里。\n\n回到 Git Bash 界面，测试是否配置成功：\nssh -T git@github.com\n\n如果提示 Hi xxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. ，那么就证明成功了。\n\n\n\n配置远程仓库\n如何将本地的代码文件提交至远端服务器？那么就要将你的本地仓库与远程仓库建立一个连接，通过以下命令：\ngit remote add &lt;name&gt; &lt;git_address&gt;\n\n其中，一般都将名字设置为 origin ，这相当于是一种默认规范了，即：\ngit remote add origin username@host:/path/to/repository\n\n然后，就可以向这个远程仓库发送文件啦！这里指定一个master分支：\ngit push -u origin master\n\n\n\n如果想查看已经添加成功的远程仓库，可以使用：\ngit remote\n\n与 Idea 集成\n路径设置：打开 File -&gt; Settings -&gt; Version Control -&gt; Git（不过一般都能被自动识别）\nTerminal设置：打开 File -&gt; Settings -&gt; Tools -&gt; Terminal，将其中的 Shell path 改为 Git Bash 的路径即可。\n\n\n\n\nnode.js安装阶段官网安装地址：下载 | Node.js (nodejs.org)\n安装阶段没有太多需要额外说明的。\n新版的Node.js已经集成了npm，所以就不需要再去特意安装npm了。安装完成后，打开终端窗口，执行以下命令：\n# 查看node版本node -v# 查看npm版本npm -v\n\n如果能正确显示版本号，那么就已经安装成功了！\n\n\n配置阶段\n配置npm在全局模块的安装路径地址和缓存路径地址\n\nWindows\n在nodejs安装目录下，新建两个文件夹，分别用于作为全局模块的安装路径地址和缓存路径地址，并使用命令行修改npm的相关配置。\n以下是一个示例：\n新建文件夹 node_global 和 node_cache，然后打开终端输入以下命令：\nnpm config set prefix &quot;E:\\develop\\node.js\\node_global&quot;npm config set cache &quot;E:\\develop\\node.js\\node_cache&quot;\n\n\n修改系统环境变量\n\nWindows\n\n高级系统设置 -&gt; 环境变量 -&gt; 系统变量，新建一个名为 NODE_PATH 的变量名，其值为 node_modules 文件夹\n这里是一个示例：\n\n高级系统设置 -&gt; 环境变量 -&gt; 用户变量，在 Path 变量中新建一条记录，其值为 node_global 文件夹\n这里是一个示例：\n\n\n\nMac\n在终端窗口中，创建并打开全局环境变量文件\n# 如果是第一次配置环境变量，那么需要先创建 .bash_profile 文件touch ~/.bash_profile# 打开环境变量配置文件open ~/.bash_profile\n\n由于MacOs环境下的nodejs和npm可执行文件都在 &#x2F;usr&#x2F;local&#x2F;bin 目录下，所以加上这样一项就行了：\nexport PATH=/usr/local/bin/\n\n之后，再重新打开终端，并输入 node ，就会进入node环境。按两次 control+c 可退出node环境。\n\n\n\n\n","tags":["环境搭建"]},{"title":"「二分最值」 二分法还能这么用？！","url":"/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/","content":"前言本文的知识是建立于熟悉掌握二分法的思想与模板代码之上的。\n因此，如果存在任何不确定&#x2F;疑问，可以先移步至此 👉 「二分法」二分最硬干货，就在这了！ ，其中给出了实用的二分查找模板代码。\n如果已经温习完毕&#x2F;足够熟悉，那么，接下来就开始了~\n\n\n总体思路最核心的问题是，为什么这类题目可以使用二分法？又没有什么有序数组，也没有什么查找目标，这是干嘛呢？\n原因在于这类最值问题的答案本身具有二段性。\n所谓二段性，翻译成大白话就是：假设我在 h 小时内到达 d 的最小速度是 s ，那么如果我以 s-1 的速度出发，就一定不能在 h 小时内到达 d 。\n而我们使用二分查找，其实就是在查找这个临界最值，即答案。\n\n如果求的是在满足要求下的最小值，那么查询目标就是第一个满足要求的数值；\n如果求的是在满足要求下的最大值，那么查询目标就是最后一个满足要求的数值。\n\n\n\n概括而言，可以将这类问题的解题步骤分为两部分：\n\n确定答案区间。左区间一般取0或1，而右区间取题目规定的最大数据范围。\n根据题目所求，确定二分模板。\n编写检验函数 check()。这也是最困难，最不确定的一部分。每个题目需要具体情况具体分析。\n\n\n\n题单汇总 🏷️显式最值问题简单计算LeetCode.1283 – 使结果不超过阈值的最小除数题面\n给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。\n每个数除以除数后都向上取整，比方说 7&#x2F;3 &#x3D; 3 ，10&#x2F;2 &#x3D; 5 。\n题目保证一定有解。\n\n示例 1：\n\n输入：nums &#x3D; [1,2,5,9], threshold &#x3D; 6输出：5解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n\n\n\n代码class Solution &#123;  public int smallestDivisor(int[] nums, int threshold) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, threshold, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 divisor 作为除数，使得结果不超过 threshold */  private boolean check(int[] nums, int threshold, int divisor) &#123;    int sum = 0;    for (int num : nums) &#123;      sum += num / divisor + (num % divisor == 0 ? 0 : 1);    &#125;    return sum &lt;= threshold;  &#125;&#125;\n\n\n\nLeetCode.1300 – 转变数组后最接近目标值的数组和题面\n给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。\n如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。\n请注意，答案不一定是 arr 中的数字。\n\n示例 1：\n\n输入：arr &#x3D; [4,9,3], target &#x3D; 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n\n\n\n代码class Solution &#123;  public int findBestValue(int[] arr, int target) &#123;    int left = 0, right = 0;    for (int num : arr) &#123;      right = Math.max(right, num);    &#125;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(arr, target, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    int sum1 = getSum(arr, left - 1), sum2 = getSum(arr, left);    return target - sum1 &lt;= sum2 - target ? left - 1 : left;  &#125;    private boolean check(int[] arr, int target, int value) &#123;    return getSum(arr, value) &gt;= target;  &#125;  private int getSum(int[] arr, int value) &#123;    int sum = 0;    for (int num : arr) &#123;      sum += Math.min(num, value);    &#125;    return sum;  &#125;&#125;\n\n\n\nLeetCode.875 – 爱吃香蕉的珂珂题面\n珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。\n珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n\n示例 1：\n\n输入：piles &#x3D; [3,6,7,11], h &#x3D; 8\n输出：4\n\n\n\n代码class Solution &#123;  public int minEatingSpeed(int[] piles, int h) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(piles, h, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 speed 的速度，在 h 小时内吃完所有香蕉 */  private boolean check(int[] piles, int h, int speed) &#123;    int cost = 0;    for (int pile : piles) &#123;      cost += pile / speed + (pile % speed == 0 ? 0 : 1);    &#125;    return cost &lt;= h;  &#125;&#125;\n\n\n\nLeetCode.2064 – 分配给商店的最多商品的最小值题面\n给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。\n你需要将 所有商品 分配到零售商店，并遵守这些规则：\n一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。请你返回最小的可能的 x 。\n\n示例 1：\n\n输入：n &#x3D; 6, quantities &#x3D; [11,6]输出：3解释：一种最优方案为：\n\n11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) &#x3D; 3 。\n\n\n\n\n代码class Solution &#123;  public int minimizedMaximum(int n, int[] quantities) &#123;    // TODO  &#125;&#125;\n\n\n\nLeetCode.1870 – 准时到达的列车最小时速题面\n给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。\n每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。\n例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。\n生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。\n\n示例 1：\n\n输入：dist &#x3D; [1,3,2], hour &#x3D; 6输出：1解释：速度为 1 时：\n\n第 1 趟列车运行需要 1&#x2F;1 &#x3D; 1 小时。\n由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3&#x2F;1 &#x3D; 3 小时。\n由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2&#x2F;1 &#x3D; 2 小时。\n你将会恰好在第 6 小时到达。\n\n\n\n\n代码class Solution &#123;  public int minSpeedOnTime(int[] dist, double hour) &#123;    if (dist.length - 1 &gt; (int) hour || (dist.length - 1 == (int) hour &amp;&amp; hour % (int) hour == 0)) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e7;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(dist, hour, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 speed 的速度，在 hour 小时内到达终点 */  private boolean check(int[] dist, double hour, int speed) &#123;    int cost = 0;    for (int i = 0; i &lt; dist.length - 1; i++) &#123;      cost += dist[i] / speed + (dist[i] % speed == 0 ? 0 : 1);    &#125;    return cost + (double) dist[dist.length - 1] / speed &lt;= hour;  &#125;&#125;\n\n\n\nLeetCode.2187 – 完成旅途的最少时间题面\n给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。\n每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。\n给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3], totalTrips &#x3D; 5输出：3解释：\n\n时刻 t &#x3D; 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。已完成的总旅途数为 1 + 0 + 0 &#x3D; 1 。\n时刻 t &#x3D; 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。已完成的总旅途数为 2 + 1 + 0 &#x3D; 3 。\n时刻 t &#x3D; 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。已完成的总旅途数为 3 + 1 + 1 &#x3D; 5 。所以总共完成至少 5 趟旅途的最少时间为 3 。\n\n\n\n\n代码class Solution &#123;  public long minimumTime(int[] time, int totalTrips) &#123;    long left = 1L, right = (long) 1e14;    while (left &lt; right) &#123;      long middle = left + ((right - left) &gt;&gt; 1);      if (check(time, (long) totalTrips, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 totalTime 的时间内，至少完成 totalTrips 次旅途 */  private boolean check(int[] time, long totalTrips, long totalTime) &#123;    long count = 0;    for (int t : time) &#123;      count += totalTime / t;    &#125;    return count &gt;= totalTrips;  &#125;&#125;\n\n\n\nLeetCode.1760 – 袋子里最少数目的球题面\n给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n\n示例 1：\n\n输入：nums &#x3D; [9], maxOperations &#x3D; 2输出：3解释：\n\n将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。\n将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n\n\n\n\n代码class Solution &#123;  public int minimumSize(int[] nums, int maxOperations) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, maxOperations, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 maxOperations 次操作内实现 cost 的开销 */  private boolean check(int[] nums, int maxOperations, int cost) &#123;    int count = 0;    for (int num : nums) &#123;      // 这里需要注意的细节是：      // 如果正好可以分完，那么共需要 num/cost 个袋子      // 不过算上本来就有的一个袋子，所以还需要 num/cost-1 个袋子      count += num / cost + (num % cost == 0 ? -1 : 0);    &#125;    return count &lt;= maxOperations;  &#125;&#125;\n\n\n\n历史标记LeetCode.1552 – 两球之间的磁力题面\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。\n已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。\n给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。\n\n示例 1：\n\n输入：position &#x3D; [1,2,3,4,7], m &#x3D; 3输出：3解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n\n\n\n代码class Solution &#123;  public int maxDistance(int[] position, int m) &#123;    Arrays.sort(position);    int left = 1, right = position[position.length - 1] - position[0];    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(position, m, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在任意相邻小球的间隔不超过 dist 的情况下，放入 m 个球 */  private boolean check(int[] position, int m, int dist) &#123;    int count = 1, cur = position[0];    for (int p : position) &#123;      if (cur + dist &lt;= p) &#123;        count++;        cur = p;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1482 – 制作 m 束花所需的最少天数题面\n给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n示例 1：\n\n输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1输出：3解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3\n\n\n\n代码class Solution &#123;  public int minDays(int[] bloomDay, int m, int k) &#123;    if (bloomDay.length &lt; m * k) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(bloomDay, m, k, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 waitingDay 天之内，制成 m 束花 */  private boolean check(int[] bloomDay, int m, int k, int waitingDay) &#123;    int combo = 0, count = 0;    for (int day : bloomDay) &#123;      combo = day &lt;= waitingDay ? combo + 1 : 0;      if (combo == k) &#123;        count++;        combo = 0;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1011 – 在 D 天内送达包裹的能力题面\n传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。\n\n示例 1：\n\n输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], days &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n\n\n\n代码class Solution &#123;  public int shipWithinDays(int[] weights, int days) &#123;    int left = 1, right = 500 * 5 * 10000;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(weights, days, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 capacity 的运量，在 days 天内运输完所有包裹 */  private boolean check(int[] weights, int days, int capacity) &#123;    int sum = 0, cost = 0;    for (int w : weights) &#123;      // 单个包裹的重量不能够超过总运量      if (w &gt; capacity) &#123;        return false;      &#125;      sum += w;      if (sum &gt; capacity) &#123;        sum = w;        cost++;      &#125;    &#125;    cost++;    return cost &lt;= days;  &#125;&#125;\n\n\n\nLCP.12 – 小张刷题计划题面\n为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。\n在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。\n我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3,3], m &#x3D; 2\n输出：3\n解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。\n\n\n\n代码class Solution &#123;  public int minTime(int[] time, int m) &#123;    int left = 0, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(time, m, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在一天耗时最多为 maxTime 的情况下，在 m 天内完成所有计划 */  private boolean check(int[] time, int m, int maxTime) &#123;    // maxCost 记录当天花费最久的题目，将它交给场外求助    int costTime = 0, maxCost = 0, costDay = 0;    boolean help = false;    for (int t : time) &#123;      costTime += t;      maxCost = Math.max(maxCost, t);      if (costTime &gt; maxTime) &#123;        if (!help) &#123;          costTime -= maxCost;          help = true;        &#125;        if (costTime &gt; maxTime) &#123;          costTime = maxCost = t;          costDay++;          help = false;        &#125;      &#125;    &#125;    costDay++;    return costDay &lt;= m;  &#125;&#125;\n\n\n\n规律计算LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长题面\n给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。\n\n示例 1：\n\n\n输入：mat &#x3D; [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold &#x3D; 4输出：2解释：总和小于或等于 4 的正方形的最大边长为 2，如上图所示。\n\n\n\n代码class Solution &#123;  private int m, n;  public int maxSideLength(int[][] mat, int threshold) &#123;    m = mat.length;    n = mat[0].length;    // sum[i][j] -&gt; 以 (0,0) 为左上角，(i,j) 为右下角的矩形的元素和    int[][] sum = new int[m + 1][n + 1];    for (int i = 1; i &lt;= m; i++) &#123;      for (int j = 1; j &lt;= n; j++) &#123;        // 根据容斥原理，构造二维前缀和数组        sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + mat[i - 1][j - 1];      &#125;    &#125;    int left = 0, right = Math.min(m, n);    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(sum, threshold, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 是否存在以 side 为边长的正方形，其元素和不超过 threshold */  private boolean check(int[][] sum, int threshold, int side) &#123;    for (int i = side; i &lt;= m; i++) &#123;      for (int j = side; j &lt;= n; j++) &#123;        // 根据容斥原理，得到当前正方形的元素和        int cur = sum[i][j] - sum[i - side][j] - sum[i][j - side] + sum[i - side][j - side];        if (cur &lt;= threshold) &#123;          return true;        &#125;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\nLeetCode.1954 – 收集足够苹果的最小花园周长题面\n给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 abs(i) + abs(j) 个苹果。\n你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。\n给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。\n\n示例 1：\n\n\n输入：neededApples &#x3D; 1输出：8解释：边长长度为 1 的正方形不包含任何苹果。但是边长为 2 的正方形包含 12 个苹果（如上图所示）。周长为 2 * 4 &#x3D; 8 。\n\n\n\n代码class Solution &#123;  public long minimumPerimeter(long neededApples) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(neededApples, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left * 8L;  &#125;  private boolean check(long neededApples, int len) &#123;    return len * (len + 1L) * (len + 1L) * 4L - 2L * len * (len + 1L) &gt;= neededApples;  &#125;&#125;\n\n\n\nLeetCode.1802 – 有界数组中指定下标处的最大值题面\n给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：\n\nnums.length &#x3D;&#x3D; n\nnums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n\nabs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1\nnums 中所有元素之和不超过 maxSum\nnums[index] 的值被 最大化\n\n返回你所构造的数组中的 nums[index] 。\n\n示例 1：\n\n输入：n &#x3D; 4, index &#x3D; 2,  maxSum &#x3D; 6输出：2解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n\n\n\n代码class Solution &#123;  public int maxValue(int n, int index, int maxSum) &#123;    int left = 1, right = maxSum;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(n, index, (long) maxSum, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断该数组总和是否可以不超过 maxSum ，其中下标 index 处的元素值被确定为 x */  private boolean check(int n, int index, long maxSum, int x) &#123;    // 为了尽可能使得数组总和不超过 maxSum ，所以它应该是长这样的：    // [1,1,2,3,...,x-2,x-1,x,x-1,x-2,...,3,2,1,1]    return getSum(x, index + 1) + getSum(x, n - index) - x &lt;= maxSum;  &#125;  private long getSum(int x, int len) &#123;    return x &gt;= len ? (2L * x - len + 1L) * len / 2L : (1L + x) * x / 2L + (len - x);  &#125;&#125;\n\n\n\n线性匹配[LeetCode.1898 – 可移除字符的最大数目](1898. 可移除字符的最大数目 - 力扣（LeetCode）)题面\n给你两个字符串 s 和 p ，其中 p 是 s 的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 removable ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。\n请你找出一个整数 k（0 &lt;&#x3D; k &lt;&#x3D; removable.length），选出 removable 中的 前 k 个下标，然后从 s 中移除这些下标对应的 k 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 0 &lt;&#x3D; i &lt; k ，先标记出位于 s[removable[i]] 的字符，接着移除所有标记过的字符，然后检查 p 是否仍然是 s 的一个子序列。\n返回你可以找出的 最大 k ，满足在移除字符后 p 仍然是 s 的一个子序列。\n字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。\n\n示例 1：\n\n输入：s &#x3D; “abcacb”, p &#x3D; “ab”, removable &#x3D; [3,1,0]输出：2解释：在移除下标 3 和 1 对应的字符后，”abcacb” 变成 “accb” 。“ab” 是 “accb” 的一个子序列。如果移除下标 3、1 和 0 对应的字符后，”abcacb” 变成 “ccb” ，那么 “ab” 就不再是 s 的一个子序列。因此，最大的 k 是 2 。\n\n\n\n代码class Solution &#123;  public int maximumRemovals(String s, String p, int[] removable) &#123;    int left = 0, right = removable.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(new String(s).toCharArray(), p, removable, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在删除 len 个字符后，使得 p 是 s 的一个子序列 */  private boolean check(char[] s, String p, int[] removable, int len) &#123;    for (int i = 0; i &lt; len; i++) &#123;      s[removable[i]] = &#x27;#&#x27;;    &#125;    for (int i = 0, j = 0; i &lt; s.length; i++) &#123;      if (s[i] == p.charAt(j)) &#123;        j++;      &#125;      if (j == p.length()) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\n隐式二分问题LeetCode.287 – 寻找重复数题面\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n\n示例 1：\n\n输入：nums &#x3D; [1,3,4,2,2]\n输出：2\n\n\n\n代码class Solution &#123;  public int findDuplicate(int[] nums) &#123;    // 第一个满足 小于等于 i 的元素个数超过了 i 个，那么 i 就是重复的数字    int left = 1, right = nums.length;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 判断小于等于 guess 的元素个数是否超过了 guess 个 */  private boolean check(int[] nums, int guess) &#123;    int count = 0;    for (int num : nums) &#123;      if (num &lt;= guess) &#123;        count++;      &#125;    &#125;    return count &gt; guess;  &#125;&#125;\n\n\n\nLeetCode.1648 – 销售价值减少的颜色球题面\n你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。\n这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）\n给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。\n请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。\n\n示例 1：\n\n\n输入：inventory &#x3D; [2,5], orders &#x3D; 4输出：14解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。最大总和为 2 + 5 + 4 + 3 &#x3D; 14 。\n\n\n\n代码//todo\n\n\n\nLeetCode.274 – H 指数题面\n给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。\n根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。\n如果 h 有多种可能的值，h 指数 是其中最大的那个。\n\n示例 1：\n\n输入：citations &#x3D; [3,0,6,1,5]输出：3解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n\n\n\n代码class Solution &#123;  public int hIndex(int[] citations) &#123;    int left = 0, right = citations.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(citations, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断是否有至少 h 篇论文被引用了至少 h 次 */  private boolean check(int[] citations, int h) &#123;    int count = 0;    for (int c : citations) &#123;      if (c &gt;= h) &#123;        count++;      &#125;    &#125;    return count &gt;= h;  &#125;&#125;","tags":["算法","二分查找"]}]