[{"title":"「Java基础问」 基础不牢，地动山摇！","url":"/2022/04/18/%E3%80%8CJava%E5%9F%BA%E7%A1%80%E9%97%AE%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%EF%BC%81/","content":"四种访问修饰符的作用范围？\n\n\n修饰符\n当前类\n同包下\n子类\n其他包下\n\n\n\npublic\n✔️\n✔️\n✔️\n✔️\n\n\nprotected\n✔️\n✔️\n✔️\n❌\n\n\ndefault\n✔️\n✔️\n❌\n❌\n\n\nprivate\n✔️\n❌\n❌\n❌\n\n\n\n\n基本类型转换\n向上转型没有任何问题。如 long b = 1;\n向下转向会造成精度损失，因此如果需要，必须显式地进行强制转换。如 float f = (float) 2.3;\n\n打个比喻：小杯的水倒进一个大杯里肯定没问题。但大杯的水倒进小杯就不行了，可能会溢出。\n\n\n常量池Java的基本类型的包装类大部分都实现了常量池技术。\n\n\n\nByte\nShort\nInteger\nLong\nCharacter\nBoolean\n\n\n\n[-128,127]\n[-128,127]\n[-128,127]\n[-128,127]\n[0,127]\nTrue&#x2F;False\n\n\nFloat 和 Double 没有使用常量池技术。\n简单地说，如果使用的对象的字面量的值在常量池的范围之内，那么就不会创建新的包装类型对象，而是直接引用常量池中的对象。\nInteger a = 100, b = 100, c = 1000, d = 1000;System.out.println(a == b);  // trueSystem.out.println(c == d);  // false\n\n\n\n同样地，String 也有对应的常量池，称为字符串常量池。不过这和上面提到的包装类型的常量池有些不同的是，字符串常量池事先不会缓存任何内容，而是在每次创建字符串时进行判断：如果已经在常量池中存在，那么就直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。维护字符串常量池的全局表叫做 StringTable，其实就是一个 HashSet&lt;String&gt;。它在JVM中仅有一份实例，并被所有类共享使用。\n在Java中，有两种创建字符串对象的方式：\n\nString str = &quot;hello&quot;;\n这种方式下，由于是通过字面量直接创建，所以在编译的时候对于JVM而言是可以确定的。如果 “hello” 已存在于常量池中，那么直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。\n\nString str = new String(&quot;hello&quot;);\n这种方式下，是通过构造器创建对象，在运行时在堆中创建的。所以它不仅会在常量池中创建一个 “hello” 实例，还会在堆中创建一个 String 对象。\n\n\n可以认为，后者包含了前者。\n\n\n重载和重写的区别？\n重载 Overload 是发生在同一个类中的：\n同名的方法，但是有着不同的参数列表 (参数类型不同&#x2F;参数个数不同)。\n\n重写 Override 是发生在父类与子类之间的：\n子类对父类中提供的某方法进行逻辑的重新定义。\n规定子类被重写方法和父类被重写方法的返回值必须相同，且不能比父类被重写方法声明更多的异常。\n\n\n\n\n为什么说重写 equals() 就要重写 hashCode() ？这其实是一种规定。\n换句话说，如果我们不遵守这样的规定，那么最直接的影响是使用哈希结构的容器就可能出现重大问题，因为它们的底层依赖的正是对象的 hashCode() 方法，而你却没有重写它。例如，HashSet 本身是具有去重功能的，但是现在就出问题了：逻辑上明明相同的两个对象，理应只会有一个存在于容器中，事实却是它们都会存在。\n\n\n另外提一句：equals() 相等的两个对象，hashCode() 要保证一定相等；但是 hashCode() 相等的两个对象，equals() 并不一定要相等。\n理由也很简单：因为 hashCode() 相等也有可能是哈希冲突导致的，实质上是两个不相干的对象。\n\n\nJVM 加载 class 文件的过程？JVM中的类加载过程，都是由类加载器来实现的。当Java程序需要使用某个类时，JVM需要确保这个类已经被加载进内存中，并被成功初始化。\n\n加载：\n在经过编译后，会生成 .class 的字节码文件。通常是使用字节数组来读入字节码文件，并在内存中产生与之对应的 Class 对象。\n\n检验：\n经过了加载的步骤，其实 Class 对象还是不完整的。还需要进行一些检验操作：\n\n该类是否存在父类？如果存在，那么必须要确保父类也已经初始化完毕。\n该类是否存在初始化语句块？如果存在，那么需要依次执行这些代码。\n\n\n\n总体顺序是这样的：\n\n父类到子类依次执行静态初始代码块\n父类执行非静态初始代码块和构造器方法，然后子类执行非静态初始代码块和构造器方法\n\n\n\nJVM的类加载器包括：\n\nBootstrapClassLoader 根加载器：负责加载JVM的基础核心类库\nExtensionClassLoader 扩展加载器：负责加载JVM的扩展类库\nApplicationClassLoader 应用类加载器：负责加载 classpath 下的类文件，即使用者编写的代码\n\n为了确保同一份字节码文件不会被多个类加载器重复加载，所以 JVM 还推出了一个叫做「双亲委派」的机制：当来了一个需要被加载的字节码文件时，当前类加载器不会直接加载它，而是向上抛给它的父加载器。只有当父加载器无法处理时，才返回由当前类加载器进行处理。这样就保证了一份字节码文件仅会被一个类加载器所处理。\n\n\n创建对象的几种方式？\nnew 创建新对象\n使用反射机制\n使用 clone 机制\n通过反序列化方式\n\n\n\n关键字 final 的作用？final 表示不可变的意思，可用于修饰类、属性和方法。\n\n被 final 修饰的类不可以被继承。\n\n被 final 修饰的方法不可以被重写。\n\n被 final 修饰的属性不可变，并且必须被显式地指定初始值。\n另外，这里的不可变指的是引用不可变，而不是引用指向的内容的不可变。\n例如 final int[] nums = new int[3]; 但是数组内部的元素是可以随意修改的啊。\n\n\n\n\n方法参数传递到底是引用传递还是值传递？值传递。\n如果参数是一个基本类型的数据，那么传递的是数据的字面值本身。\n如果参数是一个引用类型的对象，那么传递的是对象的引用地址值。在被调用的过程中，对象的属性可以被修改，并影响到调用者；对象的引用也可以被修改，但是不会影响到调用者。\n\n\n字符串拼接问题String 作为不可变类，它是只读的，对象的内容是无法被改变的。如果需要修改内容，那么只能再通过创建一个新的字符串对象。如果在修改操作十分频繁的场景下，性能就显得十分低下了。\n因此，JDK5开始，引入了 StringBuilder&#x2F;StringBuffer 类，专门用于字符串拼接、删除、插入等修改操作。两者的区别在于线程安全性，由于后者的所有方法都被 synchronized 修饰，因此是线程安全的，但是效率就不如前者了。\n\n\n在JDK8以前，如果在两个字符串对象之间使用 “+” 进行拼接，会生成中间对象。不过，在Java8开始，JVM在编译期对 “+” 进行了优化，变成了基于 StringBuilder 的 append() 方法。所以，经过编译器的处理，加号拼接的性能和 StringBuilder 是一样的！\n当然，如果是循环里进行拼接操作，那么还是建议用 StringBuilder 来显式地调用，否则每循环一次就会创建一个新的 StringBuilder 对象，这肯定不如把 StringBuilder 显式地放在循环外部来得好。\n\n\n抽象类和接口的区别？\n相同点：\n\n它们天生的作用就是被继承&#x2F;实现。不可以被实例化，即不能通过 new 来创建对象。\n可以使用抽象类&#x2F;接口类的引用。如 UserService service = new UserServiceImpl();\n一个类如果继承&#x2F;实现了抽象类&#x2F;接口，那么它就需要对其中的所有抽象方法进行 @Override 重写实现。\n\n\n不同点：\n抽象类和普通类的区别就在于：它可以声明抽象方法 (注意我这里的用词是可以，不是必须)。换句话说，抽象类不一定都要有抽象方法，但具有抽象方法的都一定是抽象类。\n\n接口比抽象类更加“抽象”：抽象类可以存在非抽象方法，但是接口中的方法都必须是抽象的。\n抽象类作为一种类，可以定义构造器、成员变量，并且可以用 public, protected, default, private 来修饰；接口不能定义构造器，成员变量只能用 public 来修饰 (而且，这种变量实质上都是常量)。\n\n\n\n\n\ntry…catch…finally 坑爹题\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      System.out.print(&quot;3&quot;);    &#125;  &#125;&#125;\n\n答案：31\n在 try 返回前，会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的结果 1。\n\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      return 3;    &#125;  &#125;&#125;\n\n答案：3\n在 try 返回前，会先执行 finally 语句块。然而这里的 finally 却不按套路出牌，直接 return 了。\n\n\n\n\nI&#x2F;O流有哪些？\n按照流向：输入流、输出流\n按照操作单元：字节流、字符流\n\nInputStream&#x2F;Reader：所有输入流的基类。前者是字节输入流，后者是字符输入流。\nOutputStream&#x2F;Writer：所有输出流的基类。前者是字节输出流，后者是字符输出流。\n\n\n序列化什么是序列化&#x2F;反序列化？序列化：把Java对象转为二进制流，以方便在网络中进行传输。\n反序列化：把二进制流恢复为Java对象。\n好比生活中对一些大件物品的运输，在运输时将它拆分再打包，使用时再重新组装。\n\n\n如何实现序列化？需要让该Java对象所属的类实现 Serializable 接口。\nSerializable 接口没有什么具体的作用，它只是一个标识性接口。但是如果不实现这个接口，在一些序列化场景下会出错。\n所以一般建议，创建的JavaBean类都实现 Serializable 接口。\n\n\n可以不参与序列化吗？可以。对于那些不想进行序列化的变量，可以使用关键字 transient 进行修饰。\n\n\n常见的序列化手段？\nJava对象流：一般是对象输出流 ObjectOutputStream 和对象输入流 ObjectInputStream\nJSON：很多第三方JSON技术，如Jackson、FastJson、GSON\nProtoBuff：一种轻便高效的结构化数据存储格式，可以大大减少数据传输大小，提高系统性能。\n\n\n\n泛型泛型擦除是什么？Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。也就是说，在运行的时候是没有泛型的。\n这样做的目的，主要是为了能够使JVM向下兼容，因为在JDK5之前是没有泛型的。\n\n\n反射什么是反射？普通的创建对象，是通过 new 的方式。这种方式相当于在编译时已经确定了类型信息。\n但是如果想在运行时动态地获取类信息，然后再创建对应的类型实例，那么就需要使用反射了。\n\n\n通过反射，可以获取任意一个类的所有属性和方法 (没错，即使 private 也可以获取到)，并调用它们。\n\n\n\n反射的原理是什么？在类加载时期，JVM使用类加载器将字节码文件加载入内存。反射就是在这个期间获取类信息，然后进行各种操作。\n\n\n反射有哪些使用场景？一般而言，我们很少会直接接触并编写反射代码。\n但是，这并不代表反射没有用。相反，正是因为反射，才能这么轻松地使用各种框架。比如Spring框架中，就大量使用了反射机制。\n","tags":["Java","八股文"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己注册组件！","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，实现自动将组件注册入IOC容器（不用再为每个需要注册的类手写 @Component 、 @Service 等注解），只需要关心业务代码本身即可。\n\n@Import@Import 支持三种使用姿势：\n带有 @Configuration 的 JavaConfig 配置类这也是平时使用的最多的方式就是第一种了，例如有一个主配置类 SpringConfiguration ，现在还需要声明并注册一些数据库相关的组件Bean。当然可以继续写在当前主配置类中，但是组件一旦变得多起来，日后查找就相当烦恼了。更清晰的一种编写方式是：将数据库相关的内容拆分出去，例如新建一个类 JdbcConfiguration ，然后主配置类与数据库配置类之间可以通过 @Import 进行引入。\n\n\n实现 ImportSelector 接口，并自定义其中的规则可以通过实现 ImportSelector 接口和 ImportBeanDefinitionRegistrar 接口，并在其中自定义我们自己想要的注册规则，实现自动批量注册组件等操作。\n观察接口的源码，发现有一个名为 selectImports 的方法需要我们去实现。\n\n\n\n实现类代码/** * 自定义 ImportSelector * 实现功能：将组件批量注册入IOC容器 */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并初始化赋值全局变量   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：将类批量注册入IOC容器   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // 存储扫描包的集合    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\n可以看到，我在无参构造函数中，是通过读取配置文件来获取用户指定的扫描包的。\n配置文件# ImportSelector 相关# AspectJ表达式：twq包下的 任意子包的 任意类custom.importSelector.expression=twq..*# 在上述规则成立的前提下，用户可以指定具体的扫描包custom.importSelector.package=twq# ImportBeanDefinitionRegistrar 相关custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\n对应到我的项目的文件夹路径，是这样的：\n\n    \n    \n    红框部分，就是我配置文件中配置的扫描包范围：twq包（包括子包）下的所有类\n\n\n\n\n最后，在主配置类上引入 @Import(CustomImportBeanDefinitionRegistrar.class) 即可。\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\n可以看到，我既没有在配置类上写 @ComponentScan ，也没有在任何业务类上写例如 @Component 、 @Service 等注解。\n\n\n测试结果现在让我们去测试一下，看看是否可以同样达到组件注册的效果。\n\n    \n    \n    可以看到，这些组件都被成功注册，调用方法也正常执行\n\n\n\n    \n    \n    另外，通过输出当前IOC容器组件名可知：自动为它们分配的id是各自的全限定名。\n\n\n\n\n实现 ImportBeanDefinitionRegistrar 接口，并自定义其中的规则我们来看一下 ImportBeanDefinitionRegistrar 接口的实现姿势。其实它与 ImportSelector 的实现思路基本一致。\n实现类代码/** * 自定义 ImportBeanDefinitionRegistrar * 实现功能：将组件批量注册入IOC容器 */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并给一些全局变量赋值   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：通过指定扫描包，自动将组件注册入IOC容器   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // 扫描集合中的这些包    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\n配置类代码@Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\n测试结果\n\n这里要说明一下：虽然在上面的图片中，看到相关注解的属性爆红了：idea表示无法解析这个bean name。这是因为我们根本没有写任何 @Component ，idea 还以为不存在这些组件。但其实我们已经通过 ImportBeanDefinitionRegistrar 接口帮我们进行组件注册了，所以测试结果是没问题的~~ :laughing:\n\n\n总结：\nImportSelector 自动注册时，分配的组件名规则是：各自类的全限定名 。\n\nImportBeanDefinitionRegistrar 自动注册时，分配的组件名规则是：各自类的类短名+首字母小写的注入方式 。\n\n\n","tags":["Java","Spring"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己读取yaml文件！","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，通过实现 PropertySourceFactory 接口，使Spring可以读取 yaml 格式的配置文件。\n\n@PropertySource我们知道，@PropertySource默认支持读取的是 .properties 和 .xml 格式的配置文件。\n不过就目前而言，更受欢迎且主流的配置文件格式是 .yml 。但很遗憾的是，Spring原生并不支持。\n那么，只好自己动手丰衣足食吧~ :thinking:\n所以接下来就自己实现一个可支持 .yml 格式的 @PropertySource ~\n\n\n源码分析首先点进来这个 @PropertySource 分析一番。可以看到这里需要的是一个解析器工厂类，接口为 PropertySourceFactory ，而框架提供的默认实现类是 DefaultPropertySourceFactory 。\n\n\n\n那么我们就照猫画虎，实现一个自己的 `CustomPropertySourceFactory` 。\n\n\n\n实现实现思路就是：将 yaml 文件解析并转为 properties 文件，然后再交由Spring去读取。\n这里我选择导入第三方依赖 snakeyaml ，以帮助我们解析 yaml 文件并转为 properties 文件。\n实现类代码/** * 自定义 PropertySourceFactory * 实现功能：允许读取yml格式的配置文件 */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // 创建一个yaml文件解析工厂    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // 将传入的资源解析为 properties 文件。这样，spring就支持读取了    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\n至此，就可以愉快地将配置文件改为 .yml 格式的啦。但是别忘了将 @PropertySource 的 factory 属性指向自己自定义的工厂解析类哦~\n\n\n配置类代码@Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Java","Spring"]},{"title":"「二分最值」 二分法还能这么用？！","url":"/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/","content":"前言本文的知识是建立于熟悉掌握二分法的思想与模板代码之上的。\n因此，如果存在任何不确定&#x2F;疑问，可以先移步至此 👉 「二分法」二分最硬干货，就在这了！ ，其中给出了实用的二分查找模板代码。\n如果已经温习完毕&#x2F;足够熟悉，那么，接下来就开始了~\n\n\n题单汇总 🏷️显式最值问题简单计算\nLeetCode.1283 – 使结果不超过阈值的最小除数\nLeetCode.1300 – 转变数组后最接近目标值的数组和\nLeetCode.875 – 爱吃香蕉的珂珂\nLeetCode.2064 – 分配给商店的最多商品的最小值\nLeetCode.1870 – 准时到达的列车最小时速\nLeetCode.1760 – 袋子里最少数目的球\n\n历史标记\nLeetCode.1552 – 两球之间的磁力\nLeetCode.1482 – 制作 m 束花所需的最少天数\nLeetCode.1011 – 在 D 天内送达包裹的能力\n\n滑动窗口\nLCP.12 – 小张刷题计划\n\n规律计算\nLeetCode.1954 – 收集足够苹果的最小花园周长\nLeetCode.1802 – 有界数组中指定下标处的最大值\n\n线性匹配\nLeetCode.1898 – 可移除字符的最大数目\n\n\n\n隐式最值问题\nLeetCode.287 – 寻找重复数\nLeetCode.1648 – 销售价值减少的颜色球\nLeetCode.274 – H 指数\nLeetCode.400 – 第 N 位数字\n\n\n\n特殊二分\nLeetCode.2187 – 完成旅途的最少时间\n\n","tags":["算法","二分查找"]},{"title":"「二分法」最硬干货，速进！","url":"/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81/","content":"前言二分法是一个广泛应用于计算机世界的经典算法，相信没有哪个程序员会不知道它。\n二分查找的本质是通过不断的判断，决定区间的取舍，最终夹出所需答案。使用二分法，可以让你在有序数组中，以 O(logn) 的时间复杂度，找到想要的答案。\n但是，网上关于二分的教学满天飞，大致分为 while (left &lt;= right)  和 while (left &lt; right) ，然后更新式又是五花八门：有的是 left = middle + 1 和 right = middle - 1 ，有的是 left = middle + 1 和 right = middle ……\n稍有不慎写错了，二分就进入了死循环 😭 本来是为了加速查找，这下好了，反向加速了属于是。\n\n\n所以，不多逼逼，直接上干货！\n模板代码统一使用 while (left &lt; right) ，并且：\n\n寻找第一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  int middle = left + (right - left) / 2;  if (满足XXX) &#123;    right = middle;  &#125; else &#123;    left = middle + 1;  &#125;&#125;\n寻找最后一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  // +1是为了让相除结果向上取整，这个地方就是两套模板的区别之一  int middle = left + (right - left + 1) / 2;  if (满足XXX) &#123;    left = middle;  &#125; else &#123;    right = middle - 1;  &#125;&#125;\n\n\n\n最终的二分结果，返回 left 或 right 都可，因为退出循环时一定有 left==right 。\n\n你可以把这两种模板都记住，也可以只选择其中一套看着更顺眼的。因为这两种模板之间的结果是可以互相转化的。\n假设你只会用 寻找第一个满足XXX 这个模板，但是遇到的实际需求是 寻找最后一个满足XXX ，那你也完全可以将二分目标动态地修改为： 寻找第一个不满足XXX 的位置（也就是把 if 条件 改成对应相反的，其余都不用动）。可知它的上一个位置就是 最后一个满足XXX 的，即：把得到的二分结果减去1，就是答案了。反之同理，由 最后一个 -&gt; 第一个 是 加1操作。\n\n\n不过，这样得到的结果，很多时候都需要进行 后处理判断 ，否则会带来问题。\n\n如果你是由 一种情况 转化到 另一种情况 的话，可能会带来 索引越界 的问题。这是因为：在结果转化时一定会进行 -1 (或者 +1) 的操作。那么假设本身的二分结果是0，然后再减1，变成-1了。\n所以在最后返回前，必须判断一下这个下标究竟是否合法（如果题目保证一定存在答案，那么大可放心不必进行这些判断）：\n\n\n// 这里用 -1 表示下标非法时的返回结果return left &gt;= 0 &amp;&amp; left &lt; nums.length ? left : -1;\n\n\n另外，如果题目不保证一定存在答案，那么即使没有产生 索引越界 ，也可能得到 错误答案 。\n例如 寻找有序数组中元素值为 target 的元素所在位置，但是并不保证它一定存在 。拿到这题，我便设定二分目标是： 寻找第一个满足 nums[i] &gt;= target 的位置 i ，最终我得到的二分结果是 left (同样也可以是 right ) 。可是我只知道 nums[left] &gt;= target 是没错的，但不代表 nums[left] == target 也一定没错，因为可能 target 压根就不存在于数组中！！\n所以就必须要后处理判断：\n\n\n// 这里用 -1 表示数组中不存在 target 的返回结果return nums[left] == target ? left : -1;\n\n\n\n最后，还是要啰嗦一下：如果题目保证答案是存在的，那么以上这些后处理的判断都是不必的，你得到的结果一定是正确的。当然，你总是进行后判断处理，那也是很严谨的~\n","tags":["算法","二分查找"]},{"title":"「动态规划」股神养成记","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n股票问题系列 是动态规划入门的经典系列了。\n本文将收录 LeetCode 上的所有相关问题，以此总结股票市场的操作经验。\n\n题目1 – LeetCode.121题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例1：\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出。\n\n示例2：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成。\n\n\n\n分析本题的要点：最多允许一次交易（买入+卖出）。而数组本身的长度，满足 prices.length&gt;=1 ，即：你想在哪个点位买入，随意任君挑选~并且，你不用考虑当前交易会对下次交易产生影响（因为只有一次交易，不存在下一次）。\n所以，在这种情况下，可以不考虑dp思想，退化为最naive的贪心策略：选择一个价格差最大的交易即可。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\n\n题目2 – LeetCode.122题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以 尽可能地 完成更多的交易（多次买卖一支股票）。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出）。除了不能同时参与多笔交易，没有任何其他限制条件。\n这种情况下，也完全可以将问题 退化为贪心策略：只要今天价格比昨天高，那么我就认为昨天已买入，然后在今天卖出。\n为什么这个策略是正确的？万一明天更高，但是我今天就卖出了，岂不是卖早了嘛？？\n其实并不会。可以看 示例2 ，你会发现：即使我在1块钱买入、2块钱卖出；然后我可以在2块钱又买入、3块钱再卖出；然后再是3块钱买入、4块钱卖出……总之，我最后依然可以赚取4元的利润，不会少的。嗯，本质是叫我们去做短线高手。懂了，学会这个操作思路，股神就是在下了。实际：死于做t\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\n\n题目3 – LeetCode.309：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n示例1：\n\n输入：prices &#x3D; [1,2,3,0,2]输出：3\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出），但除了不能同时参与多笔交易以外，每两笔交易之间还存在一天的冷冻期。\n这种情况下，贪心策略就不再好使了。因为，你必须考虑到：当前的交易会使得明天无法交易，所以“无脑短线”并不见得一定正确。 从此开始，dp策略正式亮相~\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; 第i天持有股票时，可获得的最大利润    // dp2[i] -&gt; 第i天未持有股票且未处于冷冻期，可获得的最大利润    // dp3[i] -&gt; 第i天未持有股票且处于冷冻期，可获得的最大利润    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\n\n题目4 – LeetCode.123：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：最多允许两次交易（买入+卖出），并且不能同时参与多笔交易。\n这种情况下，贪心策略也不再好使了。原因也很容易理解：一共只有两次交易机会，你必须选择利润最大的两笔，而不是“一高就卖”，随意挥霍机会。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * 在任意一天结束后，会处于以下五种状态中的一种：   * 未进行过任何操作，最大利润永远是0   * 只进行过一次买入操作，最大利润以buy1表示；   * 进行过一次买入、一次卖出操作，最大利润以sell1表示；   * 进行过两次买入、一次卖出操作，最大利润以buy2表示；   * 进行过两次买入、两次卖出操作，最大利润以sell2表示。   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\n\n题目5 – LeetCode.188：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2\n\n示例2：\n\n输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7\n\n\n\n分析本题与之前的不同之处在于：最多允许 两次 交易（买入+卖出），并且不能同时参与多笔交易。\n本题实质上，就是 题目4 – LeetCode.123 的扩展版本：硬编码 2 次机会 --&gt;  任意给定的 k 次机会。\n同样地，这里也理应无法使用贪心策略。\n但事实上，由于 k 的范围是任意的，所以情况也不完全是这样。例如：k=9999999（此处自行脑补一亿个9…），那么我们就可以认为 k 是无限大的，此时交易次数视为：不受限。\n事实上，只要有 k &gt;= prices.length / 2 ，此时就可以 无视次数限制了，因为你一定来不及用完所有的交易机会！如果没有交易次数限制，那么问题又可以退化为“贪心策略”了。 于是问题又变成了 题目2 – LeetCode.122 。\n除此以外，普遍情况下还是需要使用 dp策略 。\n\n\n代码class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // 当可操作次数不少于数组的一半长度时，问题可以退化为“贪心策略”    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; 完成i次买入后，可获得的最大利润    // dp[i][1] -&gt; 完成i次卖出后，可获得的最大利润    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["算法","动态规划"]},{"title":"「树」根据给定的前/中/后序遍历，以恢复二叉树","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"今天来记录两道经典二叉树的问题：\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树\n\n\n\n首先，为了构建出这棵二叉树，我们肯定是自顶向下，从 位于顶端的树根节点 出发，在每个正确的位置构造出正确的节点。在每次处理中，我们只关注如何 构造出当前节点 。\n而这个 节点 ：\n\n对于 先序遍历 ，就是 第一个 元素 preorder[preLeft] ；\n\n对于 后序遍历 ，就是 最后一个 元素 postorder[postRight]\n\n\n现在，这个根节点的 val 属性已经确定了，我们可以构造出当前节点： TreeNode root = new TreeNode(val);\n但是其 left 和 right 属性都是不确定的，它们作为子节点，此时并不存在。需要在之后的处理中将它们构造出来 (也就是递归调用) ： \nroot.left = buildTree();root.right = buildTree();\n\n接下来，我们将开始利用 中序遍历的性质。据前所述，我们可以根据 先序遍历 (or 后序遍历) 得到当前的根节点。那么，它在 中序遍历 中的位置，其实将整棵树分为了两半。\n我们假定 该根节点在中序遍历中的位置 是 rootIdx ，那么我们可知 左子树的节点个数 leftSize = rootIdx - inLeft ，由此可得到左右子树的区间范围：\n\n左子树：\n先序遍历： [preLeft + 1, preLeft + leftSize]\n中序遍历： [inLeft, rootIdx - 1]\n后序遍历： [postLeft, postLeft + leftSize - 1]\n\n\n右子树：\n先序遍历： [preLeft + leftSize + 1, preRight]\n中序遍历： [rootIdx + 1, inRight]\n后序遍历： [postLeft + leftSize, postRight - 1]\n\n\n\n至于如何能快速地根据先序遍历&#x2F;后序遍历的元素定位至它在中序遍历中的位置？\n答案是：在开始时，使用哈希表来预处理存储先&#x2F;后序遍历数组中的每个元素在中序遍历数组中的位置。\n\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["算法","二叉树"]},{"title":"「链表」链表题总结","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"链表的基本套路：链表反转public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // 三指针  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\n找链表的中点public ListNode middleNode(ListNode head) &#123;  // 快慢双指针  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 至此，slow 移动至链表的中点  // 对于长度为奇数的链表，中点只有一个  // 对于长度为偶数的链表，中点有两个。此时 slow 位于第一个中点  return slow;&#125;\n\n\n找链表的倒数第 K 个节点 (使用前后双指针 former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // 让先指针 former 先走 k 步  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\n删除某节点// 找到待删除节点的前驱节点 prevprev.next = prev.next.next\n\n\n\n很多链表的中等题甚至是困难题，其实都是对于上述基本套路的缝合。\n例如，LeetCode.234 – 判断一个链表是否为回文链表 。\n\n很直观的一个做法是：使用 栈 的数据结构，先存储链表的前半部分，然后与后半部分逐个进行比对。但是这么做的话，空间复杂度就是 O(n) 了。\n存在一种空间复杂度 O(1) 的原地解法，即用到我们上面所说的基本套路操作。\n具体做法是：\n\n使用快慢指针，定位至链表的中点\n反转后半部分的链表\n比较前半部分与后半部分的链表是否完全一致public boolean isPalindrome(ListNode head) &#123;  // 定位至链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 反转后半部分的链表  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 比较两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\n常见链表面试题反转链表public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nK个一组翻转链表public ListNode reverseKGroup(ListNode head, int k) &#123;  // 判断剩余节点个数是否够 k 个  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // 翻转接下来的 k 个节点  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 尾部连接  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\n合并两个有序链表public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\n另外，也可以使用迭代法 (类似于归并排序) 。\n判断是否为环形链表public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n延伸问题： 找到环的入口节点\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\n相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // 保证两个链表的剩余长度一致  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\n链表相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // 不足补0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // 存在进位现象  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\n重排链表public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // 找到链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 由此，将整个链表分为两部分。  // 前半部分是 [head,mid] ；后半部分是 [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // 反转后半部分的链表  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 合并两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\n删除链表的重复元素public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // 去重    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\n两两交换链表中的节点public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\n链表排序public ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\n分隔链表public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["算法","链表"]},{"title":"「多线程」 时间管理大师","url":"/2022/05/17/%E3%80%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8D%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%E7%A8%8B%E5%BA%8F%E6%8C%87%E5%8D%97/","content":"线程线程的几种状态？\n新建 New\n就绪 Runnable\n运行 Running\n阻塞 Blocked\nI&#x2F;O ：阻塞态，仅释放CPU资源，但不会释放占有着的锁。如 sleep()\nWaiting ：等待态，会释放CPU资源和占有着的锁。如 wait()\nTimed Waiting ：带有超时的等待态\n\n\n结束 Terminated\n\n\n\n线程和进程的区别是什么？\n首先，可以从宏观的角度看待它们的关系：一个程序至少有一个进程，一个进程至少有一个线程。\n进程是操作系统进行资源分配的最小单元，每个进程都有自己独立的内存空间。进程与进程之间是不共享资源的。如果需要，那么就要使用通信技术（socket、channel）。\n线程是操作系统进行资源调度的最小单元。除了线程自己的函数堆栈等，线程与线程之间是共享资源的（这也是为什么会存在线程安全这一问题）。\n打个比喻：进程是水杯，线程是水杯里的水。人喝的是水而不是水杯，但是如果没有水杯来装水也是不行的。\n\n进程可以看作是重量级的线程。在多任务处理机的环境下，如果直接使用进程作为调度单元，那么在资源切换时的开销是比较大的。为了提高执行效率，所以引入了线程来取代进程的资源调度功能。\n\n\n\n\n上下文切换是什么？因为多线程是共用计算机上的CPU资源的，并且在一般情况下，线程数都是大于CPU核心数的。为了让所有线程都有执行的机会，所以需要进行线程之间的调度切换。这种切换就是上下文切换。在切换前，需要保存CPU的状态；在切换回来后，又需要恢复CPU的状态，使得线程能够正确地从中断处恢复执行。\n在Java中，线程调度采用的是抢占式的方式。一个线程的时间片到后，操作系统会根据线程优先级、线程饥饿情况、CPU空闲率等多方面因素，选出下一个线程，并分配时间片给它。\n可以通过 setPriority() 来设置线程的优先级。不过，你不能指望靠它来保证，因为最终权还是在底层的操作系统。但是，如果不是特别需求，就不要改动线程的优先级，因为这可能会因为设置不当，造成线程饥饿问题（当前线程被一个高优先级的线程吞噬掉了所有的CPU时间）。\n\n\n什么是线程饥饿？线程饥饿指的是：一个线程因为某种原因无法获得所需资源，导致一直无法执行下去。\n\n\n听起来和死锁有点像：死锁是指两个及以上的线程在执行时，因互相需要对方的资源，却又不肯先释放自己持有的资源，导致全都永远等待在原地。\n死锁和饥饿的相同点是：二者都是因为资源的竞争引起的问题。\n死锁和饥饿的不同点是：\n\n在死锁中，资源的占有方和资源的拥有方互相请求对方的资源；在饥饿中，当前线程只是迟迟得不到所需资源，但是并不在乎这个资源是谁给的！\n死锁一定涉及多个线程，而饥饿可能只有一个线程。\n当饥饿发生时，除了饥饿线程得不到执行机会，其他线程都还是正常执行的；当死锁发生时，可能最终会使整个系统都陷入死锁并崩溃。\n\n\n\nCallable 和 Future 的区别？Callable 接口类似于 Runnable (从名字也可以看得出) ，不过 Runnable 不会返回执行结果，也无法抛出返回结果的异常。但是 Callable 就弥补了这一缺陷，可以认为是带有回调功能的 Runnable ：能够返回异步执行的结果，然后由 Future 接收到。\n\n\n线程之间如何进行通信？\n使用 Object 类中提供的 wait() &amp; notify()/notifyAll() 、park() &amp; unpark() 机制\n使用 concurrent 包下的同步工具类，如 CountDownLatch 、CyclicBarrier 。\n\n\n\n为什么要把 wait()、notify() 这种方法定义在 Object 类中？\nJava 中的每个对象都有一个对应的 Monitor 对象。当该对象调用了 wait()、notify() 这些方法时，其实就是在向 Monitor 对象传达信息：等待对象的锁 &#x2F; 通知其他线程对象的 Monitor 是可用的。\n在 Java 的线程中，并没有提供线程同步的方法。为了使得每个类都具有线程间通信的能力，所以给每个类都应该提供一个类似 wait() 、 notify()/notifyAll() 的方法。而 Object 作为所有类的父类，将这样的方法直接放在 Object 中也是十分合适的。\n\n\n\n保证线程安全的方案？\n使用 synchronized 关键字\n\n使用 Lock 接口下的实现类\n\n使用线程的本地局部变量 ThreadLocal\n简单来说就是一种以空间换时间的数据隔离思想：在每个线程中，维护了一个 ThreadLocalMap，用 set() &#x2F; get() 来使用当前线程的数据，最后将这个 Map 挂到当前线程下，所以 Map 就只属于这个线程了。数据不再共享，自然就不存在线程安全的问题了。\n\n将对象设置为不可变的 (即对象一旦被创建，就不能再改变了)\n比如 String、基本类型的包装类，这些都是不可变类 (被 final 修饰) 。\n\n另辟空间，在操作结束后替换引用地址 (如 CopyOnWriteArrayList)\n\n\n\n\n线程池为什么要用线程池？直接 new Thread() 不好吗？\n创建线程对象是一个开销较大的操作，无论是对CPU还是对内存占用。所以，如果一个任务就开辟一个新线程，性价比实在是太低了。\n\n通过 new Thread() 得到的线程是不易管理的（一般被称为野线程），甚至可以无限制的创建！如此一来，如果使用者使用不慎，可能就导致整个操作系统瘫痪了……🙃\n\n通过 new Thread() 得到的线程也不易于扩展。比如，想要定时执行、定期执行的话，都是不容易实现的。\n\n\n\n\n因此，引入了一个名为线程池的思想，完美解决了上述缺点。\n\n复用已创建好的那些线程，从而降低了资源消耗，并且便于管理\n可以很方便地进行功能扩展，达到定时执行等效果\n\n不过，如果阅读过阿里巴巴开发手册就会发现，不建议使用 Executors 来创建线程。主要原因是：用这样的方式来创建线程，使用者对于这个默认线程池的规则是不够了解的，这就有可能导致使用不当。\n所以，一般建议使用 ThreadPoolExecutor 来创建线程池，并由使用者来设置线程池的一些核心参数，保证使用者对于这个自定义线程池的规则是了解的。\n\n\n常用的线程池\nnewCachedThreadPool()：创建一个可缓存线程池，如果线程池的大小超过实际需要，在超时时间后会回收空闲线程。当任务数增加时，又可以动态地添加新线程来处理任务。\nnewFixedThreadPool()：创建一个大小固定的线程池。每次提交一个任务就会创建一个线程，直至到达线程池的最大大小。超出的线程会在阻塞队列中等待。\nnewSingleThreadExecutor()：创建一个单线程化的线程池，使用唯一的工作线程来执行所有任务。可以保证所有任务都是按照顺序来执行的。\nnewScheduledThreadPool()：创建一个大小固定的线程池。支持定时及周期性任务执行。\n\n\n\n解读一下线程池的7大核心参数？\ncorePoolSize : 核心线程数\nmaximumPoolSize : 最大线程数 (核心线程数+救急线程数)\nkeepAliveTime : 空闲的救急线程的最大存活时间\nTimeUnit : keepAliveTime 的时间单位\nworkQueue : 阻塞队列，用于存放那些待执行的任务\nthreadFactory : 创建线程池中的工作线程的线程工厂 (一般都是默认即可)\nrejectedHandler : 拒绝策略。当线程池中的阻塞队列已满，且线程数已达到最大线程数时，执行拒绝策略。\nAbortPolicy : 拒绝新任务并抛出异常\nDiscardPolicy : 拒绝新任务，但不抛出异常\nCallerRunsPolicy : 使用当前调用的线程来执行此任务 (相当于为了让任务不失败，于是让它插队)\nDiscardOldestPolicy : 抛弃阻塞队列头部 (最旧) 的一个任务，并执行当前任务\n\n\n\n\n\n对于阻塞队列的使用，需要进行一点说明：\n\n如果使用的是 LinkedBlockingQueue 等无界队列，那么可以无限地向线程池中添加任务 (因为阻塞队列不会满) 而不会触发拒绝策略。并且，也不会触发救急线程。所以，相当于 maximumPoolSize, keepAliveTime, TimeUnit, rejectedHandler 都是无意义的参数。\n如果使用的是 ArrayBlockingQueue 等有界队列，那么如果阻塞队列已满，就会触发救急线程。如果救急线程也达到了上限，那么再有新任务时就会触发拒绝策略。\n\n\n\n线程池的执行流程？\n当线程数小于 corePoolSize 时，使用核心线程来执行任务\n当线程数大于 corePoolSize 时，将多余的任务放入阻塞队列\n当阻塞队列已满时，启动救急线程来执行\n当阻塞队列已满，且线程数已达到 maximumPoolSize 时，执行拒绝策略\n当阻塞队列不再满时，已创建的那些救急线程就进入空闲状态。如果它们的空闲时间超过 keepAliveTime ，就会回收这些救急线程\n\n\n\nsubmit() 和 execute() 的区别？这两者都是用于向线程池提交任务的。\n区别在于：\n\nexecute() 没有返回值\nsubmit() 返回值是一个 Future 对象，从而可以得到异步执行的结果\n\n\n\nsynchronized 关键字synchronized 修饰在不同的位置，各代表什么？\n如果 synchronized 修饰的是一个实例方法，则上锁的是调用该方法的对象实例\n如果 synchronized 修饰的是一个静态方法，则上锁的是所在类的Class实例\n如果 synchronized 修饰的是一个代码块，则上锁的是传入 synchronized 括号内的对象实例\n\n请知道一条原则：同步块的作用范围越小越好。\n\n\nsynchronized 的底层原理是什么？前置知识点：Mark Word 、Monitor 对象\n无论 synchronized 修饰的是什么，对应的锁都是一个实例对象。\n一个对象，是由三部分组成的：对象头、对象实际内容、对齐填充字段。synchronized 的原理，就在于对象头之中的 Mark Word 部分。这部分就负责记录对象关于锁的信息。\n\n另外，每个对象都会有一个 Monitor 对象，存储着当前持有该 (对象) 锁的线程，并维护一个阻塞等待该 (对象) 锁的等待队列。\n\n\n\n\n锁的优化在JDK1.6之前，锁的操作都是重量级的：monitor对象直接存储持有着锁的线程的id，并设置 Mark Word 中的 monitor对象地址，把其他阻塞等待的线程都加入等待队列中。这个加锁的过程是依赖底层操作系统的 mutex 指令的，存在用户态与内核态之间的切换，所以性能损耗十分严重。\n在JDK1.6之后，引入了偏向锁、轻量级锁的概念，它们是在JVM层面的规定，所以就不依赖于底层操作系统，性能得到大幅提升。\n总体流程是：无锁 &#x3D;&#x3D;&gt;  偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁。并且，锁只有升级，不存在降级。\n从使用层面看，至始至终都是关键字 synchronized，即：这种优化是内部的，对于使用者而言是无感知的。引入了偏向锁和轻量级锁这两个概念，就是为了能够尽可能地提高并发执行时的效率问题。\n\n偏向锁\nJVM认为在同一时间，只会有一个线程来执行同步块中的代码，即：这是一个没有竞争的环境。\n所以直接在 Mark Word 中记录该线程。如果一个线程想要获得锁，就直接比对线程ID与 Mark Word 中存放的是否一致，一致就可以直接获得这个锁；否则，用CAS来尝试修改 Mark Word，将记录改为当前线程ID。\n如果CAS修改成功，那么线程仍旧可以获得这个锁；否则，说明当前环境是存在竞争的，于是升级为轻量级锁。\n\n轻量级锁\n当前线程会在栈帧下创建 Lock Record，把 Mark Word 的信息都拷贝进去。如果一个线程想要获得锁，先用CAS来尝试将 Mark Word 信息修改为该线程的 Lock Record。\n如果CAS修改成功，那么线程就获取到了这个锁 (轻量级) ；否则，进行自旋重试。当自旋一定次数后仍不能获得锁，就升级为重量级锁。\n\n\n总结：\n\n只有一个线程进入临界区：偏向锁\n多个线程交替进入临界区：轻量级锁\n多个线程同时进入临界区：重量级锁\n\n\n\n关于 java.util.concurrent乐观锁和悲观锁是如何理解的？\n乐观锁：非常乐观，认为每次拿到的数据都没有被人修改过，所以不会上锁。\n在进行更新的时候，使用的是CAS算法：先判断当前值是否是预期值，如果是，则可以进行写操作写入新值；否则，被告知这次竞争失败，然后进行再次尝试，直到成功。\n乐观锁的缺点是：\n\nABA 问题\n线程1读取了某变量的值是A 。此时线程2也读取了该变量，并且线程2将它改为了B ，后又改回为A 。\n然后线程1进行CAS操作，发现当前值与预期值一致，均为A ，于是放心地写入了新值。\n以上过程，线程1的CAS操作是成功的，但这是有潜在隐患的。\n从 JDK1.5 开始，提供了一个名为 AtomicStampedReference 的类来解决ABA问题，即增加了一个比对元素：版本号。每次操作后都会更新这个版本号。这样，即使是同一个值，如果版本号不一致，也被认为是CAS失败。\n\n如果资源竞争十分激烈，那么CAS自旋的概率会很高，从而导致大多数时间都是在浪费CPU资源，效率反而不如 synchronized 。\n\n只能保证对于一个变量的原子操作。如果需要保证对于多个变量的原子操作，那么就需要用锁了。\n\n\n\n悲观锁：非常悲观，总是做最坏的打算，认为每次拿到的数据都是被人修改过了的，所以每次在拿到数据时都会上锁，这样其他线程就拿不到了。\nJava 的同步关键字 synchronized 就是悲观锁的。此外，传统的关系型数据库 (例如MySQL) 里面的行锁、表锁、读锁、写锁等，用到的也都是悲观锁的机制。\n悲观锁是足够安全的，但是缺点也很明显：每次操作都要上锁，结束后再释放锁，比较耗时。\n\n\n在大多数情况下 (竞争不是特别激烈) ，乐观锁的性能是好于悲观锁的。\n\n\nLock 接口是什么？对比传统的同步，有什么优势？Lock 接口是同步的扩展，使用起来更加**灵活 **。典型的实现类是 ReentrantLock 。\n\n支持公平&#x2F;非公平的模式选择 (出于性能考虑，一般都是默认非公平模式)\n允许线程在等待锁时被中断\n允许让线程去尝试获得锁，如果无法获得，可以选择立即返回不再等待或是等待一段时间 (带有超时时间)\n配合条件变量 Condition 来使用，达到 wait&#x2F;notify 的效果，并且是支持中断、超时的\n\n不过，需要注意的是：使用 synchronized 无需考虑释放锁的操作，因为这是自动的；而 Lock 就必须要求使用者手动来释放锁资源。因此，最规范的写法就是在 finally 块中进行 unlock() 释放操作。\n\n\n公平锁和非公平锁的区别是什么？简单来说，公平锁模式是讲究先来后到的顺序的；非公平锁模式是谁准备好了就谁来。\n公平锁：在竞争环境下，先到达临界区的线程一定比后到达临界区的线程更早地获得锁。\n非公平锁：在竞争环境下，先到达临界区的线程未必比后到达临界区的线程更早地获得锁。\n所以，决定它们的因素就是：如果一个线程到达了临界区，它是否会直接尝试获得锁 (非公平) ，还是会直接进入等待队列 (公平) 。\n\n\n并发容器类\nCopyOnWriteArrayList (性能较差的同步容器是 Vector)\n主要特点是：读写分离。\n\n实际的写操作发生在复制的数组上，而读操作还是在原始数组中进行，从而实现读写分离，互不影响。\n在写操作时需要加锁，防止并发写入时导致写入数据丢失。\n在写操作结束后，把原始数组的引用指向新的复制数组。\n\n缺点是：\n\n由于每次写操作都会复制出一个新的数组，所以是比较耗费内存的。\n只能保证最终一致性，无法保证实时一致性。\n\n我们可以从中学到的线程安全解决思路是：通过另辟空间，来解决并发问题。\n\nConcurrentHashMap (性能较差的同步容器是 HashTable)\n底层数据结构与普通的 HashMap 一样，同为数组+链表&#x2F;红黑树。\n\n在 put() 写操作时需要加锁，不过使用的是 CAS算法 (在JDK8之前，使用的是分段锁的方式)\n在 get() 读操作时不加锁，value属性通过 volatile 关键字进行修饰，保证了内存可见性，即每次 get() 得到的都是最新值\n\n\n\n\n\n同步工具类\nCountDownLatch\n在创建时传入一个参数 new CountDownLatch(int initial) 作为计数次数。\n其他线程每调用一次 countDown() 方法，计数器减1。\n当计数器被减为0时，主线程从 latch.await() 处重新被唤醒，然后继续执行后续代码。\n\nCyclicBarrier\n和 CountDownLatch 的作用一样，只不过 CountDownLatch 只能使用一次，使用之后就会失效，而 CyclicBarrier 可以反复使用。\n\nSemaphore\n在不超过设定上限的线程数的情况下，允许多个线程并行执行。主要用于限流之类的操作，限制某段代码块的并发数。打个比喻：Semaphore 就好比是一个停车场，允许同时停放多辆车辆，但也总有一个上限。\n如果 Semaphore 的构造函数中传入的参数是 1 ，就相当于一个 synchronized 了。\n\n\n\n\nAQS是什么？全称是 AbstractQueuedSynchronizer 。作为一个抽象类，相当于是很多同步容器的框架模板，其中制定了很多用于保证线程安全的基本规则。\n常用的实现类有 ReentrantLock, Semaphore, FutureTask 等。\n\n\nAQS的原理底层是使用一个双向链表来维护一个FIFO的等待队列，还有一个 state 的状态变量。\n队列中存储的实体是 Node 节点，记录了当前的状态值、同步模式 (独占 &#x2F; 共享) 、前驱节点和后继节点。\n总体流程是：把需要等待的线程以 Node 节点的形式加入到等待队列中，用 state 变量来维护当前锁的状态。\n当调用了 lock() 方法时：\n\n使用CAS来尝试获得锁。如果成功，那么就可以执行同步块中的代码；\n\n否则，调用 acquire() 方法，判断 state 是否为0。如果等于0，说明没有其他线程持有这把锁，那么就再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n\n否则，说明有线程正在持有着这把锁。于是再判断当前线程是否持有着锁，如果是，那么更新 state 的值加1 (这里正是可重入的体现) ，然后就可以执行同步块中的代码；\n\n否则，只能将当前线程加入等待队列中，然后将自己 park() 挂起，等待后续被唤醒后再继续进行CAS尝试……直至成功，然后执行同步块中的代码。\n在加入等待队列的过程中，其实还有一些细节：\n\n节点入队后，会判断前驱节点是否为头节点。如果是头节点，那么就可以再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n否则，会把前驱节点的状态设置为 SIGNAL (-1) ，用以表示后续节点需要被唤醒，而这个任务就交给了前驱节点。\n\n\n\n当调用了 unlock() 方法时，就非常简单了：把 state 置0，然后唤醒等待队列中第一个需要被唤醒的节点 (节点的 state 小于0) ，然后这个节点就会进行CAS尝试来获得锁。\n\n\nAQS的同步方式是什么？AQS支持两种同步方式：独占式和共享式。\n独占式，锁只会被一个线程持有。如 ReentrantLock\n共享式，多个线程可以同时执行。如 Semaphore, CountDownLatch\n\n\nvolatile 关键字volatile 的作用是什么？\nvolatile 可以保证内存可见性。被 volatile 修饰的变量在进行写操作后，其他线程能马上读到最新值。\n\nvolatile 还可以保证不会发生指令重排序的问题。最典型的使用场景就是 懒汉式的DCL单例模式了吧！\n\n\nclass Singleton &#123;  /** 这里一定要使用 volatile 关键字来修饰单例实例，以防止指令重排序导致的线程不安全问题 */  private static volatile Singleton singleton;    /** 构造器使用 private 修饰，对外部进行屏蔽 */  private Singleton() &#123;&#125;    /** 对外暴露的唯一接口。使用DCL机制来保证线程安全 */  public static Singleton getInstance() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n​\t线程安全的单例模式还可以是静态内部类；亦或是直接使用饿汉式，在类加载时就创建，由jvm保证了线程安全性。\n​\t不过就不展开了，毕竟本文的主要内容不是设计模式 :-)\n\n与CAS操作结合，保证线程安全性。\n\n\n\n为什么会发生指令重排序？这是出于性能最大化考虑，CPU常常会对指令进行重排序。当然，前提是不能改变程序的运行结果 🤣 否则岂不是乱了套了，编程成了一个玄学问题了。\n","tags":["Java","多线程"]}]