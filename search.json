[{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己注册组件！","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，实现自动将组件注册入IOC容器（不用再为每个需要注册的类手写 @Component 、 @Service 等注解），只需要关心业务代码本身即可。\n\n@Import@Import 支持三种使用姿势：\n带有 @Configuration 的 JavaConfig 配置类这也是平时使用的最多的方式就是第一种了，例如有一个主配置类 SpringConfiguration ，现在还需要声明并注册一些数据库相关的组件Bean。当然可以继续写在当前主配置类中，但是组件一旦变得多起来，日后查找就相当烦恼了。更清晰的一种编写方式是：将数据库相关的内容拆分出去，例如新建一个类 JdbcConfiguration ，然后主配置类与数据库配置类之间可以通过 @Import 进行引入。\n\n\n实现 ImportSelector 接口，并自定义其中的规则可以通过实现 ImportSelector 接口和 ImportBeanDefinitionRegistrar 接口，并在其中自定义我们自己想要的注册规则，实现自动批量注册组件等操作。\n观察接口的源码，发现有一个名为 selectImports 的方法需要我们去实现。\n\n\n\n实现类代码/** * 自定义 ImportSelector * 实现功能：将组件批量注册入IOC容器 */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并初始化赋值全局变量   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：将类批量注册入IOC容器   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // 存储扫描包的集合    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\n可以看到，我在无参构造函数中，是通过读取配置文件来获取用户指定的扫描包的。\n配置文件# ImportSelector 相关# AspectJ表达式：twq包下的 任意子包的 任意类custom.importSelector.expression=twq..*# 在上述规则成立的前提下，用户可以指定具体的扫描包custom.importSelector.package=twq# ImportBeanDefinitionRegistrar 相关custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\n对应到我的项目的文件夹路径，是这样的：\n\n    \n    \n    红框部分，就是我配置文件中配置的扫描包范围：twq包（包括子包）下的所有类\n\n\n\n\n最后，在主配置类上引入 @Import(CustomImportBeanDefinitionRegistrar.class) 即可。\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\n可以看到，我既没有在配置类上写 @ComponentScan ，也没有在任何业务类上写例如 @Component 、 @Service 等注解。\n\n\n测试结果现在让我们去测试一下，看看是否可以同样达到组件注册的效果。\n\n    \n    \n    可以看到，这些组件都被成功注册，调用方法也正常执行\n\n\n\n    \n    \n    另外，通过输出当前IOC容器组件名可知：自动为它们分配的id是各自的全限定名。\n\n\n\n\n实现 ImportBeanDefinitionRegistrar 接口，并自定义其中的规则我们来看一下 ImportBeanDefinitionRegistrar 接口的实现姿势。其实它与 ImportSelector 的实现思路基本一致。\n实现类代码/** * 自定义 ImportBeanDefinitionRegistrar * 实现功能：将组件批量注册入IOC容器 */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并给一些全局变量赋值   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：通过指定扫描包，自动将组件注册入IOC容器   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // 扫描集合中的这些包    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\n配置类代码@Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\n测试结果\n\n这里要说明一下：虽然在上面的图片中，看到相关注解的属性爆红了：idea表示无法解析这个bean name。这是因为我们根本没有写任何 @Component ，idea 还以为不存在这些组件。但其实我们已经通过 ImportBeanDefinitionRegistrar 接口帮我们进行组件注册了，所以测试结果是没问题的~~ :laughing:\n\n\n总结：\nImportSelector 自动注册时，分配的组件名规则是：各自类的全限定名 。\n\nImportBeanDefinitionRegistrar 自动注册时，分配的组件名规则是：各自类的类短名+首字母小写的注入方式 。\n\n\n","tags":["Java","Spring"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己读取yaml文件！","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，通过实现 PropertySourceFactory 接口，使Spring可以读取 yaml 格式的配置文件。\n\n@PropertySource我们知道，@PropertySource默认支持读取的是 .properties 和 .xml 格式的配置文件。\n不过就目前而言，更受欢迎且主流的配置文件格式是 .yml 。但很遗憾的是，Spring原生并不支持。\n那么，只好自己动手丰衣足食吧~ :thinking:\n所以接下来就自己实现一个可支持 .yml 格式的 @PropertySource ~\n\n\n源码分析首先点进来这个 @PropertySource 分析一番。可以看到这里需要的是一个解析器工厂类，接口为 PropertySourceFactory ，而框架提供的默认实现类是 DefaultPropertySourceFactory 。\n\n\n\n那么我们就照猫画虎，实现一个自己的 `CustomPropertySourceFactory` 。\n\n\n\n实现实现思路就是：将 yaml 文件解析并转为 properties 文件，然后再交由Spring去读取。\n这里我选择导入第三方依赖 snakeyaml ，以帮助我们解析 yaml 文件并转为 properties 文件。\n实现类代码/** * 自定义 PropertySourceFactory * 实现功能：允许读取yml格式的配置文件 */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // 创建一个yaml文件解析工厂    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // 将传入的资源解析为 properties 文件。这样，spring就支持读取了    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\n至此，就可以愉快地将配置文件改为 .yml 格式的啦。但是别忘了将 @PropertySource 的 factory 属性指向自己自定义的工厂解析类哦~\n\n\n配置类代码@Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Java","Spring"]},{"title":"「动态规划」股神养成记","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n股票问题系列 是动态规划入门的经典系列了。\n本文将收录 LeetCode 上的所有相关问题，以此总结股票市场的操作经验。\n\n题目1 – LeetCode.121题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例1：\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出。\n\n示例2：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成。\n\n\n\n分析本题的要点：最多允许一次交易（买入+卖出）。而数组本身的长度，满足 prices.length&gt;=1 ，即：你想在哪个点位买入，随意任君挑选~并且，你不用考虑当前交易会对下次交易产生影响（因为只有一次交易，不存在下一次）。\n所以，在这种情况下，可以不考虑dp思想，退化为最naive的贪心策略：选择一个价格差最大的交易即可。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\n\n题目2 – LeetCode.122题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以 尽可能地 完成更多的交易（多次买卖一支股票）。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出）。除了不能同时参与多笔交易，没有任何其他限制条件。\n这种情况下，也完全可以将问题 退化为贪心策略：只要今天价格比昨天高，那么我就认为昨天已买入，然后在今天卖出。\n为什么这个策略是正确的？万一明天更高，但是我今天就卖出了，岂不是卖早了嘛？？\n其实并不会。可以看 示例2 ，你会发现：即使我在1块钱买入、2块钱卖出；然后我可以在2块钱又买入、3块钱再卖出；然后再是3块钱买入、4块钱卖出……总之，我最后依然可以赚取4元的利润，不会少的。嗯，本质是叫我们去做短线高手。懂了，学会这个操作思路，股神就是在下了。实际：死于做t\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\n\n题目3 – LeetCode.309：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n示例1：\n\n输入：prices &#x3D; [1,2,3,0,2]输出：3\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出），但除了不能同时参与多笔交易以外，每两笔交易之间还存在一天的冷冻期。\n这种情况下，贪心策略就不再好使了。因为，你必须考虑到：当前的交易会使得明天无法交易，所以“无脑短线”并不见得一定正确。 从此开始，dp策略正式亮相~\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; 第i天持有股票时，可获得的最大利润    // dp2[i] -&gt; 第i天未持有股票且未处于冷冻期，可获得的最大利润    // dp3[i] -&gt; 第i天未持有股票且处于冷冻期，可获得的最大利润    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\n\n题目4 – LeetCode.123：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：最多允许两次交易（买入+卖出），并且不能同时参与多笔交易。\n这种情况下，贪心策略也不再好使了。原因也很容易理解：一共只有两次交易机会，你必须选择利润最大的两笔，而不是“一高就卖”，随意挥霍机会。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * 在任意一天结束后，会处于以下五种状态中的一种：   * 未进行过任何操作，最大利润永远是0   * 只进行过一次买入操作，最大利润以buy1表示；   * 进行过一次买入、一次卖出操作，最大利润以sell1表示；   * 进行过两次买入、一次卖出操作，最大利润以buy2表示；   * 进行过两次买入、两次卖出操作，最大利润以sell2表示。   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\n\n题目5 – LeetCode.188：题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2\n\n示例2：\n\n输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7\n\n\n\n分析本题与之前的不同之处在于：最多允许 两次 交易（买入+卖出），并且不能同时参与多笔交易。\n本题实质上，就是 题目4 – LeetCode.123 的扩展版本：硬编码 2 次机会 --&gt;  任意给定的 k 次机会。\n同样地，这里也理应无法使用贪心策略。\n但事实上，由于 k 的范围是任意的，所以情况也不完全是这样。例如：k=9999999（此处自行脑补一亿个9…），那么我们就可以认为 k 是无限大的，此时交易次数视为：不受限。\n事实上，只要有 k &gt;= prices.length / 2 ，此时就可以 无视次数限制了，因为你一定来不及用完所有的交易机会！如果没有交易次数限制，那么问题又可以退化为“贪心策略”了。 于是问题又变成了 题目2 – LeetCode.122 。\n除此以外，普遍情况下还是需要使用 dp策略 。\n\n\n代码class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // 当可操作次数不少于数组的一半长度时，问题可以退化为“贪心策略”    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; 完成i次买入后，可获得的最大利润    // dp[i][1] -&gt; 完成i次卖出后，可获得的最大利润    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["算法","动态规划"]},{"title":"「树」根据给定的前/中/后序遍历，以恢复二叉树","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"今天来记录两道经典二叉树的问题：\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树\n\n\n\n首先，为了构建出这棵二叉树，我们肯定是自顶向下，从 位于顶端的树根节点 出发，在每个正确的位置构造出正确的节点。在每次处理中，我们只关注如何 构造出当前节点 。\n而这个 节点 ：\n\n对于 先序遍历 ，就是 第一个 元素 preorder[preLeft] ；\n\n对于 后序遍历 ，就是 最后一个 元素 postorder[postRight]\n\n\n现在，这个根节点的 val 属性已经确定了，我们可以构造出当前节点： TreeNode root = new TreeNode(val);\n但是其 left 和 right 属性都是不确定的，它们作为子节点，此时并不存在。需要在之后的处理中将它们构造出来 (也就是递归调用) ： \nroot.left = buildTree();root.right = buildTree();\n\n接下来，我们将开始利用 中序遍历的性质。据前所述，我们可以根据 先序遍历 (or 后序遍历) 得到当前的根节点。那么，它在 中序遍历 中的位置，其实将整棵树分为了两半。\n我们假定 该根节点在中序遍历中的位置 是 rootIdx ，那么我们可知 左子树的节点个数 leftSize = rootIdx - inLeft ，由此可得到左右子树的区间范围：\n\n左子树：\n先序遍历： [preLeft + 1, preLeft + leftSize]\n中序遍历： [inLeft, rootIdx - 1]\n后序遍历： [postLeft, postLeft + leftSize - 1]\n\n\n右子树：\n先序遍历： [preLeft + leftSize + 1, preRight]\n中序遍历： [rootIdx + 1, inRight]\n后序遍历： [postLeft + leftSize, postRight - 1]\n\n\n\n至于如何能快速地根据先序遍历&#x2F;后序遍历的元素定位至它在中序遍历中的位置？\n答案是：在开始时，使用哈希表来预处理存储先&#x2F;后序遍历数组中的每个元素在中序遍历数组中的位置。\n\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["算法","二叉树"]},{"title":"「链表」链表题总结","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"链表的基本套路：链表反转public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // 三指针  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\n找链表的中点public ListNode middleNode(ListNode head) &#123;  // 快慢双指针  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 至此，slow 移动至链表的中点  // 对于长度为奇数的链表，中点只有一个  // 对于长度为偶数的链表，中点有两个。此时 slow 位于第一个中点  return slow;&#125;\n\n\n找链表的倒数第 K 个节点 (使用前后双指针 former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // 让先指针 former 先走 k 步  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\n删除某节点// 找到待删除节点的前驱节点 prevprev.next = prev.next.next\n\n\n\n很多链表的中等题甚至是困难题，其实都是对于上述基本套路的缝合。\n例如，LeetCode.234 – 判断一个链表是否为回文链表 。\n\n很直观的一个做法是：使用 栈 的数据结构，先存储链表的前半部分，然后与后半部分逐个进行比对。但是这么做的话，空间复杂度就是 O(n) 了。\n存在一种空间复杂度 O(1) 的原地解法，即用到我们上面所说的基本套路操作。\n具体做法是：\n\n使用快慢指针，定位至链表的中点\n反转后半部分的链表\n比较前半部分与后半部分的链表是否完全一致public boolean isPalindrome(ListNode head) &#123;  // 定位至链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 反转后半部分的链表  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 比较两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\n常见链表面试题反转链表public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nK个一组翻转链表public ListNode reverseKGroup(ListNode head, int k) &#123;  // 判断剩余节点个数是否够 k 个  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // 翻转接下来的 k 个节点  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 尾部连接  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\n合并两个有序链表public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\n另外，也可以使用迭代法 (类似于归并排序) 。\n判断是否为环形链表public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n延伸问题： 找到环的入口节点\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\n相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // 保证两个链表的剩余长度一致  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\n链表相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // 不足补0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // 存在进位现象  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\n重排链表public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // 找到链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 由此，将整个链表分为两部分。  // 前半部分是 [head,mid] ；后半部分是 [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // 反转后半部分的链表  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 合并两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\n删除链表的重复元素public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // 去重    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\n两两交换链表中的节点public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\n链表排序public ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\n分隔链表public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["算法","链表"]}]