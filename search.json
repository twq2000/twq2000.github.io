[{"title":"「Git」 常用指令","url":"/2022/05/18/%E3%80%8CGit%E3%80%8D%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"创建仓库\n从云端下载完整仓库到本地\ngit clone username@host:/path/to/repository\n\n\n\n本地git管理\n查看文件的修改状态\ngit status\n\n将文件从工作区移至暂存区\ngit add 文件名\n\n将文件从从暂存区移至本地仓库\ngit commitgit commit -a # 可以把还没有执行add命令的文件也一起提交，即可以省去 git add 的过程（但是仅对于修改/删除文件有效，新文件还是要先 git add）git commit -m &quot;注释&quot; # 添加提交信息\n\n查看历史commit记录及其commit_id\ngit log\n\n回退至某个commit版本\ngit reset --hard commit_id\n\n将指定文件添加至忽略列表，不参与git的管理\n首先需要在工作目录下创建一个名为 .gitignore 的文件（必须是这个固定名）：\ntouch .gitignore\n\n然后在该文件中，指出需要忽略的文件（支持通配符），如 *.a ，那么所有 a 类型的文件都不再被git管理，自然也就不会提交至远端服务器了。\n\n\n\n\npush&#x2F;pull\n将本地git同步至云端\ngit push\n\n从云端获取内容\ngit pull\n\n其中，git pull &#x3D; git fetch + git merge，即先获取远端的分支更新内容，再与本地分支进行合并。\n\n\n可能会有疑惑：git pull 和 git clone 有什么区别呢，不都是从云端获取内容吗？\ngit clone 是一个从无到有的过程：在本地没有版本库的时候，从云端服务器获取整个版本库下载到本地。因此，它通常是初始时的第一步。\ngit pull 是在本地已有版本库的前提下，从云端服务器获取最新的commit数据（如果有的话），再merge合并至本地。\n\n\n\n\n使用分支\n创建新分支\ngit branch 新分支名称\n\n切换分支\ngit checkout 目标分支名称\n\n合并分支\ngit merge 目标分支名称\n\n删除分支\ngit branch -d 目标分支名称\n\n\n\n一些trick自定义别名配置为那些常用但较长的指令，配置一个简短的别名，方便自己的命令书写！\n\n在用户目录下，创建 .bashrc 文件\ntouch ~/.bashrc\n\n在 .bashrc 文件中以键值对的形式，进行别名配置，如：\nalias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n保存并退出 .bashrc 文件，然后读取该配置文件\nsource ~/.bashrc\n\n不过，需要注意的是，该读取只在当前shell窗口中生效。\n\n\n\n\n查看git版本流水git log --pretty=oneline --abbrev-commit --all --graph## 自定义别名# 用于输出git提交日志alias git-log=&#x27;git log --pretty=oneline --abbrev-commit --all --graph&#x27;\n\n\n\n强制覆盖本地代码git fetch --allgit reset --hard origin/mastergit pull\n\n\n\n","tags":["Git"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己注册组件！","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，实现自动将组件注册入IOC容器（不用再为每个需要注册的类手写 @Component 、 @Service 等注解），只需要关心业务代码本身即可。\n\n@Import@Import 支持三种使用姿势：\n带有 @Configuration 的 JavaConfig 配置类这也是平时使用的最多的方式就是第一种了，例如有一个主配置类 SpringConfiguration ，现在还需要声明并注册一些数据库相关的组件Bean。当然可以继续写在当前主配置类中，但是组件一旦变得多起来，日后查找就相当烦恼了。更清晰的一种编写方式是：将数据库相关的内容拆分出去，例如新建一个类 JdbcConfiguration ，然后主配置类与数据库配置类之间可以通过 @Import 进行引入。\n\n\n实现 ImportSelector 接口，并自定义其中的规则可以通过实现 ImportSelector 接口和 ImportBeanDefinitionRegistrar 接口，并在其中自定义我们自己想要的注册规则，实现自动批量注册组件等操作。\n观察接口的源码，发现有一个名为 selectImports 的方法需要我们去实现。\n\n\n\n实现类代码/** * 自定义 ImportSelector * 实现功能：将组件批量注册入IOC容器 */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并初始化赋值全局变量   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：将类批量注册入IOC容器   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // 存储扫描包的集合    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\n可以看到，我在无参构造函数中，是通过读取配置文件来获取用户指定的扫描包的。\n配置文件# ImportSelector 相关# AspectJ表达式：twq包下的 任意子包的 任意类custom.importSelector.expression=twq..*# 在上述规则成立的前提下，用户可以指定具体的扫描包custom.importSelector.package=twq# ImportBeanDefinitionRegistrar 相关custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\n对应到我的项目的文件夹路径，是这样的：\n\n    \n    \n    红框部分，就是我配置文件中配置的扫描包范围：twq包（包括子包）下的所有类\n\n\n\n\n最后，在主配置类上引入 @Import(CustomImportBeanDefinitionRegistrar.class) 即可。\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\n可以看到，我既没有在配置类上写 @ComponentScan ，也没有在任何业务类上写例如 @Component 、 @Service 等注解。\n\n\n测试结果现在让我们去测试一下，看看是否可以同样达到组件注册的效果。\n\n    \n    \n    可以看到，这些组件都被成功注册，调用方法也正常执行\n\n\n\n    \n    \n    另外，通过输出当前IOC容器组件名可知：自动为它们分配的id是各自的全限定名。\n\n\n\n\n实现 ImportBeanDefinitionRegistrar 接口，并自定义其中的规则我们来看一下 ImportBeanDefinitionRegistrar 接口的实现姿势。其实它与 ImportSelector 的实现思路基本一致。\n实现类代码/** * 自定义 ImportBeanDefinitionRegistrar * 实现功能：将组件批量注册入IOC容器 */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJ表达式 */  private final String expression;  /** 用户指定的扫描包 */  private final String customPackage;  /**   * 默认的无参构造函数   * 用于读取配置文件，并给一些全局变量赋值   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;读取配置文件失败&quot;);    &#125;  &#125;  /**   * 将配置类中的过滤规则设置为FilterType=ASPECTJ，并重写该方法   * 实现功能：通过指定扫描包，自动将组件注册入IOC容器   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // 如果当前类存在@ComponentScan注解，则取出它的basePackages属性值，并以此作为扫描包      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // 如果存在 basePackages 属性，则取出其属性值        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // 如果未指定@ComponentScan注解，或指定了@ComponentScan但是未指定basePackages，那么都需要我们手动设置扫描包      String basePackage;      try &#123;        // 获取当前类所在的包名，以此作为扫描包        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;获取当前类包名失败&quot;);      &#125;      // 将包名加入集合中      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // 至此，basePackages集合中必不为空，且必定存在元素    if (!StringUtils.isEmpty(customPackage)) &#123;      // 如果用户配置了自定义的扫描包，也需要加入集合中      basePackages.add(customPackage);    &#125;    // 创建一个类路径扫描器与AspectJ表达式过滤器，并将它们整合起来    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // 扫描集合中的这些包    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\n配置类代码@Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\n测试结果\n\n这里要说明一下：虽然在上面的图片中，看到相关注解的属性爆红了：idea表示无法解析这个bean name。这是因为我们根本没有写任何 @Component ，idea 还以为不存在这些组件。但其实我们已经通过 ImportBeanDefinitionRegistrar 接口帮我们进行组件注册了，所以测试结果是没问题的~~ :laughing:\n\n\n总结：\nImportSelector 自动注册时，分配的组件名规则是：各自类的全限定名 。\n\nImportBeanDefinitionRegistrar 自动注册时，分配的组件名规则是：各自类的类短名+首字母小写的注入方式 。\n\n\n","tags":["Java","Spring"]},{"title":"「Spring」 框架知识点梳理宝典","url":"/2022/05/23/%E3%80%8CSpring%E3%80%8D%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%E5%AE%9D%E5%85%B8/","content":"为什么要用Spring？\n控制反转\n通过依赖注入的方式，降低组件之间的耦合程度。由IoC容器来负责创建、管理对象的生命周期和配置。\nIoC的注入方式有两种：构造器注入、setter方法注入\n\nAOP技术\nSpring支持面向切面的编程方式，将一些与业务逻辑本身无关，且被多个业务所共用的操作（事务处理、打印日志、权限控制……）抽取出来。\n这样做的好处是可以减少重复代码，并且有利于未来的可拓展性和可维护性。\n它的原理是在编译时&#x2F;运行时，通过动态代理的方式实现程序功能的统一维护的一种技术。例如 AspectJ 就是在编译时进行动态代理的，SpringAOP 是在运行时进行动态代理的。\n\n支持事务管理\nSpring实现事务有两种方式：声明式和编码式。声明式事务又有两种方式：xml配置方式、@Transaction 注解方式。\n\n\n\n\n说说bean的声明周期流程？(todo…)todo…\n\n\nbean的作用域有哪些？\nsingleton：每一个bean只创建一个实例。这是默认的作用域。\n\n单例模式是线程安全的吗？\nSpring对于单例模式的实现，使用的是 volatile+DCL 的懒汉式。这种方式本身是可以保证读操作的线程安全的。\n也就是说：如果每个线程只有读操作而没有写操作，那么其实是可以保证线程安全的；否则，如果有多个线程同时进行写操作，那么就存在线程安全问题了。\n\n\n\nprototype：每次对bean的调用都会生成一个新的实例。\n\nrequest：在一个 http request 中，一个bean对应一个实例。 \n\nsession：在一个 http session 中，一个bean对应一个实例。 \n\nglobal session：在一个全局的 http session 中，一个bean对应一个实例。\n\n\n\n\nAOP的动态代理策略是怎样的？如果目标对象实现了接口，那么会默认采用JDK动态代理（也可以强制指定为CGLib动态代理）；否则，会强制采用CGLib动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n常用注解及其含义\n\n\n注解\n作用\n\n\n\n@Value\n将常量、配置文件中的变量值，注入到一个变量中\n\n\n@RequestMapping\n用于映射web请求，搭配@Controller一起使用\n\n\n@RequestParam\n接收请求路径中的参数，如 &#x2F;user?id&#x3D;123\n\n\n@PathVariable\n接收路径参数，如 &#x2F;user&#x2F;123\n\n\n@RequestBody\n接收json等格式数据，并注入给指定形参对象\n\n\n@ResponseBody\n将返回对象通过转换器转成指定格式，并写入响应消息的body区。一般用于返回json、xml等格式的数据\n\n\n@Qualifier\nby name匹配模式，搭配@Autowired一起使用，从而消除注入歧义\n\n\n@Component\n标注在类上，表示当前类是一个组件，要交由Spring来进行管理\n\n\n@Configuration\n标注当前类是一个Java Config类，Spring可以将它视作定义bean的配置类\n\n\n@Bean\n标注在具有返回值的方法上，将其返回值对象作为一个bean注册入IoC容器中\n\n\n\n\nSpringBoot是什么？它基于Spring框架，可以帮助使用者快速构建一个准生产级别的项目。\n\n由于Spring框架中需要进行大量的配置，且很多都是固定重复的，因此，SpringBoot预先对这些部分已经做好了习惯性的配置，使用者可以不用或者只需进行很少的手动配置。\n引入了 SpringBoot Starters 来解决依赖之间可能因版本冲突导致的问题。\n\n\n\n@SpringBootApplication 注解@SpringBootApplication 包含了：\n\n@ComponentScan\n\n@SpringBootConfiguration（本身就是一种 @Configuration）\n\n@EnableAutoConfiguration\n其中，最关键的是 @Import(EnableAutoConfigurationImportSelector.class)。借助它，SpringBoot可以将所有符合要求的 JavaConfig 配置类都加载到IoC容器中。\n\n\n\n\nSpringBoot加载配置文件的优先级顺序？由高到低：\n\nfile: .&#x2F;config&#x2F;application.properties\nfile: .&#x2F;application.properties\nclasspath: resource&#x2F;config&#x2F;application.properties\nclasspath: resource&#x2F;application.properties\n\n其中，file 代表项目文件的主目录；classpath 代表项目的类路径。\n","tags":["Spring","八股文"]},{"title":"「Spring」 你已经是一个成熟的框架了，应该学会自己读取yaml文件！","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n本文内容：\n根据对于 Spring 的源码学习，对其进行改造，通过实现 PropertySourceFactory 接口，使Spring可以读取 yaml 格式的配置文件。\n\n@PropertySource我们知道，@PropertySource默认支持读取的是 .properties 和 .xml 格式的配置文件。\n不过就目前而言，更受欢迎且主流的配置文件格式是 .yml 。但很遗憾的是，Spring原生并不支持。\n那么，只好自己动手丰衣足食吧~ :thinking:\n所以接下来就自己实现一个可支持 .yml 格式的 @PropertySource ~\n\n\n源码分析首先点进来这个 @PropertySource 分析一番。可以看到这里需要的是一个解析器工厂类，接口为 PropertySourceFactory ，而框架提供的默认实现类是 DefaultPropertySourceFactory 。\n\n\n\n那么我们就照猫画虎，实现一个自己的 `CustomPropertySourceFactory` 。\n\n\n\n实现实现思路就是：将 yaml 文件解析并转为 properties 文件，然后再交由Spring去读取。\n这里我选择导入第三方依赖 snakeyaml ，以帮助我们解析 yaml 文件并转为 properties 文件。\n实现类代码/** * 自定义 PropertySourceFactory * 实现功能：允许读取yml格式的配置文件 */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // 创建一个yaml文件解析工厂    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // 将传入的资源解析为 properties 文件。这样，spring就支持读取了    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\n至此，就可以愉快地将配置文件改为 .yml 格式的啦。但是别忘了将 @PropertySource 的 factory 属性指向自己自定义的工厂解析类哦~\n\n\n配置类代码@Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Java","Spring"]},{"title":"「macOS」 🍎懵逼指南","url":"/2022/05/28/%E3%80%8CmacOS%E3%80%8DmacOS%E4%B8%8A%E6%89%8B%E5%88%9D%E8%AE%BE%E7%BD%AE/","content":"自定义设置总体而言，几乎所有的自定义设置，都在「偏好设置」中。如果是系统级别的，就是「系统偏好设置」；如果是应用级别的，就是各应用中的「偏好设置」。\n\n\n系统偏好设置通用\n显示滚动条 —— 始终\n在滚动条中点按 —— 跳到点按的位置\n最近使用的项目 —— 关闭文稿时要求保存更改、退出App时关闭窗口\n\n\n\n程序坞\n打开文稿时首选标签页 —— 仅在全屏幕视图下\n连按窗口标题栏以 —— 缩放\n将窗口最小化为应用程序图标 —— 关闭\n弹跳打开应用程序 —— 打开\n为打开的应用程序显示指示灯 —— 打开\n在程序坞中显示最近使用的应用程序 —— 打开\n\n\n\n语言与地区 &amp; 日期与时间\n每周的第一天 —— 星期一\n时间格式 —— 24小时\n时钟 —— 使用24小时格式时钟\n\n\n\n用户与群组登录选项：\n\n自动登录 —— 关闭\n显示“睡眠”、“重新启动”和“关机”按钮 —— 打开\n将快速用户切换菜单显示为 —— 全名\n\n\n\n安全性与隐私\n允许从以下位置下载的App —— 任何来源\nsudo spctl --master-disable\n\n文件保险箱 —— 停用\n\n\n\n\n显示器\n排列 —— 主屏是上方有「白条」标识的\n\n\n\n节能\n此时间段后关闭显示器 —— 30分钟\n如果可能，使硬盘进入睡眠 —— 关闭\n使用电池电源时使显示屏略暗一些 —— 打开\n在菜单栏中显示电池状态 —— 打开\n当显示器关闭时，防止电脑自动进入睡眠 —— 打开\n\nApp推荐：Better Menubar\n\n\n访达高级：\n\n显示所有文件扩展名 —— 打开\n更改扩展名之前显示警告 —— 打开\n从iCloud云盘中移除前显示警告 —— 打开\n清倒废纸篓之前显示警告 —— 打开\n将以下位置的文件夹保持在顶部 —— 按名称排列时的窗口中\n执行搜索时 —— 搜索此Mac\n\n\n\n显示文件路径打开终端，输入以下命令：\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n这样就可以在Finder顶部看见完整地址了。复制路径使用 Option+Command+C\n右键地址栏区域，还可以直接访问路径中的任意一层。\n\n\n卸载方式\n应用程序自带的卸载程序\n使用第三方卸载工具（如 AppDelete），然后将需要卸载的应用图标拖入\n直接移除至废纸篓（可能会残留日志、用户数据缓存等文件）\n\n\n\n常用命令行查找目标文件的路径\n根据文件名查找路径\nmdfind -name &#x27;hello.txt&#x27;\n\n根据文件内容查找路径\nmdfind &#x27;hello world!&#x27;\n\n\n\n新建文本文件touch hello.txt\n\n\n\n推荐App工具列单 🏷️\nBetterAndBetter\n截图工具 iShot\n解压缩工具 Bandizip&#x2F;MyZip&#x2F;FastZip\n磁盘清理工具 CleanMyMac\n\n\n\n附图：Mac快捷键\n","tags":["环境搭建"]},{"title":"「二分法」最硬干货，速进！","url":"/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81/","content":"前言二分法是一个广泛应用于计算机世界的经典算法，相信没有哪个程序员会不知道它。\n二分查找的本质是通过不断的判断，决定区间的取舍，最终夹出所需答案。使用二分法，可以让你在有序数组中，以 O(logn) 的时间复杂度，找到想要的答案。\n但是，网上关于二分的教学满天飞，大致分为 while (left &lt;= right)  和 while (left &lt; right) ，然后更新式又是五花八门：有的是 left = middle + 1 和 right = middle - 1 ，有的是 left = middle + 1 和 right = middle ……\n稍有不慎写错了，二分就进入了死循环 😭 本来是为了加速查找，这下好了，反向加速了属于是。\n\n\n所以，不多逼逼，直接上干货！\n模板代码统一使用 while (left &lt; right) ，并且：\n\n寻找第一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  int middle = left + (right - left) / 2;  if (满足XXX) &#123;    right = middle;  &#125; else &#123;    left = middle + 1;  &#125;&#125;\n寻找最后一个满足XXX的位置：int left = 0, right = nums.length - 1;while (left &lt; right) &#123;  // +1是为了让相除结果向上取整，这个地方就是两套模板的区别之一  int middle = left + (right - left + 1) / 2;  if (满足XXX) &#123;    left = middle;  &#125; else &#123;    right = middle - 1;  &#125;&#125;\n\n\n\n最终的二分结果，返回 left 或 right 都可，因为退出循环时一定有 left==right 。\n\n你可以把这两种模板都记住，也可以只选择其中一套看着更顺眼的。因为这两种模板之间的结果是可以互相转化的。\n假设你只会用 寻找第一个满足XXX 这个模板，但是遇到的实际需求是 寻找最后一个满足XXX ，那你也完全可以将二分目标动态地修改为： 寻找第一个不满足XXX 的位置（也就是把 if 条件 改成对应相反的，其余都不用动）。可知它的上一个位置就是 最后一个满足XXX 的，即：把得到的二分结果减去1，就是答案了。反之同理，由 最后一个 -&gt; 第一个 是 加1操作。\n\n\n不过，这样得到的结果，很多时候都需要进行 后处理判断 ，否则会带来问题。\n\n如果你是由 一种情况 转化到 另一种情况 的话，可能会带来 索引越界 的问题。这是因为：在结果转化时一定会进行 -1 (或者 +1) 的操作。那么假设本身的二分结果是0，然后再减1，变成-1了。\n所以在最后返回前，必须判断一下这个下标究竟是否合法（如果题目保证一定存在答案，那么大可放心不必进行这些判断）：\n\n\n// 这里用 -1 表示下标非法时的返回结果return left &gt;= 0 &amp;&amp; left &lt; nums.length ? left : -1;\n\n\n另外，如果题目不保证一定存在答案，那么即使没有产生 索引越界 ，也可能得到 错误答案 。\n例如 寻找有序数组中元素值为 target 的元素所在位置，但是并不保证它一定存在 。拿到这题，我便设定二分目标是： 寻找第一个满足 nums[i] &gt;= target 的位置 i ，最终我得到的二分结果是 left (同样也可以是 right ) 。可是我只知道 nums[left] &gt;= target 是没错的，但不代表 nums[left] == target 也一定没错，因为可能 target 压根就不存在于数组中！！\n所以就必须要后处理判断：\n\n\n// 这里用 -1 表示数组中不存在 target 的返回结果return nums[left] == target ? left : -1;\n\n\n\n最后，还是要啰嗦一下：如果题目保证答案是存在的，那么以上这些后处理的判断都是不必的，你得到的结果一定是正确的。当然，你总是进行后判断处理，那也是很严谨的~\n","tags":["算法","二分查找"]},{"title":"「动态规划」 股神养成记","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"原文链接🔗：微信公众号 BugNotFoundException\n\n\n前言股票问题系列 是动态规划入门的经典系列了。\n本文将收录 LeetCode 上的所有相关问题，以此总结股票市场的操作经验。\n\n\n题单汇总 🏷️LeetCode.121题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例1：\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出。\n\n示例2：\n\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成。\n\n\n\n分析本题的要点：最多允许一次交易（买入+卖出）。而数组本身的长度，满足 prices.length&gt;=1 ，即：你想在哪个点位买入，随意任君挑选~并且，你不用考虑当前交易会对下次交易产生影响（因为只有一次交易，不存在下一次）。\n所以，在这种情况下，可以不考虑dp思想，退化为最naive的贪心策略：选择一个价格差最大的交易即可。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.122题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以 尽可能地 完成更多的交易（多次买卖一支股票）。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出）。除了不能同时参与多笔交易，没有任何其他限制条件。\n这种情况下，也完全可以将问题 退化为贪心策略：只要今天价格比昨天高，那么我就认为昨天已买入，然后在今天卖出。\n为什么这个策略是正确的？万一明天更高，但是我今天就卖出了，岂不是卖早了嘛？？\n其实并不会。可以看 示例2 ，你会发现：即使我在1块钱买入、2块钱卖出；然后我可以在2块钱又买入、3块钱再卖出；然后再是3块钱买入、4块钱卖出……总之，我最后依然可以赚取4元的利润，不会少的。嗯，本质是叫我们去做短线高手。懂了，学会这个操作思路，股神就是在下了。实际：死于做t\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\nLeetCode.309题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n示例1：\n\n输入：prices &#x3D; [1,2,3,0,2]输出：3\n\n\n\n分析本题的要点：允许任意多次交易（买入+卖出），但除了不能同时参与多笔交易以外，每两笔交易之间还存在一天的冷冻期。\n这种情况下，贪心策略就不再好使了。因为，你必须考虑到：当前的交易会使得明天无法交易，所以“无脑短线”并不见得一定正确。 从此开始，dp策略正式亮相~\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; 第i天持有股票时，可获得的最大利润    // dp2[i] -&gt; 第i天未持有股票且未处于冷冻期，可获得的最大利润    // dp3[i] -&gt; 第i天未持有股票且处于冷冻期，可获得的最大利润    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\nLeetCode.123题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：prices &#x3D; [3,3,5,0,0,3,1,4]输出：6\n\n示例2：\n\n输入：prices &#x3D; [1,2,3,4,5]输出：4\n\n\n\n分析本题的要点：最多允许两次交易（买入+卖出），并且不能同时参与多笔交易。\n这种情况下，贪心策略也不再好使了。原因也很容易理解：一共只有两次交易机会，你必须选择利润最大的两笔，而不是“一高就卖”，随意挥霍机会。\n\n\n代码class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * 在任意一天结束后，会处于以下五种状态中的一种：   * 未进行过任何操作，最大利润永远是0   * 只进行过一次买入操作，最大利润以buy1表示；   * 进行过一次买入、一次卖出操作，最大利润以sell1表示；   * 进行过两次买入、一次卖出操作，最大利润以buy2表示；   * 进行过两次买入、两次卖出操作，最大利润以sell2表示。   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\nLeetCode.188题面\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例1：\n\n输入：k &#x3D; 2, prices &#x3D; [2,4,1]输出：2\n\n示例2：\n\n输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]输出：7\n\n\n\n分析本题与之前的不同之处在于：最多允许 两次 交易（买入+卖出），并且不能同时参与多笔交易。\n本题实质上，就是 题目4 – LeetCode.123 的扩展版本：硬编码 2 次机会 --&gt;  任意给定的 k 次机会。\n同样地，这里也理应无法使用贪心策略。\n但事实上，由于 k 的范围是任意的，所以情况也不完全是这样。例如：k=9999999（此处自行脑补一亿个9…），那么我们就可以认为 k 是无限大的，此时交易次数视为：不受限。\n事实上，只要有 k &gt;= prices.length / 2 ，此时就可以 无视次数限制了，因为你一定来不及用完所有的交易机会！如果没有交易次数限制，那么问题又可以退化为“贪心策略”了。 于是问题又变成了 题目2 – LeetCode.122 。\n除此以外，普遍情况下还是需要使用 dp策略 。\n\n\n代码class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // 当可操作次数不少于数组的一半长度时，问题可以退化为“贪心策略”    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; 完成i次买入后，可获得的最大利润    // dp[i][1] -&gt; 完成i次卖出后，可获得的最大利润    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["算法","动态规划"]},{"title":"「树」根据给定的前/中/后序遍历，以恢复二叉树","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"今天来记录两道经典二叉树的问题：\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树\n\n\n\n首先，为了构建出这棵二叉树，我们肯定是自顶向下，从 位于顶端的树根节点 出发，在每个正确的位置构造出正确的节点。在每次处理中，我们只关注如何 构造出当前节点 。\n而这个 节点 ：\n\n对于 先序遍历 ，就是 第一个 元素 preorder[preLeft] ；\n\n对于 后序遍历 ，就是 最后一个 元素 postorder[postRight]\n\n\n现在，这个根节点的 val 属性已经确定了，我们可以构造出当前节点： TreeNode root = new TreeNode(val);\n但是其 left 和 right 属性都是不确定的，它们作为子节点，此时并不存在。需要在之后的处理中将它们构造出来 (也就是递归调用) ： \nroot.left = buildTree();root.right = buildTree();\n\n接下来，我们将开始利用 中序遍历的性质。据前所述，我们可以根据 先序遍历 (or 后序遍历) 得到当前的根节点。那么，它在 中序遍历 中的位置，其实将整棵树分为了两半。\n我们假定 该根节点在中序遍历中的位置 是 rootIdx ，那么我们可知 左子树的节点个数 leftSize = rootIdx - inLeft ，由此可得到左右子树的区间范围：\n\n左子树：\n先序遍历： [preLeft + 1, preLeft + leftSize]\n中序遍历： [inLeft, rootIdx - 1]\n后序遍历： [postLeft, postLeft + leftSize - 1]\n\n\n右子树：\n先序遍历： [preLeft + leftSize + 1, preRight]\n中序遍历： [rootIdx + 1, inRight]\n后序遍历： [postLeft + leftSize, postRight - 1]\n\n\n\n至于如何能快速地根据先序遍历&#x2F;后序遍历的元素定位至它在中序遍历中的位置？\n答案是：在开始时，使用哈希表来预处理存储先&#x2F;后序遍历数组中的每个元素在中序遍历数组中的位置。\n\n\nLeetCode.105 – 从前序与中序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 – 从中序与后序遍历序列构造二叉树代码class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["算法","二叉树"]},{"title":"「正则表达式」 语法与使用","url":"/2022/05/27/%E3%80%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%8D%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"前言正则表达式，又称规则表达式。其英语为 Regular Expression，在代码中常简写为 regex 。它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，从而实现一种过滤的逻辑效果。\n正则表达式是一种文本模式，描述了在搜索文本时要匹配的字符串的“样子”，因此通常被用来检索、替换那些符合该模式规则的文本，或者是检验一个文本是否符合该模式规则。\n\n\n基本语法\n\n\n表达式\n匹配内容\n\n\n\n[…]\n匹配封闭字符集中的任一字符\n\n\n[\\^…]\n不匹配封闭字符集中的任一字符\n\n\n.\n代表任意字符\n\n\n\\.\n代表文字句号 ‘.’\n\n\n\\d\n匹配一个数字\n\n\n\\d+\n匹配一个整数（+表示一个或多个）\n\n\n\\d?\n匹配一个可能存在的数字（?表示零个或一个）\n\n\n\\d*\n匹配一个可能存在的整数（*表示零个或多个）\n\n\n\\d{m}\n匹配m个数字\n\n\n\\d{m,n}\n匹配m~n个数字\n\n\n\\w\n匹配一个字母字符\n\n\n其中,+,*,&#123;m&#125;,&#123;m,n&#125; 这些都是数量表达式，可以跟在 [...],\\w 等任意字符表达式的后面，两者结合成为更加详细的字符串匹配表达式。\n\n\n不过，需要注意的是：在Java中使用这些正则表达式的语法时，对于任何特殊字符（如\\ 和 .）都需要两级转义，变成 \\\\ 和 \\. 。这是因为正则表达式本身也是一种字符串，也会被javac编译。因此想要得到预期的效果，就必须转义。\n\n\n例题应用LeetCode.65 – 有效数字题面\n有效数字（按顺序）可以分成以下几个部分：\n\n一个 小数 或者 整数\n（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数\n\n小数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n下述格式之一：\n至少一位数字，后面跟着一个点 ‘.’\n至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字\n一个点 ‘.’ ，后面跟着至少一位数字\n\n\n\n整数（按顺序）可以分成以下几个部分：\n\n（可选）一个符号字符（’+’ 或 ‘-‘）\n至少一位数字\n\n给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。\n\n示例：\n\n部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]\n部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final Pattern PATTERN = Pattern.compile(&quot;[+-]?((\\\\d+)|(\\\\d+\\\\.\\\\d*)|(\\\\d*\\\\.\\\\d+))([eE][+-]?\\\\d+)?&quot;);  public boolean isNumber(String s) &#123;    return PATTERN.matcher(s).matches();  &#125;&#125;\n\n\n\nLeetCode.468 – 验证IP地址题面\n给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。\n有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 &lt;&#x3D; xi &lt;&#x3D; 255 且 xi 不能包含 前导零。\n一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:\n\n1 &lt;&#x3D; xi.length &lt;&#x3D; 4\nxi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )\n在 xi 中允许前导零。\n\n\n示例：\n\n有效的IPv4地址: “192.168.1.1”, “192.168.1.0”\n无效的IPv4地址: “192.168.01.1”, “192.168.1.00”, “&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#64;&#49;&#46;&#x31;”\n有效的IPv6地址: “2001:0db8:85a3:0000:0000:8a2e:0370:7334”, “2001:db8:85a3:0:0:8A2E:0370:7334”\n无效的IPv6地址: “2001:0db8:85a3::8A2E:037j:7334”, “02001:0db8:85a3:0000:0000:8a2e:0370:7334”\n\n\n\n代码import java.util.regex.*;class Solution &#123;  private static final String IP4_REGEX = &quot;((\\\\d)|([1-9]\\\\d)|(1\\\\d\\\\d)|(2[0-4]\\\\d)|(25[0-5]))&quot;;  private static final String IP6_REGEX = &quot;([\\\\d|[a-f]|[A-F]]&#123;1,4&#125;)&quot;;  private static final Pattern IPV4_PATTERN = Pattern.compile(IP4_REGEX + &quot;(\\\\.&quot; + IP4_REGEX + &quot;)&#123;3&#125;&quot;);  private static final Pattern IPV6_PATTERN = Pattern.compile(IP6_REGEX + &quot;(:&quot; + IP6_REGEX + &quot;)&#123;7&#125;&quot;);  public String validIPAddress(String queryIP) &#123;    if (IPV4_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv4&quot;;    &#125;    if (IPV6_PATTERN.matcher(queryIP).matches()) &#123;      return &quot;IPv6&quot;;    &#125;    return &quot;Neither&quot;;  &#125;&#125;\n\n","tags":["字符串","正则表达式"]},{"title":"「链表」链表题总结","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"链表的基本套路：链表反转public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // 三指针  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\n找链表的中点public ListNode middleNode(ListNode head) &#123;  // 快慢双指针  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 至此，slow 移动至链表的中点  // 对于长度为奇数的链表，中点只有一个  // 对于长度为偶数的链表，中点有两个。此时 slow 位于第一个中点  return slow;&#125;\n\n\n找链表的倒数第 K 个节点 (使用前后双指针 former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // 让先指针 former 先走 k 步  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\n删除某节点// 找到待删除节点的前驱节点 prevprev.next = prev.next.next\n\n\n\n很多链表的中等题甚至是困难题，其实都是对于上述基本套路的缝合。\n例如，LeetCode.234 – 判断一个链表是否为回文链表 。\n\n很直观的一个做法是：使用 栈 的数据结构，先存储链表的前半部分，然后与后半部分逐个进行比对。但是这么做的话，空间复杂度就是 O(n) 了。\n存在一种空间复杂度 O(1) 的原地解法，即用到我们上面所说的基本套路操作。\n具体做法是：\n\n使用快慢指针，定位至链表的中点\n反转后半部分的链表\n比较前半部分与后半部分的链表是否完全一致public boolean isPalindrome(ListNode head) &#123;  // 定位至链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 反转后半部分的链表  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 比较两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\n常见链表面试题反转链表public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nK个一组翻转链表public ListNode reverseKGroup(ListNode head, int k) &#123;  // 判断剩余节点个数是否够 k 个  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // 翻转接下来的 k 个节点  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 尾部连接  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\n合并两个有序链表public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\n另外，也可以使用迭代法 (类似于归并排序) 。\n判断是否为环形链表public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\n延伸问题： 找到环的入口节点\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\n相交链表public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // 保证两个链表的剩余长度一致  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\n链表相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // 不足补0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // 存在进位现象  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\n重排链表public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // 找到链表的中点  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // 由此，将整个链表分为两部分。  // 前半部分是 [head,mid] ；后半部分是 [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // 反转后半部分的链表  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // 合并两个链表  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\n删除链表的重复元素public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // 去重    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\n两两交换链表中的节点public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\n链表排序public ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\n分隔链表public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["算法","链表"]},{"title":"「Java基础」 基础不牢，地动山摇！","url":"/2022/04/18/%E3%80%8CJava%E5%9F%BA%E7%A1%80%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%EF%BC%81/","content":"四种访问修饰符的作用范围？\n\n\n修饰符\n当前类\n同包下\n子类\n其他包下\n\n\n\npublic\n✔️\n✔️\n✔️\n✔️\n\n\nprotected\n✔️\n✔️\n✔️\n❌\n\n\ndefault\n✔️\n✔️\n❌\n❌\n\n\nprivate\n✔️\n❌\n❌\n❌\n\n\n\n\n基本类型转换\n向上转型没有任何问题。如 long b = 1;\n向下转向会造成精度损失，因此如果需要，必须显式地进行强制转换。如 float f = (float) 2.3;\n\n打个比喻：小杯的水倒进一个大杯里肯定没问题。但大杯的水倒进小杯就不行了，可能会溢出。\n\n\n常量池Java的基本类型的包装类大部分都实现了常量池技术。\n\n\n\nByte\nShort\nInteger\nLong\nCharacter\nBoolean\n\n\n\n[-128,127]\n[-128,127]\n[-128,127]\n[-128,127]\n[0,127]\nTrue&#x2F;False\n\n\nFloat 和 Double 没有使用常量池技术。\n简单地说，如果使用的对象的字面量的值在常量池的范围之内，那么就不会创建新的包装类型对象，而是直接引用常量池中的对象。\nInteger a = 100, b = 100, c = 1000, d = 1000;System.out.println(a == b);  // trueSystem.out.println(c == d);  // false\n\n\n\n同样地，String 也有对应的常量池，称为字符串常量池。不过这和上面提到的包装类型的常量池有些不同的是，字符串常量池事先不会缓存任何内容，而是在每次创建字符串时进行判断：如果已经在常量池中存在，那么就直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。维护字符串常量池的全局表叫做 StringTable，其实就是一个 HashSet&lt;String&gt;。它在JVM中仅有一份实例，并被所有类共享使用。\n在Java中，有两种创建字符串对象的方式：\n\nString str = &quot;hello&quot;;\n这种方式下，由于是通过字面量直接创建，所以在编译的时候对于JVM而言是可以确定的。如果 “hello” 已存在于常量池中，那么直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。\n\nString str = new String(&quot;hello&quot;);\n这种方式下，是通过构造器创建对象，在运行时在堆中创建的。所以它不仅会在常量池中创建一个 “hello” 实例，还会在堆中创建一个 String 对象。\n\n\n可以认为，后者包含了前者。\n\n\n重载和重写的区别？\n重载 Overload 是发生在同一个类中的：\n同名的方法，但是有着不同的参数列表 (参数类型不同&#x2F;参数个数不同)。\n\n重写 Override 是发生在父类与子类之间的：\n子类对父类中提供的某方法进行逻辑的重新定义。\n规定子类被重写方法和父类被重写方法的返回值必须相同，且不能比父类被重写方法声明更多的异常。\n\n\n\n\n为什么说重写 equals() 就要重写 hashCode() ？这其实是一种规定。\n换句话说，如果我们不遵守这样的规定，那么最直接的影响是使用哈希结构的容器就可能出现重大问题，因为它们的底层依赖的正是对象的 hashCode() 方法，而你却没有重写它。例如，HashSet 本身是具有去重功能的，但是现在就出问题了：逻辑上明明相同的两个对象，理应只会有一个存在于容器中，事实却是它们都会存在。\n\n\n另外提一句：equals() 相等的两个对象，hashCode() 要保证一定相等；但是 hashCode() 相等的两个对象，equals() 并不一定要相等。\n理由也很简单：因为 hashCode() 相等也有可能是哈希冲突导致的，实质上是两个不相干的对象。\n\n\nJVM 加载 class 文件的过程？JVM中的类加载过程，都是由类加载器来实现的。当Java程序需要使用某个类时，JVM需要确保这个类已经被加载进内存中，并被成功初始化。\n\n加载：\n在经过编译后，会生成 .class 的字节码文件。通常是使用字节数组来读入字节码文件，并在内存中产生与之对应的 Class 对象。\n\n检验：\n经过了加载的步骤，其实 Class 对象还是不完整的。还需要进行一些检验操作：\n\n该类是否存在父类？如果存在，那么必须要确保父类也已经初始化完毕。\n该类是否存在初始化语句块？如果存在，那么需要依次执行这些代码。\n\n\n\n总体顺序是这样的：\n\n父类到子类依次执行静态初始代码块\n父类执行非静态初始代码块和构造器方法，然后子类执行非静态初始代码块和构造器方法\n\n\n\nJVM的类加载器包括：\n\nBootstrapClassLoader 根加载器：负责加载JVM的基础核心类库\nExtensionClassLoader 扩展加载器：负责加载JVM的扩展类库\nApplicationClassLoader 应用类加载器：负责加载 classpath 下的类文件，即使用者编写的代码\n\n为了确保同一份字节码文件不会被多个类加载器重复加载，所以 JVM 还推出了一个叫做「双亲委派」的机制：当来了一个需要被加载的字节码文件时，当前类加载器不会直接加载它，而是向上抛给它的父加载器。只有当父加载器无法处理时，才返回由当前类加载器进行处理。这样就保证了一份字节码文件仅会被一个类加载器所处理。\n\n\n创建对象的几种方式？\nnew 创建新对象\n使用反射机制\n使用 clone 机制\n通过反序列化方式\n\n\n\n关键字 final 的作用？final 表示不可变的意思，可用于修饰类、属性和方法。\n\n被 final 修饰的类不可以被继承。\n\n被 final 修饰的方法不可以被重写。\n\n被 final 修饰的属性不可变，并且必须被显式地指定初始值。\n另外，这里的不可变指的是引用不可变，而不是引用指向的内容的不可变。\n例如 final int[] nums = new int[3]; 但是数组内部的元素是可以随意修改的啊。\n\n\n\n\n方法参数传递到底是引用传递还是值传递？值传递。\n如果参数是一个基本类型的数据，那么传递的是数据的字面值本身。\n如果参数是一个引用类型的对象，那么传递的是对象的引用地址值。在被调用的过程中，对象的属性可以被修改，并影响到调用者；对象的引用也可以被修改，但是不会影响到调用者。\n\n\n字符串拼接问题String 作为不可变类，它是只读的，对象的内容是无法被改变的。如果需要修改内容，那么只能再通过创建一个新的字符串对象。如果在修改操作十分频繁的场景下，性能就显得十分低下了。\n因此，JDK5开始，引入了 StringBuilder&#x2F;StringBuffer 类，专门用于字符串拼接、删除、插入等修改操作。两者的区别在于线程安全性，由于后者的所有方法都被 synchronized 修饰，因此是线程安全的，但是效率就不如前者了。\n\n\n在JDK8以前，如果在两个字符串对象之间使用 “+” 进行拼接，会生成中间对象。不过，在Java8开始，JVM在编译期对 “+” 进行了优化，变成了基于 StringBuilder 的 append() 方法。所以，经过编译器的处理，加号拼接的性能和 StringBuilder 是一样的！\n当然，如果是循环里进行拼接操作，那么还是建议用 StringBuilder 来显式地调用，否则每循环一次就会创建一个新的 StringBuilder 对象，这肯定不如把 StringBuilder 显式地放在循环外部来得好。\n\n\n抽象类和接口的区别？\n相同点：\n\n它们天生的作用就是被继承&#x2F;实现。不可以被实例化，即不能通过 new 来创建对象。\n可以使用抽象类&#x2F;接口类的引用。如 UserService service = new UserServiceImpl();\n一个类如果继承&#x2F;实现了抽象类&#x2F;接口，那么它就需要对其中的所有抽象方法进行 @Override 重写实现。\n\n\n不同点：\n抽象类和普通类的区别就在于：它可以声明抽象方法 (注意我这里的用词是可以，不是必须)。换句话说，抽象类不一定都要有抽象方法，但具有抽象方法的都一定是抽象类。\n\n接口比抽象类更加“抽象”：抽象类可以存在非抽象方法，但是接口中的方法都必须是抽象的。\n抽象类作为一种类，可以定义构造器、成员变量，并且可以用 public, protected, default, private 来修饰；接口不能定义构造器，成员变量只能用 public 来修饰 (而且，这种变量实质上都是常量)。\n\n\n\n\n\ntry…catch…finally 坑爹题\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      System.out.print(&quot;3&quot;);    &#125;  &#125;&#125;\n\n答案：31\n在 try 返回前，会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的结果 1。\n\n请问以下代码的输出是？\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(test());  &#125;    private static int test() &#123;    try &#123;      return 1;    &#125; catch (Exception e) &#123;      return 2;    &#125; finally &#123;      return 3;    &#125;  &#125;&#125;\n\n答案：3\n在 try 返回前，会先执行 finally 语句块。然而这里的 finally 却不按套路出牌，直接 return 了。\n\n\n\n\nI&#x2F;O流有哪些？\n按照流向：输入流、输出流\n按照操作单元：字节流、字符流\n\nInputStream&#x2F;Reader：所有输入流的基类。前者是字节输入流，后者是字符输入流。\nOutputStream&#x2F;Writer：所有输出流的基类。前者是字节输出流，后者是字符输出流。\n\n\n序列化什么是序列化&#x2F;反序列化？序列化：把Java对象转为二进制流，以方便在网络中进行传输。\n反序列化：把二进制流恢复为Java对象。\n好比生活中对一些大件物品的运输，在运输时将它拆分再打包，使用时再重新组装。\n\n\n如何实现序列化？需要让该Java对象所属的类实现 Serializable 接口。\nSerializable 接口没有什么具体的作用，它只是一个标识性接口。但是如果不实现这个接口，在一些序列化场景下会出错。\n所以一般建议，创建的JavaBean类都实现 Serializable 接口。\n\n\n可以不参与序列化吗？可以。对于那些不想进行序列化的变量，可以使用关键字 transient 进行修饰。\n\n\n常见的序列化手段？\nJava对象流：一般是对象输出流 ObjectOutputStream 和对象输入流 ObjectInputStream\nJSON：很多第三方JSON技术，如Jackson、FastJson、GSON\nProtoBuff：一种轻便高效的结构化数据存储格式，可以大大减少数据传输大小，提高系统性能。\n\n\n\n泛型泛型擦除是什么？Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。也就是说，在运行的时候是没有泛型的。\n这样做的目的，主要是为了能够使JVM向下兼容，因为在JDK5之前是没有泛型的。\n\n\n反射什么是反射？普通的创建对象，是通过 new 的方式。这种方式相当于在编译时已经确定了类型信息。\n如果想在运行时动态地获取类信息，进而创建对应的类型实例，那么就需要使用反射了。\n\n\n通过反射，可以获取任意一个类的任意属性和方法，并调用它们。\n通过设置 setAccessible(true)，就连 private 的属性也可以获取到。\n\n\n\n总结而言，反射的作用主要有：\n\n在运行时创建任意一个类的对象\n在运行时获取任意一个对象的类信息\n在运行时获取任意一个对象的属性和方法，并进行调用\n生成动态代理对象\n\n\n\n反射的原理是什么？在类加载时期，JVM使用类加载器将字节码文件加载入内存。反射就是在这个期间获取类信息，然后进行各种操作。\n\n\n反射有哪些使用场景？一般而言，我们很少会直接接触并编写反射代码。但是，这并不代表反射没有用。相反，正是因为反射，才能这么轻松地使用各种框架。\n\nSpring框架中，利用反射机制来注入属性、调用方法。\nJDBC中，利用反射机制来动态加载数据库的驱动类。\n\n\n\n反射的使用姿势\n通过全限定类名创建一个对象\nClass clazz1 = Class.forName(&quot;java.lang.String&quot;);Class clazz2 = &quot;hello&quot;.getClass();\n\n创建一个实例对象\n// 第一种方式：通过class对象的 newInstance() 方法Object obj1 = clazz.newInstance();// 第二种方式：通过class对象获得对应的构造器对象，再使用构造器对象的 newInstance() 方法Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(new Class[]&#123;String.class&#125;);Object obj2 = constructor.newInstance(new Object[]&#123;&quot;hello&quot;&#125;);\n\n通过class对象获得一个属性对象 Field\n// getFields 可以获取public属性Field field1 = clazz.getFields();// getDeclaredFields 可以获取所有属性Field field2 = clazz.getDeclaredFields();\n\n通过class对象获得一个方法对象 Method\n// getMethod 可以获取public方法Method method1 = clazz.getMethod(String methodName);// getDeclaredMethod 可以获取所有方法Method method2 = clazz.getDeclaredMethod(String methodName);// 可以执行private方法method2.setAccessible(true);\n\n执行方法\nmethod.invoke(obj);\n\n\n\n\n例子：\nimport java.lang.reflect.Method;public class Main &#123;  public static void main(String[] args) throws Exception &#123;    String s1 = &quot;hello&quot;;    // 通过对象.getClass()得到一个class对象，并获得指定的方法对象    Method method = s1.getClass().getMethod(&quot;toUpperCase&quot;);    // 调用该方法    String s2 = method.invoke(s1); // HELLO  &#125;&#125;\n\n\n\n设计模式手写个单例模式类？注意点：\n\n保证构造器方法是不对外暴露的，即：将默认无参构造方法声明为 private\n通过唯一的公开静态方法向外界提供单例实例\n\n\n\n\n饿汉式 (线程安全)\npublic class Singleton &#123;   private static Singleton singleton = new Singleton();    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    return singleton;  &#125;&#125;\n\n懒汉式1 (线程不安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n懒汉式2 (synchronized 线程安全)\npublic class Singleton &#123;   private static Singleton singleton;    private Singleton() &#123;&#125;    public static synchronized Singleton getSingleton() &#123;    if (singleton == null) &#123;      singleton = new Singleton();    &#125;    return singleton;  &#125;&#125;\n\n懒汉式3 (volatile+DCL 线程安全)\npublic class Singleton &#123;   private static volatile Singleton singleton;    private Singleton() &#123;&#125;    public static Singleton getSingleton() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n懒汉式4 (静态内部类 线程安全)\npublic class Singleton &#123;    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;    private static final Singleton SINGLETON = new Singleton();  &#125;    public static Singleton getSingleton() &#123;    return SingletonHolder.SINGLETON;  &#125;&#125;\n\n\n\n总结来说，使用哪种都是可以的。即使是饿汉式的单例模式，问题也不大，因为现在的内存也不再那么稀缺了，而且这种实现的代码可读性挺好的。\n\n\n设计模式及其实际应用\nSpring的IOC容器应用了工厂模式，通过 ApplicationContext 或 BeanFactory 来创建并管理对象，然后使用反射机制来获取对象。\n\n\n\nBeanFactory\nApplicationContext\n\n\n\n懒加载\n即时加载\n\n\n不支持注解形式的依赖\n支持注解形式的依赖\n\n\n一般使用的IOC容器实现类都是 ApplicationContext 接口，它扩展了 BeanFactory 接口。\n\nSpring的对象默认是单例模式的。Spring源码中对于单例模式的实现，使用的是 volatile+DCL 方式。\n\nSpringAOP 使用了代理模式。\n具体实现可能是JDK动态代理，也可能是CGLib动态代理。这取决于目标代理对象是否是一个接口的实现类，如果是则会使用JDK动态代理。\nJDK动态代理是面向接口的，CGLib动态代理是基于底层字节码来生成一个被代理对象的子类。换句话说，如果被代理类是 final 的，那么CGLib代理就会失败。\n\n\n\n\n","tags":["Java","八股文"]},{"title":"「多线程」 时间管理大师","url":"/2022/05/17/%E3%80%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8D%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%E7%A8%8B%E5%BA%8F%E6%8C%87%E5%8D%97/","content":"线程线程的几种状态？\n新建 New\n就绪 Runnable\n运行 Running\n阻塞 Blocked\nI&#x2F;O ：阻塞态，仅释放CPU资源，但不会释放占有着的锁。如 sleep()\nWaiting ：等待态，会释放CPU资源和占有着的锁。如 wait()\nTimed Waiting ：带有超时的等待态\n\n\n结束 Terminated\n\n\n\n线程和进程的区别是什么？\n首先，可以从宏观的角度看待它们的关系：一个程序至少有一个进程，一个进程至少有一个线程。\n进程是操作系统进行资源分配的最小单元，每个进程都有自己独立的内存空间。进程与进程之间是不共享资源的。如果需要，那么就要使用通信技术（socket、channel）。\n线程是操作系统进行资源调度的最小单元。除了线程自己的函数堆栈等，线程与线程之间是共享资源的（这也是为什么会存在线程安全这一问题）。\n打个比喻：进程是水杯，线程是水杯里的水。人喝的是水而不是水杯，但是如果没有水杯来装水也是不行的。\n\n进程可以看作是重量级的线程。在多任务处理机的环境下，如果直接使用进程作为调度单元，那么在资源切换时的开销是比较大的。为了提高执行效率，所以引入了线程来取代进程的资源调度功能。\n\n\n\n\n上下文切换是什么？因为多线程是共用计算机上的CPU资源的，并且在一般情况下，线程数都是大于CPU核心数的。为了让所有线程都有执行的机会，所以需要进行线程之间的调度切换。这种切换就是上下文切换。在切换前，需要保存CPU的状态；在切换回来后，又需要恢复CPU的状态，使得线程能够正确地从中断处恢复执行。\n在Java中，线程调度采用的是抢占式的方式。一个线程的时间片到后，操作系统会根据线程优先级、线程饥饿情况、CPU空闲率等多方面因素，选出下一个线程，并分配时间片给它。\n可以通过 setPriority() 来设置线程的优先级。不过，你不能指望靠它来保证，因为最终权还是在底层的操作系统。但是，如果不是特别需求，就不要改动线程的优先级，因为这可能会因为设置不当，造成线程饥饿问题（当前线程被一个高优先级的线程吞噬掉了所有的CPU时间）。\n\n\n什么是线程饥饿？线程饥饿指的是：一个线程因为某种原因无法获得所需资源，导致一直无法执行下去。\n\n\n听起来和死锁有点像：死锁是指两个及以上的线程在执行时，因互相需要对方的资源，却又不肯先释放自己持有的资源，导致全都永远等待在原地。\n死锁和饥饿的相同点是：二者都是因为资源的竞争引起的问题。\n死锁和饥饿的不同点是：\n\n在死锁中，资源的占有方和资源的拥有方互相请求对方的资源；在饥饿中，当前线程只是迟迟得不到所需资源，但是并不在乎这个资源是谁给的！\n死锁一定涉及多个线程，而饥饿可能只有一个线程。\n当饥饿发生时，除了饥饿线程得不到执行机会，其他线程都还是正常执行的；当死锁发生时，可能最终会使整个系统都陷入死锁并崩溃。\n\n\n\nCallable 和 Future 的区别？Callable 接口类似于 Runnable (从名字也可以看得出) ，不过 Runnable 不会返回执行结果，也无法抛出返回结果的异常。但是 Callable 就弥补了这一缺陷，可以认为是带有回调功能的 Runnable ：能够返回异步执行的结果，然后由 Future 接收到。\n\n\n线程之间如何进行通信？\n使用 Object 类中提供的 wait() &amp; notify()/notifyAll() 、park() &amp; unpark() 机制\n使用 concurrent 包下的同步工具类，如 CountDownLatch 、CyclicBarrier 。\n\n\n\n为什么要把 wait()、notify() 这种方法定义在 Object 类中？\nJava 中的每个对象都有一个对应的 Monitor 对象。当该对象调用了 wait()、notify() 这些方法时，其实就是在向 Monitor 对象传达信息：等待对象的锁 &#x2F; 通知其他线程对象的 Monitor 是可用的。\n在 Java 的线程中，并没有提供线程同步的方法。为了使得每个类都具有线程间通信的能力，所以给每个类都应该提供一个类似 wait() 、 notify()/notifyAll() 的方法。而 Object 作为所有类的父类，将这样的方法直接放在 Object 中也是十分合适的。\n\n\n\n保证线程安全的方案？\n使用 synchronized 关键字\n\n使用 Lock 接口下的实现类\n\n使用线程的本地局部变量 ThreadLocal\n简单来说就是一种以空间换时间的数据隔离思想：在每个线程中，维护了一个 ThreadLocalMap，用 set() &#x2F; get() 来使用当前线程的数据，最后将这个 Map 挂到当前线程下，所以 Map 就只属于这个线程了。数据不再共享，自然就不存在线程安全的问题了。\n\n将对象设置为不可变的 (即对象一旦被创建，就不能再改变了)\n比如 String、基本类型的包装类，这些都是不可变类 (被 final 修饰) 。\n\n另辟空间，在操作结束后替换引用地址 (如 CopyOnWriteArrayList)\n\n\n\n\n线程池为什么要用线程池？直接 new Thread() 不好吗？\n创建线程对象是一个开销较大的操作，无论是对CPU还是对内存占用。所以，如果一个任务就开辟一个新线程，性价比实在是太低了。\n\n通过 new Thread() 得到的线程是不易管理的（一般被称为野线程），甚至可以无限制的创建！如此一来，如果使用者使用不慎，可能就导致整个操作系统瘫痪了……🙃\n\n通过 new Thread() 得到的线程也不易于扩展。比如，想要定时执行、定期执行的话，都是不容易实现的。\n\n\n\n\n因此，引入了一个名为线程池的思想，完美解决了上述缺点。\n\n复用已创建好的那些线程，从而降低了资源消耗，并且便于管理\n可以很方便地进行功能扩展，达到定时执行等效果\n\n不过，如果阅读过阿里巴巴开发手册就会发现，不建议使用 Executors 来创建线程。主要原因是：用这样的方式来创建线程，使用者对于这个默认线程池的规则是不够了解的，这就有可能导致使用不当。\n所以，一般建议使用 ThreadPoolExecutor 来创建线程池，并由使用者来设置线程池的一些核心参数，保证使用者对于这个自定义线程池的规则是了解的。\n\n\n常用的线程池\nnewCachedThreadPool()：创建一个可缓存线程池，如果线程池的大小超过实际需要，在超时时间后会回收空闲线程。当任务数增加时，又可以动态地添加新线程来处理任务。\nnewFixedThreadPool()：创建一个大小固定的线程池。每次提交一个任务就会创建一个线程，直至到达线程池的最大大小。超出的线程会在阻塞队列中等待。\nnewSingleThreadExecutor()：创建一个单线程化的线程池，使用唯一的工作线程来执行所有任务。可以保证所有任务都是按照顺序来执行的。\nnewScheduledThreadPool()：创建一个大小固定的线程池。支持定时及周期性任务执行。\n\n\n\n解读一下线程池的7大核心参数？\ncorePoolSize : 核心线程数\nmaximumPoolSize : 最大线程数 (核心线程数+救急线程数)\nkeepAliveTime : 空闲的救急线程的最大存活时间\nTimeUnit : keepAliveTime 的时间单位\nworkQueue : 阻塞队列，用于存放那些待执行的任务\nthreadFactory : 创建线程池中的工作线程的线程工厂 (一般都是默认即可)\nrejectedHandler : 拒绝策略。当线程池中的阻塞队列已满，且线程数已达到最大线程数时，执行拒绝策略。\nAbortPolicy : 拒绝新任务并抛出异常\nDiscardPolicy : 拒绝新任务，但不抛出异常\nCallerRunsPolicy : 使用当前调用的线程来执行此任务 (相当于为了让任务不失败，于是让它插队)\nDiscardOldestPolicy : 抛弃阻塞队列头部 (最旧) 的一个任务，并执行当前任务\n\n\n\n\n\n对于阻塞队列的使用，需要进行一点说明：\n\n如果使用的是 LinkedBlockingQueue 等无界队列，那么可以无限地向线程池中添加任务 (因为阻塞队列不会满) 而不会触发拒绝策略。并且，也不会触发救急线程。所以，相当于 maximumPoolSize, keepAliveTime, TimeUnit, rejectedHandler 都是无意义的参数。\n如果使用的是 ArrayBlockingQueue 等有界队列，那么如果阻塞队列已满，就会触发救急线程。如果救急线程也达到了上限，那么再有新任务时就会触发拒绝策略。\n\n\n\n线程池的执行流程？\n当线程数小于 corePoolSize 时，使用核心线程来执行任务\n当线程数大于 corePoolSize 时，将多余的任务放入阻塞队列\n当阻塞队列已满时，启动救急线程来执行\n当阻塞队列已满，且线程数已达到 maximumPoolSize 时，执行拒绝策略\n当阻塞队列不再满时，已创建的那些救急线程就进入空闲状态。如果它们的空闲时间超过 keepAliveTime ，就会回收这些救急线程\n\n\n\nsubmit() 和 execute() 的区别？这两者都是用于向线程池提交任务的。\n区别在于：\n\nexecute() 没有返回值\nsubmit() 返回值是一个 Future 对象，从而可以得到异步执行的结果\n\n\n\nsynchronized 关键字synchronized 修饰在不同的位置，各代表什么？\n如果 synchronized 修饰的是一个实例方法，则上锁的是调用该方法的对象实例\n如果 synchronized 修饰的是一个静态方法，则上锁的是所在类的Class实例\n如果 synchronized 修饰的是一个代码块，则上锁的是传入 synchronized 括号内的对象实例\n\n请知道一条原则：同步块的作用范围越小越好。\n\n\nsynchronized 的底层原理是什么？前置知识点：Mark Word 、Monitor 对象\n无论 synchronized 修饰的是什么，对应的锁都是一个实例对象。\n一个对象，是由三部分组成的：对象头、对象实际内容、对齐填充字段。synchronized 的原理，就在于对象头之中的 Mark Word 部分。这部分就负责记录对象关于锁的信息。\n\n另外，每个对象都会有一个 Monitor 对象，存储着当前持有该 (对象) 锁的线程，并维护一个阻塞等待该 (对象) 锁的等待队列。\n\n\n\n\n锁的优化在JDK1.6之前，锁的操作都是重量级的：monitor对象直接存储持有着锁的线程的id，并设置 Mark Word 中的 monitor对象地址，把其他阻塞等待的线程都加入等待队列中。这个加锁的过程是依赖底层操作系统的 mutex 指令的，存在用户态与内核态之间的切换，所以性能损耗十分严重。\n在JDK1.6之后，引入了偏向锁、轻量级锁的概念，它们是在JVM层面的规定，所以就不依赖于底层操作系统，性能得到大幅提升。\n总体流程是：无锁 &#x3D;&#x3D;&gt;  偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁。并且，锁只有升级，不存在降级。\n从使用层面看，至始至终都是关键字 synchronized，即：这种优化是内部的，对于使用者而言是无感知的。引入了偏向锁和轻量级锁这两个概念，就是为了能够尽可能地提高并发执行时的效率问题。\n\n偏向锁\nJVM认为在同一时间，只会有一个线程来执行同步块中的代码，即：这是一个没有竞争的环境。\n所以直接在 Mark Word 中记录该线程。如果一个线程想要获得锁，就直接比对线程ID与 Mark Word 中存放的是否一致，一致就可以直接获得这个锁；否则，用CAS来尝试修改 Mark Word，将记录改为当前线程ID。\n如果CAS修改成功，那么线程仍旧可以获得这个锁；否则，说明当前环境是存在竞争的，于是升级为轻量级锁。\n\n轻量级锁\n当前线程会在栈帧下创建 Lock Record，把 Mark Word 的信息都拷贝进去。如果一个线程想要获得锁，先用CAS来尝试将 Mark Word 信息修改为该线程的 Lock Record。\n如果CAS修改成功，那么线程就获取到了这个锁 (轻量级) ；否则，进行自旋重试。当自旋一定次数后仍不能获得锁，就升级为重量级锁。\n\n\n总结：\n\n只有一个线程进入临界区：偏向锁\n多个线程交替进入临界区：轻量级锁\n多个线程同时进入临界区：重量级锁\n\n\n\n关于 java.util.concurrent乐观锁和悲观锁是如何理解的？\n乐观锁：非常乐观，认为每次拿到的数据都没有被人修改过，所以不会上锁。\n在进行更新的时候，使用的是CAS算法：先判断当前值是否是预期值，如果是，则可以进行写操作写入新值；否则，被告知这次竞争失败，然后进行再次尝试，直到成功。\n乐观锁的缺点是：\n\nABA 问题\n线程1读取了某变量的值是A 。此时线程2也读取了该变量，并且线程2将它改为了B ，后又改回为A 。\n然后线程1进行CAS操作，发现当前值与预期值一致，均为A ，于是放心地写入了新值。\n以上过程，线程1的CAS操作是成功的，但这是有潜在隐患的。\n从 JDK1.5 开始，提供了一个名为 AtomicStampedReference 的类来解决ABA问题，即增加了一个比对元素：版本号。每次操作后都会更新这个版本号。这样，即使是同一个值，如果版本号不一致，也被认为是CAS失败。\n\n如果资源竞争十分激烈，那么CAS自旋的概率会很高，从而导致大多数时间都是在浪费CPU资源，效率反而不如 synchronized 。\n\n只能保证对于一个变量的原子操作。如果需要保证对于多个变量的原子操作，那么就需要用锁了。\n\n\n\n悲观锁：非常悲观，总是做最坏的打算，认为每次拿到的数据都是被人修改过了的，所以每次在拿到数据时都会上锁，这样其他线程就拿不到了。\nJava 的同步关键字 synchronized 就是悲观锁的。此外，传统的关系型数据库 (例如MySQL) 里面的行锁、表锁、读锁、写锁等，用到的也都是悲观锁的机制。\n悲观锁是足够安全的，但是缺点也很明显：每次操作都要上锁，结束后再释放锁，比较耗时。\n\n\n在大多数情况下 (竞争不是特别激烈) ，乐观锁的性能是好于悲观锁的。\n\n\nLock 接口是什么？对比传统的同步，有什么优势？Lock 接口是同步的扩展，使用起来更加**灵活 **。典型的实现类是 ReentrantLock 。\n\n支持公平&#x2F;非公平的模式选择 (出于性能考虑，一般都是默认非公平模式)\n允许线程在等待锁时被中断\n允许让线程去尝试获得锁，如果无法获得，可以选择立即返回不再等待或是等待一段时间 (带有超时时间)\n配合条件变量 Condition 来使用，达到 wait&#x2F;notify 的效果，并且是支持中断、超时的\n\n不过，需要注意的是：使用 synchronized 无需考虑释放锁的操作，因为这是自动的；而 Lock 就必须要求使用者手动来释放锁资源。因此，最规范的写法就是在 finally 块中进行 unlock() 释放操作。\n\n\n公平锁和非公平锁的区别是什么？简单来说，公平锁模式是讲究先来后到的顺序的；非公平锁模式是谁准备好了就谁来。\n公平锁：在竞争环境下，先到达临界区的线程一定比后到达临界区的线程更早地获得锁。\n非公平锁：在竞争环境下，先到达临界区的线程未必比后到达临界区的线程更早地获得锁。\n所以，决定它们的因素就是：如果一个线程到达了临界区，它是否会直接尝试获得锁 (非公平) ，还是会直接进入等待队列 (公平) 。\n\n\n并发容器类\nCopyOnWriteArrayList (性能较差的同步容器是 Vector)\n主要特点是：读写分离。\n\n实际的写操作发生在复制的数组上，而读操作还是在原始数组中进行，从而实现读写分离，互不影响。\n在写操作时需要加锁，防止并发写入时导致写入数据丢失。\n在写操作结束后，把原始数组的引用指向新的复制数组。\n\n缺点是：\n\n由于每次写操作都会复制出一个新的数组，所以是比较耗费内存的。\n只能保证最终一致性，无法保证实时一致性。\n\n我们可以从中学到的线程安全解决思路是：通过另辟空间，来解决并发问题。\n\nConcurrentHashMap (性能较差的同步容器是 HashTable)\n底层数据结构与普通的 HashMap 一样，同为数组+链表&#x2F;红黑树。\n\n在 put() 写操作时需要加锁，不过使用的是 CAS算法 (在JDK8之前，使用的是分段锁的方式)\n在 get() 读操作时不加锁，value属性通过 volatile 关键字进行修饰，保证了内存可见性，即每次 get() 得到的都是最新值\n\n\n\n\n\n同步工具类\nCountDownLatch\n在创建时传入一个参数 new CountDownLatch(int initial) 作为计数次数。\n其他线程每调用一次 countDown() 方法，计数器减1。\n当计数器被减为0时，主线程从 latch.await() 处重新被唤醒，然后继续执行后续代码。\n\nCyclicBarrier\n和 CountDownLatch 的作用一样，只不过 CountDownLatch 只能使用一次，使用之后就会失效，而 CyclicBarrier 可以反复使用。\n\nSemaphore\n在不超过设定上限的线程数的情况下，允许多个线程并行执行。主要用于限流之类的操作，限制某段代码块的并发数。打个比喻：Semaphore 就好比是一个停车场，允许同时停放多辆车辆，但也总有一个上限。\n如果 Semaphore 的构造函数中传入的参数是 1 ，就相当于一个 synchronized 了。\n\n\n\n\nAQS是什么？全称是 AbstractQueuedSynchronizer 。作为一个抽象类，相当于是很多同步容器的框架模板，其中制定了很多用于保证线程安全的基本规则。\n常用的实现类有 ReentrantLock, Semaphore, FutureTask 等。\n\n\nAQS的原理底层是使用一个双向链表来维护一个FIFO的等待队列，还有一个 state 的状态变量。\n队列中存储的实体是 Node 节点，记录了当前的状态值、同步模式 (独占 &#x2F; 共享) 、前驱节点和后继节点。\n总体流程是：把需要等待的线程以 Node 节点的形式加入到等待队列中，用 state 变量来维护当前锁的状态。\n当调用了 lock() 方法时：\n\n使用CAS来尝试获得锁。如果成功，那么就可以执行同步块中的代码；\n\n否则，调用 acquire() 方法，判断 state 是否为0。如果等于0，说明没有其他线程持有这把锁，那么就再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n\n否则，说明有线程正在持有着这把锁。于是再判断当前线程是否持有着锁，如果是，那么更新 state 的值加1 (这里正是可重入的体现) ，然后就可以执行同步块中的代码；\n\n否则，只能将当前线程加入等待队列中，然后将自己 park() 挂起，等待后续被唤醒后再继续进行CAS尝试……直至成功，然后执行同步块中的代码。\n在加入等待队列的过程中，其实还有一些细节：\n\n节点入队后，会判断前驱节点是否为头节点。如果是头节点，那么就可以再进行一次CAS尝试。如果成功，那么就可以执行同步块中的代码；\n否则，会把前驱节点的状态设置为 SIGNAL (-1) ，用以表示后续节点需要被唤醒，而这个任务就交给了前驱节点。\n\n\n\n当调用了 unlock() 方法时，就非常简单了：把 state 置0，然后唤醒等待队列中第一个需要被唤醒的节点 (节点的 state 小于0) ，然后这个节点就会进行CAS尝试来获得锁。\n\n\nAQS的同步方式是什么？AQS支持两种同步方式：独占式和共享式。\n独占式，锁只会被一个线程持有。如 ReentrantLock\n共享式，多个线程可以同时执行。如 Semaphore, CountDownLatch\n\n\nvolatile 关键字volatile 的作用是什么？\nvolatile 可以保证内存可见性。被 volatile 修饰的变量在进行写操作后，其他线程能马上读到最新值。\n简单地说，就是在对一个 volatile 变量进行写操作前，JMM会插入一个写屏障，保证所有线程都可以马上看见这个新值；在对一个 volatile 变量进行读操作前，JMM会插入一个读屏障，保证任何数据的更新对所有线程都是可见的。\n\nvolatile 可以保证不会发生指令重排序的问题。最典型的使用场景就是懒汉式的DCL单例模式。\n\n\nclass Singleton &#123;  /** 这里一定要使用 volatile 关键字来修饰单例实例，以防止指令重排序导致的线程不安全问题 */  public static volatile Singleton singleton;    /** 构造器使用 private 修饰，对外部进行屏蔽 */  private Singleton() &#123;&#125;    /** 对外暴露的唯一公开静态方法，以此提供单例实例。这里使用 volatile+DCL 来保证线程安全 */  public static Singleton getInstance() &#123;    if (singleton == null) &#123;      synchronized (Singleton.class) &#123;        if (singleton == null) &#123;          singleton = new Singleton();        &#125;      &#125;    &#125;    return singleton;  &#125;&#125;\n\n​\t线程安全的单例模式还可以是静态内部类；亦或是直接使用饿汉式，在类加载时就创建，由jvm保证了线程安全性。\n​\t不过就不展开了，毕竟本文的主要内容不是设计模式 :-)\n\n与CAS操作结合，保证线程安全性。\n\n\n\n为什么会发生指令重排序？这是出于性能最大化考虑，CPU常常会对指令进行重排序。当然，前提是不会改变程序的运行结果 🤣 否则编程就成为一个玄学问题了。\n\n\n一些编写多线程的最佳实践\n不要自己手动创建线程对象，而是使用线程池来管理线程对象，达到资源复用的效果。\n给线程命名，并开启打印线程名的功能。这有助于进行调试。\n尽可能最小化临界区的范围，而不是无脑地将整个方法进行同步。这有助于性能提升。\n尽可能使用 volatile 而不是 synchronized\n当需要进行线程间通信时，使用 concurrent 包下的那些同步工具类（如 CountDownLatch, Semaphore），而不是使用 wait() &amp; notify()。\n当需要使用线程安全的容器集合时，使用 concurrent 包下的那些并发容器类，而不是 util 包下的同步容器类。\n\n","tags":["Java","多线程"]},{"title":"「二分最值」 二分法还能这么用？！","url":"/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/","content":"前言本文的知识是建立于熟悉掌握二分法的思想与模板代码之上的。\n因此，如果存在任何不确定&#x2F;疑问，可以先移步至此 👉 「二分法」二分最硬干货，就在这了！ ，其中给出了实用的二分查找模板代码。\n如果已经温习完毕&#x2F;足够熟悉，那么，接下来就开始了~\n\n\n总体思路最核心的问题是，为什么这类题目可以使用二分法？又没有什么有序数组，也没有什么查找目标，这是干嘛呢？\n原因在于这类最值问题的答案本身具有二段性。\n所谓二段性，翻译成大白话就是：假设我在 h 小时内到达 d 的最小速度是 s ，那么如果我以 s-1 的速度出发，就一定不能在 h 小时内到达 d 。\n而我们使用二分查找，其实就是在查找这个临界最值，即答案。\n\n如果求的是在满足要求下的最小值，那么查询目标就是第一个满足要求的数值；\n如果求的是在满足要求下的最大值，那么查询目标就是最后一个满足要求的数值。\n\n\n\n概括而言，可以将这类问题的解题步骤分为两部分：\n\n确定答案区间。左区间一般取0或1，而右区间取题目规定的最大数据范围。\n根据题目所求，确定二分模板。\n编写检验函数 check()。这也是最困难，最不确定的一部分。每个题目需要具体情况具体分析。\n\n\n\n题单汇总 🏷️显式最值问题简单计算LeetCode.1283 – 使结果不超过阈值的最小除数题面\n给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。\n每个数除以除数后都向上取整，比方说 7&#x2F;3 &#x3D; 3 ，10&#x2F;2 &#x3D; 5 。\n题目保证一定有解。\n\n示例 1：\n\n输入：nums &#x3D; [1,2,5,9], threshold &#x3D; 6输出：5解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n\n\n\n代码class Solution &#123;  public int smallestDivisor(int[] nums, int threshold) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, threshold, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 divisor 作为除数，使得结果不超过 threshold */  private boolean check(int[] nums, int threshold, int divisor) &#123;    int sum = 0;    for (int num : nums) &#123;      sum += num / divisor + (num % divisor == 0 ? 0 : 1);    &#125;    return sum &lt;= threshold;  &#125;&#125;\n\n\n\nLeetCode.1300 – 转变数组后最接近目标值的数组和题面\n给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。\n如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。\n请注意，答案不一定是 arr 中的数字。\n\n示例 1：\n\n输入：arr &#x3D; [4,9,3], target &#x3D; 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n\n\n\n代码class Solution &#123;  public int findBestValue(int[] arr, int target) &#123;    int left = 0, right = 0;    for (int num : arr) &#123;      right = Math.max(right, num);    &#125;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(arr, target, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    int sum1 = getSum(arr, left - 1), sum2 = getSum(arr, left);    return target - sum1 &lt;= sum2 - target ? left - 1 : left;  &#125;    private boolean check(int[] arr, int target, int value) &#123;    return getSum(arr, value) &gt;= target;  &#125;  private int getSum(int[] arr, int value) &#123;    int sum = 0;    for (int num : arr) &#123;      sum += Math.min(num, value);    &#125;    return sum;  &#125;&#125;\n\n\n\nLeetCode.875 – 爱吃香蕉的珂珂题面\n珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。\n珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n\n示例 1：\n\n输入：piles &#x3D; [3,6,7,11], h &#x3D; 8\n输出：4\n\n\n\n代码class Solution &#123;  public int minEatingSpeed(int[] piles, int h) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(piles, h, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;\t  /** 能否以 speed 的速度，在 h 小时内吃完所有香蕉 */  private boolean check(int[] piles, int h, int speed) &#123;    int cost = 0;    for (int pile : piles) &#123;      cost += pile / speed + (pile % speed == 0 ? 0 : 1);    &#125;    return cost &lt;= h;  &#125;&#125;\n\n\n\nLeetCode.2064 – 分配给商店的最多商品的最小值题面\n给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。\n你需要将 所有商品 分配到零售商店，并遵守这些规则：\n一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。请你返回最小的可能的 x 。\n\n示例 1：\n\n输入：n &#x3D; 6, quantities &#x3D; [11,6]输出：3解释：一种最优方案为：\n\n11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) &#x3D; 3 。\n\n\n\n\n代码class Solution &#123;  public int minimizedMaximum(int n, int[] quantities) &#123;    // TODO  &#125;&#125;\n\n\n\nLeetCode.1870 – 准时到达的列车最小时速题面\n给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。\n每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。\n例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。\n生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。\n\n示例 1：\n\n输入：dist &#x3D; [1,3,2], hour &#x3D; 6输出：1解释：速度为 1 时：\n\n第 1 趟列车运行需要 1&#x2F;1 &#x3D; 1 小时。\n由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3&#x2F;1 &#x3D; 3 小时。\n由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2&#x2F;1 &#x3D; 2 小时。\n你将会恰好在第 6 小时到达。\n\n\n\n\n代码class Solution &#123;  public int minSpeedOnTime(int[] dist, double hour) &#123;    if (dist.length - 1 &gt; (int) hour || (dist.length - 1 == (int) hour &amp;&amp; hour % (int) hour == 0)) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e7;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(dist, hour, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 speed 的速度，在 hour 小时内到达终点 */  private boolean check(int[] dist, double hour, int speed) &#123;    int cost = 0;    for (int i = 0; i &lt; dist.length - 1; i++) &#123;      cost += dist[i] / speed + (dist[i] % speed == 0 ? 0 : 1);    &#125;    return cost + (double) dist[dist.length - 1] / speed &lt;= hour;  &#125;&#125;\n\n\n\nLeetCode.2187 – 完成旅途的最少时间题面\n给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。\n每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。\n给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3], totalTrips &#x3D; 5输出：3解释：\n\n时刻 t &#x3D; 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。已完成的总旅途数为 1 + 0 + 0 &#x3D; 1 。\n时刻 t &#x3D; 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。已完成的总旅途数为 2 + 1 + 0 &#x3D; 3 。\n时刻 t &#x3D; 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。已完成的总旅途数为 3 + 1 + 1 &#x3D; 5 。所以总共完成至少 5 趟旅途的最少时间为 3 。\n\n\n\n\n代码class Solution &#123;  public long minimumTime(int[] time, int totalTrips) &#123;    long left = 1L, right = (long) 1e14;    while (left &lt; right) &#123;      long middle = left + ((right - left) &gt;&gt; 1);      if (check(time, (long) totalTrips, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 totalTime 的时间内，至少完成 totalTrips 次旅途 */  private boolean check(int[] time, long totalTrips, long totalTime) &#123;    long count = 0;    for (int t : time) &#123;      count += totalTime / t;    &#125;    return count &gt;= totalTrips;  &#125;&#125;\n\n\n\nLeetCode.1760 – 袋子里最少数目的球题面\n给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。\n你可以进行如下操作至多 maxOperations 次：\n选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。\n请你返回进行上述操作后的最小开销。\n\n示例 1：\n\n输入：nums &#x3D; [9], maxOperations &#x3D; 2输出：3解释：\n\n将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。\n将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n\n\n\n\n代码class Solution &#123;  public int minimumSize(int[] nums, int maxOperations) &#123;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, maxOperations, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 maxOperations 次操作内实现 cost 的开销 */  private boolean check(int[] nums, int maxOperations, int cost) &#123;    int count = 0;    for (int num : nums) &#123;      // 这里需要注意的细节是：      // 如果正好可以分完，那么共需要 num/cost 个袋子      // 不过算上本来就有的一个袋子，所以还需要 num/cost-1 个袋子      count += num / cost + (num % cost == 0 ? -1 : 0);    &#125;    return count &lt;= maxOperations;  &#125;&#125;\n\n\n\n历史标记LeetCode.1552 – 两球之间的磁力题面\n在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。\n已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。\n给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。\n\n示例 1：\n\n输入：position &#x3D; [1,2,3,4,7], m &#x3D; 3输出：3解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n\n\n\n代码class Solution &#123;  public int maxDistance(int[] position, int m) &#123;    Arrays.sort(position);    int left = 1, right = position[position.length - 1] - position[0];    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(position, m, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在任意相邻小球的间隔不超过 dist 的情况下，放入 m 个球 */  private boolean check(int[] position, int m, int dist) &#123;    int count = 1, cur = position[0];    for (int p : position) &#123;      if (cur + dist &lt;= p) &#123;        count++;        cur = p;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1482 – 制作 m 束花所需的最少天数题面\n给你一个整数数组 bloomDay，以及两个整数 m 和 k 。\n现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。\n花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。\n请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。\n\n示例 1：\n\n输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1输出：3解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3\n\n\n\n代码class Solution &#123;  public int minDays(int[] bloomDay, int m, int k) &#123;    if (bloomDay.length &lt; m * k) &#123;      return -1;    &#125;    int left = 1, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(bloomDay, m, k, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在 waitingDay 天之内，制成 m 束花 */  private boolean check(int[] bloomDay, int m, int k, int waitingDay) &#123;    int combo = 0, count = 0;    for (int day : bloomDay) &#123;      combo = day &lt;= waitingDay ? combo + 1 : 0;      if (combo == k) &#123;        count++;        combo = 0;      &#125;    &#125;    return count &gt;= m;  &#125;&#125;\n\n\n\nLeetCode.1011 – 在 D 天内送达包裹的能力题面\n传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。\n\n示例 1：\n\n输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], days &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n\n\n\n代码class Solution &#123;  public int shipWithinDays(int[] weights, int days) &#123;    int left = 1, right = 500 * 5 * 10000;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(weights, days, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否以 capacity 的运量，在 days 天内运输完所有包裹 */  private boolean check(int[] weights, int days, int capacity) &#123;    int sum = 0, cost = 0;    for (int w : weights) &#123;      // 单个包裹的重量不能够超过总运量      if (w &gt; capacity) &#123;        return false;      &#125;      sum += w;      if (sum &gt; capacity) &#123;        sum = w;        cost++;      &#125;    &#125;    cost++;    return cost &lt;= days;  &#125;&#125;\n\n\n\nLCP.12 – 小张刷题计划题面\n为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。\n在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。\n我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。\n\n示例 1：\n\n输入：time &#x3D; [1,2,3,3], m &#x3D; 2\n输出：3\n解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。\n\n\n\n代码class Solution &#123;  public int minTime(int[] time, int m) &#123;    int left = 0, right = (int) 1e9;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(time, m, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 能否在一天耗时最多为 maxTime 的情况下，在 m 天内完成所有计划 */  private boolean check(int[] time, int m, int maxTime) &#123;    // maxCost 记录当天花费最久的题目，将它交给场外求助    int costTime = 0, maxCost = 0, costDay = 0;    boolean help = false;    for (int t : time) &#123;      costTime += t;      maxCost = Math.max(maxCost, t);      if (costTime &gt; maxTime) &#123;        if (!help) &#123;          costTime -= maxCost;          help = true;        &#125;        if (costTime &gt; maxTime) &#123;          costTime = maxCost = t;          costDay++;          help = false;        &#125;      &#125;    &#125;    costDay++;    return costDay &lt;= m;  &#125;&#125;\n\n\n\n规律计算LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长题面\n给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。\n请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。\n\n示例 1：\n\n\n输入：mat &#x3D; [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold &#x3D; 4输出：2解释：总和小于或等于 4 的正方形的最大边长为 2，如上图所示。\n\n\n\n代码class Solution &#123;  private int m, n;  public int maxSideLength(int[][] mat, int threshold) &#123;    m = mat.length;    n = mat[0].length;    // sum[i][j] -&gt; 以 (0,0) 为左上角，(i,j) 为右下角的矩形的元素和    int[][] sum = new int[m + 1][n + 1];    for (int i = 1; i &lt;= m; i++) &#123;      for (int j = 1; j &lt;= n; j++) &#123;        // 根据容斥原理，构造二维前缀和数组        sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + mat[i - 1][j - 1];      &#125;    &#125;    int left = 0, right = Math.min(m, n);    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(sum, threshold, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 是否存在以 side 为边长的正方形，其元素和不超过 threshold */  private boolean check(int[][] sum, int threshold, int side) &#123;    for (int i = side; i &lt;= m; i++) &#123;      for (int j = side; j &lt;= n; j++) &#123;        // 根据容斥原理，得到当前正方形的元素和        int cur = sum[i][j] - sum[i - side][j] - sum[i][j - side] + sum[i - side][j - side];        if (cur &lt;= threshold) &#123;          return true;        &#125;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\nLeetCode.1954 – 收集足够苹果的最小花园周长题面\n给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 abs(i) + abs(j) 个苹果。\n你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。\n给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。\n\n示例 1：\n\n\n输入：neededApples &#x3D; 1输出：8解释：边长长度为 1 的正方形不包含任何苹果。但是边长为 2 的正方形包含 12 个苹果（如上图所示）。周长为 2 * 4 &#x3D; 8 。\n\n\n\n代码class Solution &#123;  public long minimumPerimeter(long neededApples) &#123;    int left = 1, right = (int) 1e6;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(neededApples, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left * 8L;  &#125;  private boolean check(long neededApples, int len) &#123;    return len * (len + 1L) * (len + 1L) * 4L - 2L * len * (len + 1L) &gt;= neededApples;  &#125;&#125;\n\n\n\nLeetCode.1802 – 有界数组中指定下标处的最大值题面\n给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：\n\nnums.length &#x3D;&#x3D; n\nnums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n\nabs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1\nnums 中所有元素之和不超过 maxSum\nnums[index] 的值被 最大化\n\n返回你所构造的数组中的 nums[index] 。\n\n示例 1：\n\n输入：n &#x3D; 4, index &#x3D; 2,  maxSum &#x3D; 6输出：2解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n\n\n\n代码class Solution &#123;  public int maxValue(int n, int index, int maxSum) &#123;    int left = 1, right = maxSum;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(n, index, (long) maxSum, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断该数组总和是否可以不超过 maxSum ，其中下标 index 处的元素值被确定为 x */  private boolean check(int n, int index, long maxSum, int x) &#123;    // 为了尽可能使得数组总和不超过 maxSum ，所以它应该是长这样的：    // [1,1,2,3,...,x-2,x-1,x,x-1,x-2,...,3,2,1,1]    return getSum(x, index + 1) + getSum(x, n - index) - x &lt;= maxSum;  &#125;  private long getSum(int x, int len) &#123;    return x &gt;= len ? (2L * x - len + 1L) * len / 2L : (1L + x) * x / 2L + (len - x);  &#125;&#125;\n\n\n\n线性匹配[LeetCode.1898 – 可移除字符的最大数目](1898. 可移除字符的最大数目 - 力扣（LeetCode）)题面\n给你两个字符串 s 和 p ，其中 p 是 s 的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 removable ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。\n请你找出一个整数 k（0 &lt;&#x3D; k &lt;&#x3D; removable.length），选出 removable 中的 前 k 个下标，然后从 s 中移除这些下标对应的 k 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 0 &lt;&#x3D; i &lt; k ，先标记出位于 s[removable[i]] 的字符，接着移除所有标记过的字符，然后检查 p 是否仍然是 s 的一个子序列。\n返回你可以找出的 最大 k ，满足在移除字符后 p 仍然是 s 的一个子序列。\n字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。\n\n示例 1：\n\n输入：s &#x3D; “abcacb”, p &#x3D; “ab”, removable &#x3D; [3,1,0]输出：2解释：在移除下标 3 和 1 对应的字符后，”abcacb” 变成 “accb” 。“ab” 是 “accb” 的一个子序列。如果移除下标 3、1 和 0 对应的字符后，”abcacb” 变成 “ccb” ，那么 “ab” 就不再是 s 的一个子序列。因此，最大的 k 是 2 。\n\n\n\n代码class Solution &#123;  public int maximumRemovals(String s, String p, int[] removable) &#123;    int left = 0, right = removable.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(new String(s).toCharArray(), p, removable, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 能否在删除 len 个字符后，使得 p 是 s 的一个子序列 */  private boolean check(char[] s, String p, int[] removable, int len) &#123;    for (int i = 0; i &lt; len; i++) &#123;      s[removable[i]] = &#x27;#&#x27;;    &#125;    for (int i = 0, j = 0; i &lt; s.length; i++) &#123;      if (s[i] == p.charAt(j)) &#123;        j++;      &#125;      if (j == p.length()) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;\n\n\n\n隐式二分问题LeetCode.287 – 寻找重复数题面\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n\n示例 1：\n\n输入：nums &#x3D; [1,3,4,2,2]\n输出：2\n\n\n\n代码class Solution &#123;  public int findDuplicate(int[] nums) &#123;    // 第一个满足 小于等于 i 的元素个数超过了 i 个，那么 i 就是重复的数字    int left = 1, right = nums.length;    while (left &lt; right) &#123;      int middle = left + ((right - left) &gt;&gt; 1);      if (check(nums, middle)) &#123;        right = middle;      &#125; else &#123;        left = middle + 1;      &#125;    &#125;    return left;  &#125;  /** 判断小于等于 guess 的元素个数是否超过了 guess 个 */  private boolean check(int[] nums, int guess) &#123;    int count = 0;    for (int num : nums) &#123;      if (num &lt;= guess) &#123;        count++;      &#125;    &#125;    return count &gt; guess;  &#125;&#125;\n\n\n\nLeetCode.1648 – 销售价值减少的颜色球题面\n你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。\n这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）\n给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。\n请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。\n\n示例 1：\n\n\n输入：inventory &#x3D; [2,5], orders &#x3D; 4输出：14解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。最大总和为 2 + 5 + 4 + 3 &#x3D; 14 。\n\n\n\n代码//todo\n\n\n\nLeetCode.274 – H 指数题面\n给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。\n根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。\n如果 h 有多种可能的值，h 指数 是其中最大的那个。\n\n示例 1：\n\n输入：citations &#x3D; [3,0,6,1,5]输出：3解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n\n\n\n代码class Solution &#123;  public int hIndex(int[] citations) &#123;    int left = 0, right = citations.length;    while (left &lt; right) &#123;      int middle = left + ((right - left + 1) &gt;&gt; 1);      if (check(citations, middle)) &#123;        left = middle;      &#125; else &#123;        right = middle - 1;      &#125;    &#125;    return right;  &#125;  /** 判断是否有至少 h 篇论文被引用了至少 h 次 */  private boolean check(int[] citations, int h) &#123;    int count = 0;    for (int c : citations) &#123;      if (c &gt;= h) &#123;        count++;      &#125;    &#125;    return count &gt;= h;  &#125;&#125;","tags":["算法","二分查找"]}]