[{"title":"ã€ŒSpringã€ ä½ å·²ç»æ˜¯ä¸€ä¸ªæˆç†Ÿçš„æ¡†æ¶äº†ï¼Œåº”è¯¥å­¦ä¼šè‡ªå·±æ³¨å†Œç»„ä»¶ï¼","url":"/2022/01/19/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/","content":"åŸæ–‡é“¾æ¥ğŸ”—ï¼šå¾®ä¿¡å…¬ä¼—å· BugNotFoundException\n\n\næœ¬æ–‡å†…å®¹ï¼š\næ ¹æ®å¯¹äº Spring çš„æºç å­¦ä¹ ï¼Œå¯¹å…¶è¿›è¡Œæ”¹é€ ï¼Œå®ç°è‡ªåŠ¨å°†ç»„ä»¶æ³¨å†Œå…¥IOCå®¹å™¨ï¼ˆä¸ç”¨å†ä¸ºæ¯ä¸ªéœ€è¦æ³¨å†Œçš„ç±»æ‰‹å†™ @Component ã€ @Service ç­‰æ³¨è§£ï¼‰ï¼Œåªéœ€è¦å…³å¿ƒä¸šåŠ¡ä»£ç æœ¬èº«å³å¯ã€‚\n\n@Import@Import æ”¯æŒä¸‰ç§ä½¿ç”¨å§¿åŠ¿ï¼š\nå¸¦æœ‰ @Configuration çš„ JavaConfig é…ç½®ç±»è¿™ä¹Ÿæ˜¯å¹³æ—¶ä½¿ç”¨çš„æœ€å¤šçš„æ–¹å¼å°±æ˜¯ç¬¬ä¸€ç§äº†ï¼Œä¾‹å¦‚æœ‰ä¸€ä¸ªä¸»é…ç½®ç±» SpringConfiguration ï¼Œç°åœ¨è¿˜éœ€è¦å£°æ˜å¹¶æ³¨å†Œä¸€äº›æ•°æ®åº“ç›¸å…³çš„ç»„ä»¶Beanã€‚å½“ç„¶å¯ä»¥ç»§ç»­å†™åœ¨å½“å‰ä¸»é…ç½®ç±»ä¸­ï¼Œä½†æ˜¯ç»„ä»¶ä¸€æ—¦å˜å¾—å¤šèµ·æ¥ï¼Œæ—¥åæŸ¥æ‰¾å°±ç›¸å½“çƒ¦æ¼äº†ã€‚æ›´æ¸…æ™°çš„ä¸€ç§ç¼–å†™æ–¹å¼æ˜¯ï¼šå°†æ•°æ®åº“ç›¸å…³çš„å†…å®¹æ‹†åˆ†å‡ºå»ï¼Œä¾‹å¦‚æ–°å»ºä¸€ä¸ªç±» JdbcConfiguration ï¼Œç„¶åä¸»é…ç½®ç±»ä¸æ•°æ®åº“é…ç½®ç±»ä¹‹é—´å¯ä»¥é€šè¿‡ @Import è¿›è¡Œå¼•å…¥ã€‚\n\n\nå®ç° ImportSelector æ¥å£ï¼Œå¹¶è‡ªå®šä¹‰å…¶ä¸­çš„è§„åˆ™å¯ä»¥é€šè¿‡å®ç° ImportSelector æ¥å£å’Œ ImportBeanDefinitionRegistrar æ¥å£ï¼Œå¹¶åœ¨å…¶ä¸­è‡ªå®šä¹‰æˆ‘ä»¬è‡ªå·±æƒ³è¦çš„æ³¨å†Œè§„åˆ™ï¼Œå®ç°è‡ªåŠ¨æ‰¹é‡æ³¨å†Œç»„ä»¶ç­‰æ“ä½œã€‚\nè§‚å¯Ÿæ¥å£çš„æºç ï¼Œå‘ç°æœ‰ä¸€ä¸ªåä¸º selectImports çš„æ–¹æ³•éœ€è¦æˆ‘ä»¬å»å®ç°ã€‚\n\n\n\nå®ç°ç±»ä»£ç /** * è‡ªå®šä¹‰ ImportSelector * å®ç°åŠŸèƒ½ï¼šå°†ç»„ä»¶æ‰¹é‡æ³¨å†Œå…¥IOCå®¹å™¨ */public class CustomImportSelector implements ImportSelector &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJè¡¨è¾¾å¼ */  private final String expression;  /** ç”¨æˆ·æŒ‡å®šçš„æ‰«æåŒ… */  private final String customPackage;  /**   * é»˜è®¤çš„æ— å‚æ„é€ å‡½æ•°   * ç”¨äºè¯»å–é…ç½®æ–‡ä»¶ï¼Œå¹¶åˆå§‹åŒ–èµ‹å€¼å…¨å±€å˜é‡   */  public CustomImportSelector() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importSelector.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importSelector.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥&quot;);    &#125;  &#125;  /**   * å°†é…ç½®ç±»ä¸­çš„è¿‡æ»¤è§„åˆ™è®¾ç½®ä¸ºFilterType=ASPECTJï¼Œå¹¶é‡å†™è¯¥æ–¹æ³•   * å®ç°åŠŸèƒ½ï¼šå°†ç±»æ‰¹é‡æ³¨å†Œå…¥IOCå®¹å™¨   * @param importingClassMetadata   * @return   */  @Override  public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;    // å­˜å‚¨æ‰«æåŒ…çš„é›†åˆ    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // å¦‚æœå½“å‰ç±»å­˜åœ¨@ComponentScanæ³¨è§£ï¼Œåˆ™å–å‡ºå®ƒçš„basePackageså±æ€§å€¼ï¼Œå¹¶ä»¥æ­¤ä½œä¸ºæ‰«æåŒ…      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // å¦‚æœå­˜åœ¨ basePackages å±æ€§ï¼Œåˆ™å–å‡ºå…¶å±æ€§å€¼        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // å¦‚æœæœªæŒ‡å®š@ComponentScanæ³¨è§£ï¼Œæˆ–æŒ‡å®šäº†@ComponentScanä½†æ˜¯æœªæŒ‡å®šbasePackagesï¼Œé‚£ä¹ˆéƒ½éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨è®¾ç½®æ‰«æåŒ…      String basePackage;      try &#123;        // è·å–å½“å‰ç±»æ‰€åœ¨çš„åŒ…åï¼Œä»¥æ­¤ä½œä¸ºæ‰«æåŒ…        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackage().getName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;è·å–å½“å‰ç±»åŒ…åå¤±è´¥&quot;);      &#125;      // å°†åŒ…ååŠ å…¥é›†åˆä¸­      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // è‡³æ­¤ï¼ŒbasePackagesé›†åˆä¸­å¿…ä¸ä¸ºç©ºï¼Œä¸”å¿…å®šå­˜åœ¨å…ƒç´     if (!StringUtils.isEmpty(customPackage)) &#123;      // å¦‚æœç”¨æˆ·é…ç½®äº†è‡ªå®šä¹‰çš„æ‰«æåŒ…ï¼Œä¹Ÿéœ€è¦åŠ å…¥é›†åˆä¸­      basePackages.add(customPackage);    &#125;    // åˆ›å»ºä¸€ä¸ªç±»è·¯å¾„æ‰«æå™¨ä¸AspectJè¡¨è¾¾å¼è¿‡æ»¤å™¨ï¼Œå¹¶å°†å®ƒä»¬æ•´åˆèµ·æ¥    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportSelector.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    Set&lt;String&gt; classPaths = new HashSet&lt;&gt;();    for (String basePackage : basePackages) &#123;      scanner.findCandidateComponents(basePackage).forEach(beanDefinition -&gt; classPaths.add(beanDefinition.getBeanClassName()));    &#125;    return classPaths.toArray(new String[0]);  &#125;&#125;\n\n\n\nå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘åœ¨æ— å‚æ„é€ å‡½æ•°ä¸­ï¼Œæ˜¯é€šè¿‡è¯»å–é…ç½®æ–‡ä»¶æ¥è·å–ç”¨æˆ·æŒ‡å®šçš„æ‰«æåŒ…çš„ã€‚\né…ç½®æ–‡ä»¶# ImportSelector ç›¸å…³# AspectJè¡¨è¾¾å¼ï¼štwqåŒ…ä¸‹çš„ ä»»æ„å­åŒ…çš„ ä»»æ„ç±»custom.importSelector.expression=twq..*# åœ¨ä¸Šè¿°è§„åˆ™æˆç«‹çš„å‰æä¸‹ï¼Œç”¨æˆ·å¯ä»¥æŒ‡å®šå…·ä½“çš„æ‰«æåŒ…custom.importSelector.package=twq# ImportBeanDefinitionRegistrar ç›¸å…³custom.importBeanDefinitionRegistrar.expression=twq..*custom.importBeanDefinitionRegistrar.package=twq\n\nå¯¹åº”åˆ°æˆ‘çš„é¡¹ç›®çš„æ–‡ä»¶å¤¹è·¯å¾„ï¼Œæ˜¯è¿™æ ·çš„ï¼š\n\n    \n    \n    çº¢æ¡†éƒ¨åˆ†ï¼Œå°±æ˜¯æˆ‘é…ç½®æ–‡ä»¶ä¸­é…ç½®çš„æ‰«æåŒ…èŒƒå›´ï¼štwqåŒ…ï¼ˆåŒ…æ‹¬å­åŒ…ï¼‰ä¸‹çš„æ‰€æœ‰ç±»\n\n\n\n\næœ€åï¼Œåœ¨ä¸»é…ç½®ç±»ä¸Šå¼•å…¥ @Import(CustomImportBeanDefinitionRegistrar.class) å³å¯ã€‚\n@Configuration@Import(CustomImportSelector.class)public class SpringConfiguration &#123;&#125;\n\nå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘æ—¢æ²¡æœ‰åœ¨é…ç½®ç±»ä¸Šå†™ @ComponentScan ï¼Œä¹Ÿæ²¡æœ‰åœ¨ä»»ä½•ä¸šåŠ¡ç±»ä¸Šå†™ä¾‹å¦‚ @Component ã€ @Service ç­‰æ³¨è§£ã€‚\n\n\næµ‹è¯•ç»“æœç°åœ¨è®©æˆ‘ä»¬å»æµ‹è¯•ä¸€ä¸‹ï¼Œçœ‹çœ‹æ˜¯å¦å¯ä»¥åŒæ ·è¾¾åˆ°ç»„ä»¶æ³¨å†Œçš„æ•ˆæœã€‚\n\n    \n    \n    å¯ä»¥çœ‹åˆ°ï¼Œè¿™äº›ç»„ä»¶éƒ½è¢«æˆåŠŸæ³¨å†Œï¼Œè°ƒç”¨æ–¹æ³•ä¹Ÿæ­£å¸¸æ‰§è¡Œ\n\n\n\n    \n    \n    å¦å¤–ï¼Œé€šè¿‡è¾“å‡ºå½“å‰IOCå®¹å™¨ç»„ä»¶åå¯çŸ¥ï¼šè‡ªåŠ¨ä¸ºå®ƒä»¬åˆ†é…çš„idæ˜¯å„è‡ªçš„å…¨é™å®šåã€‚\n\n\n\n\nå®ç° ImportBeanDefinitionRegistrar æ¥å£ï¼Œå¹¶è‡ªå®šä¹‰å…¶ä¸­çš„è§„åˆ™æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ ImportBeanDefinitionRegistrar æ¥å£çš„å®ç°å§¿åŠ¿ã€‚å…¶å®å®ƒä¸ ImportSelector çš„å®ç°æ€è·¯åŸºæœ¬ä¸€è‡´ã€‚\nå®ç°ç±»ä»£ç /** * è‡ªå®šä¹‰ ImportBeanDefinitionRegistrar * å®ç°åŠŸèƒ½ï¼šå°†ç»„ä»¶æ‰¹é‡æ³¨å†Œå…¥IOCå®¹å™¨ */public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    private static final String BASE_PACKAGES = &quot;basePackages&quot;;  /** AspectJè¡¨è¾¾å¼ */  private final String expression;  /** ç”¨æˆ·æŒ‡å®šçš„æ‰«æåŒ… */  private final String customPackage;  /**   * é»˜è®¤çš„æ— å‚æ„é€ å‡½æ•°   * ç”¨äºè¯»å–é…ç½®æ–‡ä»¶ï¼Œå¹¶ç»™ä¸€äº›å…¨å±€å˜é‡èµ‹å€¼   */  public CustomImportBeanDefinitionRegistrar() &#123;    try &#123;      Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;customImport.properties&quot;);      expression = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.expression&quot;);      customPackage = properties.getProperty(&quot;custom.importBeanDefinitionRegistrar.package&quot;);    &#125; catch (IOException e) &#123;      throw new RuntimeException(&quot;è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥&quot;);    &#125;  &#125;  /**   * å°†é…ç½®ç±»ä¸­çš„è¿‡æ»¤è§„åˆ™è®¾ç½®ä¸ºFilterType=ASPECTJï¼Œå¹¶é‡å†™è¯¥æ–¹æ³•   * å®ç°åŠŸèƒ½ï¼šé€šè¿‡æŒ‡å®šæ‰«æåŒ…ï¼Œè‡ªåŠ¨å°†ç»„ä»¶æ³¨å†Œå…¥IOCå®¹å™¨   * @param importingClassMetadata   * @param registry   */  @Override  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    List&lt;String&gt; basePackages = null;    if (importingClassMetadata.hasAnnotation(ComponentScan.class.getName())) &#123;      // å¦‚æœå½“å‰ç±»å­˜åœ¨@ComponentScanæ³¨è§£ï¼Œåˆ™å–å‡ºå®ƒçš„basePackageså±æ€§å€¼ï¼Œå¹¶ä»¥æ­¤ä½œä¸ºæ‰«æåŒ…      Map&lt;String, Object&gt; attributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());      if (attributes.containsKey(BASE_PACKAGES)) &#123;        // å¦‚æœå­˜åœ¨ basePackages å±æ€§ï¼Œåˆ™å–å‡ºå…¶å±æ€§å€¼        basePackages = new ArrayList&lt;&gt;();        Collections.addAll(basePackages, (String[]) attributes.get(BASE_PACKAGES));      &#125;    &#125;    if (basePackages == null || basePackages.isEmpty()) &#123;      // å¦‚æœæœªæŒ‡å®š@ComponentScanæ³¨è§£ï¼Œæˆ–æŒ‡å®šäº†@ComponentScanä½†æ˜¯æœªæŒ‡å®šbasePackagesï¼Œé‚£ä¹ˆéƒ½éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨è®¾ç½®æ‰«æåŒ…      String basePackage;      try &#123;        // è·å–å½“å‰ç±»æ‰€åœ¨çš„åŒ…åï¼Œä»¥æ­¤ä½œä¸ºæ‰«æåŒ…        basePackage = Class.forName(importingClassMetadata.getClassName()).getPackageName();      &#125; catch (ClassNotFoundException e) &#123;        throw new RuntimeException(&quot;è·å–å½“å‰ç±»åŒ…åå¤±è´¥&quot;);      &#125;      // å°†åŒ…ååŠ å…¥é›†åˆä¸­      if (basePackages == null) &#123;        basePackages = new ArrayList&lt;&gt;();      &#125;      basePackages.add(basePackage);    &#125;    // è‡³æ­¤ï¼ŒbasePackagesé›†åˆä¸­å¿…ä¸ä¸ºç©ºï¼Œä¸”å¿…å®šå­˜åœ¨å…ƒç´     if (!StringUtils.isEmpty(customPackage)) &#123;      // å¦‚æœç”¨æˆ·é…ç½®äº†è‡ªå®šä¹‰çš„æ‰«æåŒ…ï¼Œä¹Ÿéœ€è¦åŠ å…¥é›†åˆä¸­      basePackages.add(customPackage);    &#125;    // åˆ›å»ºä¸€ä¸ªç±»è·¯å¾„æ‰«æå™¨ä¸AspectJè¡¨è¾¾å¼è¿‡æ»¤å™¨ï¼Œå¹¶å°†å®ƒä»¬æ•´åˆèµ·æ¥    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);    TypeFilter typeFilter = new AspectJTypeFilter(expression, CustomImportBeanDefinitionRegistrar.class.getClassLoader());    scanner.addIncludeFilter(typeFilter);    // æ‰«æé›†åˆä¸­çš„è¿™äº›åŒ…    scanner.scan(basePackages.toArray(new String[0]));  &#125;&#125;\n\n\né…ç½®ç±»ä»£ç @Configuration@Import(CustomImportBeanDefinitionRegistrar.class)public class SpringConfiguration &#123;&#125;\n\n\næµ‹è¯•ç»“æœ\n\nè¿™é‡Œè¦è¯´æ˜ä¸€ä¸‹ï¼šè™½ç„¶åœ¨ä¸Šé¢çš„å›¾ç‰‡ä¸­ï¼Œçœ‹åˆ°ç›¸å…³æ³¨è§£çš„å±æ€§çˆ†çº¢äº†ï¼šideaè¡¨ç¤ºæ— æ³•è§£æè¿™ä¸ªbean nameã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰å†™ä»»ä½• @Component ï¼Œidea è¿˜ä»¥ä¸ºä¸å­˜åœ¨è¿™äº›ç»„ä»¶ã€‚ä½†å…¶å®æˆ‘ä»¬å·²ç»é€šè¿‡ ImportBeanDefinitionRegistrar æ¥å£å¸®æˆ‘ä»¬è¿›è¡Œç»„ä»¶æ³¨å†Œäº†ï¼Œæ‰€ä»¥æµ‹è¯•ç»“æœæ˜¯æ²¡é—®é¢˜çš„~~ :laughing:\n\n\næ€»ç»“ï¼š\nImportSelector è‡ªåŠ¨æ³¨å†Œæ—¶ï¼Œåˆ†é…çš„ç»„ä»¶åè§„åˆ™æ˜¯ï¼šå„è‡ªç±»çš„å…¨é™å®šå ã€‚\n\nImportBeanDefinitionRegistrar è‡ªåŠ¨æ³¨å†Œæ—¶ï¼Œåˆ†é…çš„ç»„ä»¶åè§„åˆ™æ˜¯ï¼šå„è‡ªç±»çš„ç±»çŸ­å+é¦–å­—æ¯å°å†™çš„æ³¨å…¥æ–¹å¼ ã€‚\n\n\n","tags":["Java","Spring"]},{"title":"ã€ŒSpringã€ ä½ å·²ç»æ˜¯ä¸€ä¸ªæˆç†Ÿçš„æ¡†æ¶äº†ï¼Œåº”è¯¥å­¦ä¼šè‡ªå·±è¯»å–yamlæ–‡ä»¶ï¼","url":"/2022/01/30/%E3%80%8CSpring%E3%80%8D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%90%E7%86%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BA%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%AD%A6%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%AF%BB%E5%8F%96yaml%E6%96%87%E4%BB%B6/","content":"åŸæ–‡é“¾æ¥ğŸ”—ï¼šå¾®ä¿¡å…¬ä¼—å· BugNotFoundException\n\n\næœ¬æ–‡å†…å®¹ï¼š\næ ¹æ®å¯¹äº Spring çš„æºç å­¦ä¹ ï¼Œå¯¹å…¶è¿›è¡Œæ”¹é€ ï¼Œé€šè¿‡å®ç° PropertySourceFactory æ¥å£ï¼Œä½¿Springå¯ä»¥è¯»å– yaml æ ¼å¼çš„é…ç½®æ–‡ä»¶ã€‚\n\n@PropertySourceæˆ‘ä»¬çŸ¥é“ï¼Œ@PropertySourceé»˜è®¤æ”¯æŒè¯»å–çš„æ˜¯ .properties å’Œ .xml æ ¼å¼çš„é…ç½®æ–‡ä»¶ã€‚\nä¸è¿‡å°±ç›®å‰è€Œè¨€ï¼Œæ›´å—æ¬¢è¿ä¸”ä¸»æµçš„é…ç½®æ–‡ä»¶æ ¼å¼æ˜¯ .yml ã€‚ä½†å¾ˆé—æ†¾çš„æ˜¯ï¼ŒSpringåŸç”Ÿå¹¶ä¸æ”¯æŒã€‚\né‚£ä¹ˆï¼Œåªå¥½è‡ªå·±åŠ¨æ‰‹ä¸°è¡£è¶³é£Ÿå§~ :thinking:\næ‰€ä»¥æ¥ä¸‹æ¥å°±è‡ªå·±å®ç°ä¸€ä¸ªå¯æ”¯æŒ .yml æ ¼å¼çš„ @PropertySource ~\n\n\næºç åˆ†æé¦–å…ˆç‚¹è¿›æ¥è¿™ä¸ª @PropertySource åˆ†æä¸€ç•ªã€‚å¯ä»¥çœ‹åˆ°è¿™é‡Œéœ€è¦çš„æ˜¯ä¸€ä¸ªè§£æå™¨å·¥å‚ç±»ï¼Œæ¥å£ä¸º PropertySourceFactory ï¼Œè€Œæ¡†æ¶æä¾›çš„é»˜è®¤å®ç°ç±»æ˜¯ DefaultPropertySourceFactory ã€‚\n\n\n\né‚£ä¹ˆæˆ‘ä»¬å°±ç…§çŒ«ç”»è™ï¼Œå®ç°ä¸€ä¸ªè‡ªå·±çš„ `CustomPropertySourceFactory` ã€‚\n\n\n\nå®ç°å®ç°æ€è·¯å°±æ˜¯ï¼šå°† yaml æ–‡ä»¶è§£æå¹¶è½¬ä¸º properties æ–‡ä»¶ï¼Œç„¶åå†äº¤ç”±Springå»è¯»å–ã€‚\nè¿™é‡Œæˆ‘é€‰æ‹©å¯¼å…¥ç¬¬ä¸‰æ–¹ä¾èµ– snakeyaml ï¼Œä»¥å¸®åŠ©æˆ‘ä»¬è§£æ yaml æ–‡ä»¶å¹¶è½¬ä¸º properties æ–‡ä»¶ã€‚\nå®ç°ç±»ä»£ç /** * è‡ªå®šä¹‰ PropertySourceFactory * å®ç°åŠŸèƒ½ï¼šå…è®¸è¯»å–ymlæ ¼å¼çš„é…ç½®æ–‡ä»¶ */public class CustomPropertySourceFactory implements PropertySourceFactory &#123;  @Override  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;    // åˆ›å»ºä¸€ä¸ªyamlæ–‡ä»¶è§£æå·¥å‚    YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();    factoryBean.setResources(resource.getResource());    // å°†ä¼ å…¥çš„èµ„æºè§£æä¸º properties æ–‡ä»¶ã€‚è¿™æ ·ï¼Œspringå°±æ”¯æŒè¯»å–äº†    Properties properties = factoryBean.getObject();    return name == null ? new PropertiesPropertySource(resource.getResource().getFilename(), properties)        : new PropertiesPropertySource(name, properties);  &#125;&#125;\n\nè‡³æ­¤ï¼Œå°±å¯ä»¥æ„‰å¿«åœ°å°†é…ç½®æ–‡ä»¶æ”¹ä¸º .yml æ ¼å¼çš„å•¦ã€‚ä½†æ˜¯åˆ«å¿˜äº†å°† @PropertySource çš„ factory å±æ€§æŒ‡å‘è‡ªå·±è‡ªå®šä¹‰çš„å·¥å‚è§£æç±»å“¦~\n\n\né…ç½®ç±»ä»£ç @Configuration@PropertySource(value = &quot;classpath:jdbc.yml&quot;, factory = CustomPropertySourceFactory.class)public class JdbcConfiguration &#123;  @Value(&quot;$&#123;jdbc.windows.driverClassName&#125;&quot;) private String driver;  @Value(&quot;$&#123;jdbc.windows.url&#125;&quot;) private String url;  @Value(&quot;$&#123;jdbc.windows.username&#125;&quot;) private String username;  @Value(&quot;$&#123;jdbc.windows.password&#125;&quot;) private String password;  @Bean(name = &quot;dataSource&quot;)  public DataSource dataSource() &#123;    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(driver);    dataSource.setUrl(url);    dataSource.setUsername(username);    dataSource.setPassword(password);    return dataSource;  &#125;&#125;","tags":["Java","Spring"]},{"title":"ã€ŒåŠ¨æ€è§„åˆ’ã€è‚¡ç¥å…»æˆè®°","url":"/2022/02/27/%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E3%80%8D%E8%82%A1%E7%A5%9E%E5%85%BB%E6%88%90%E8%AE%B0/","content":"åŸæ–‡é“¾æ¥ğŸ”—ï¼šå¾®ä¿¡å…¬ä¼—å· BugNotFoundException\n\n\nè‚¡ç¥¨é—®é¢˜ç³»åˆ— æ˜¯åŠ¨æ€è§„åˆ’å…¥é—¨çš„ç»å…¸ç³»åˆ—äº†ã€‚\næœ¬æ–‡å°†æ”¶å½• LeetCode ä¸Šçš„æ‰€æœ‰ç›¸å…³é—®é¢˜ï¼Œä»¥æ­¤æ€»ç»“è‚¡ç¥¨å¸‚åœºçš„æ“ä½œç»éªŒã€‚\n\né¢˜ç›®1 â€“ LeetCode.121é¢˜é¢\nç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ä½ åªèƒ½é€‰æ‹© æŸä¸€å¤© ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­ å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚\n\nç¤ºä¾‹1ï¼š\n\nè¾“å…¥ï¼š[7,1,5,3,6,4]è¾“å‡ºï¼š5è§£é‡Šï¼šåœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 6ï¼‰çš„æ—¶å€™å–å‡ºã€‚\n\nç¤ºä¾‹2ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [7,6,4,3,1]è¾“å‡ºï¼š0è§£é‡Šï¼šåœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆã€‚\n\n\n\nåˆ†ææœ¬é¢˜çš„è¦ç‚¹ï¼šæœ€å¤šå…è®¸ä¸€æ¬¡äº¤æ˜“ï¼ˆä¹°å…¥+å–å‡ºï¼‰ã€‚è€Œæ•°ç»„æœ¬èº«çš„é•¿åº¦ï¼Œæ»¡è¶³ prices.length&gt;=1 ï¼Œå³ï¼šä½ æƒ³åœ¨å“ªä¸ªç‚¹ä½ä¹°å…¥ï¼Œéšæ„ä»»å›æŒ‘é€‰~å¹¶ä¸”ï¼Œä½ ä¸ç”¨è€ƒè™‘å½“å‰äº¤æ˜“ä¼šå¯¹ä¸‹æ¬¡äº¤æ˜“äº§ç”Ÿå½±å“ï¼ˆå› ä¸ºåªæœ‰ä¸€æ¬¡äº¤æ˜“ï¼Œä¸å­˜åœ¨ä¸‹ä¸€æ¬¡ï¼‰ã€‚\næ‰€ä»¥ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä¸è€ƒè™‘dpæ€æƒ³ï¼Œé€€åŒ–ä¸ºæœ€naiveçš„è´ªå¿ƒç­–ç•¥ï¼šé€‰æ‹©ä¸€ä¸ªä»·æ ¼å·®æœ€å¤§çš„äº¤æ˜“å³å¯ã€‚\n\n\nä»£ç class Solution &#123;  public int maxProfit(int[] prices) &#123;    int min = prices[0], ans = 0;    for (int price : prices) &#123;      min = Math.min(min, price);      ans = Math.max(ans, price - min);    &#125;    return ans;  &#125;&#125;\n\n\n\né¢˜ç›®2 â€“ LeetCode.122é¢˜é¢\nç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ å¯ä»¥ å°½å¯èƒ½åœ° å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰ã€‚è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚\n\nç¤ºä¾‹1ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [7,1,5,3,6,4]è¾“å‡ºï¼š7\n\nç¤ºä¾‹2ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [1,2,3,4,5]è¾“å‡ºï¼š4\n\n\n\nåˆ†ææœ¬é¢˜çš„è¦ç‚¹ï¼šå…è®¸ä»»æ„å¤šæ¬¡äº¤æ˜“ï¼ˆä¹°å…¥+å–å‡ºï¼‰ã€‚é™¤äº†ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼Œæ²¡æœ‰ä»»ä½•å…¶ä»–é™åˆ¶æ¡ä»¶ã€‚\nè¿™ç§æƒ…å†µä¸‹ï¼Œä¹Ÿå®Œå…¨å¯ä»¥å°†é—®é¢˜ é€€åŒ–ä¸ºè´ªå¿ƒç­–ç•¥ï¼šåªè¦ä»Šå¤©ä»·æ ¼æ¯”æ˜¨å¤©é«˜ï¼Œé‚£ä¹ˆæˆ‘å°±è®¤ä¸ºæ˜¨å¤©å·²ä¹°å…¥ï¼Œç„¶ååœ¨ä»Šå¤©å–å‡ºã€‚\nä¸ºä»€ä¹ˆè¿™ä¸ªç­–ç•¥æ˜¯æ­£ç¡®çš„ï¼Ÿä¸‡ä¸€æ˜å¤©æ›´é«˜ï¼Œä½†æ˜¯æˆ‘ä»Šå¤©å°±å–å‡ºäº†ï¼Œå²‚ä¸æ˜¯å–æ—©äº†å˜›ï¼Ÿï¼Ÿ\nå…¶å®å¹¶ä¸ä¼šã€‚å¯ä»¥çœ‹ ç¤ºä¾‹2 ï¼Œä½ ä¼šå‘ç°ï¼šå³ä½¿æˆ‘åœ¨1å—é’±ä¹°å…¥ã€2å—é’±å–å‡ºï¼›ç„¶åæˆ‘å¯ä»¥åœ¨2å—é’±åˆä¹°å…¥ã€3å—é’±å†å–å‡ºï¼›ç„¶åå†æ˜¯3å—é’±ä¹°å…¥ã€4å—é’±å–å‡ºâ€¦â€¦æ€»ä¹‹ï¼Œæˆ‘æœ€åä¾ç„¶å¯ä»¥èµšå–4å…ƒçš„åˆ©æ¶¦ï¼Œä¸ä¼šå°‘çš„ã€‚å—¯ï¼Œæœ¬è´¨æ˜¯å«æˆ‘ä»¬å»åšçŸ­çº¿é«˜æ‰‹ã€‚æ‡‚äº†ï¼Œå­¦ä¼šè¿™ä¸ªæ“ä½œæ€è·¯ï¼Œè‚¡ç¥å°±æ˜¯åœ¨ä¸‹äº†ã€‚å®é™…ï¼šæ­»äºåšt\n\n\nä»£ç class Solution &#123;  public int maxProfit(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;\n\n\n\né¢˜ç›®3 â€“ LeetCode.309ï¼šé¢˜é¢\nç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰:\n\nä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚\nå–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚\n\n\nç¤ºä¾‹1ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [1,2,3,0,2]è¾“å‡ºï¼š3\n\n\n\nåˆ†ææœ¬é¢˜çš„è¦ç‚¹ï¼šå…è®¸ä»»æ„å¤šæ¬¡äº¤æ˜“ï¼ˆä¹°å…¥+å–å‡ºï¼‰ï¼Œä½†é™¤äº†ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ä»¥å¤–ï¼Œæ¯ä¸¤ç¬”äº¤æ˜“ä¹‹é—´è¿˜å­˜åœ¨ä¸€å¤©çš„å†·å†»æœŸã€‚\nè¿™ç§æƒ…å†µä¸‹ï¼Œè´ªå¿ƒç­–ç•¥å°±ä¸å†å¥½ä½¿äº†ã€‚å› ä¸ºï¼Œä½ å¿…é¡»è€ƒè™‘åˆ°ï¼šå½“å‰çš„äº¤æ˜“ä¼šä½¿å¾—æ˜å¤©æ— æ³•äº¤æ˜“ï¼Œæ‰€ä»¥â€œæ— è„‘çŸ­çº¿â€å¹¶ä¸è§å¾—ä¸€å®šæ­£ç¡®ã€‚ ä»æ­¤å¼€å§‹ï¼Œdpç­–ç•¥æ­£å¼äº®ç›¸~\n\n\nä»£ç class Solution &#123;  public int maxProfit(int[] prices) &#123;    int n = prices.length;    // dp1[i] -&gt; ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ—¶ï¼Œå¯è·å¾—çš„æœ€å¤§åˆ©æ¶¦    // dp2[i] -&gt; ç¬¬iå¤©æœªæŒæœ‰è‚¡ç¥¨ä¸”æœªå¤„äºå†·å†»æœŸï¼Œå¯è·å¾—çš„æœ€å¤§åˆ©æ¶¦    // dp3[i] -&gt; ç¬¬iå¤©æœªæŒæœ‰è‚¡ç¥¨ä¸”å¤„äºå†·å†»æœŸï¼Œå¯è·å¾—çš„æœ€å¤§åˆ©æ¶¦    int[] dp1 = new int[n], dp2 = new int[n], dp3 = new int[n];    dp1[0] = -prices[0];    for (int i = 1; i &lt; n; i++) &#123;      dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);      dp2[i] = Math.max(dp2[i - 1], dp3[i - 1]);      dp3[i] = dp1[i - 1] + prices[i];    &#125;    return Math.max(dp2[n - 1], dp3[n - 1]);  &#125;&#125;\n\n\n\né¢˜ç›®4 â€“ LeetCode.123ï¼šé¢˜é¢\nç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ ä¸¤ç¬” äº¤æ˜“ã€‚æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚\n\nç¤ºä¾‹1ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [3,3,5,0,0,3,1,4]è¾“å‡ºï¼š6\n\nç¤ºä¾‹2ï¼š\n\nè¾“å…¥ï¼šprices &#x3D; [1,2,3,4,5]è¾“å‡ºï¼š4\n\n\n\nåˆ†ææœ¬é¢˜çš„è¦ç‚¹ï¼šæœ€å¤šå…è®¸ä¸¤æ¬¡äº¤æ˜“ï¼ˆä¹°å…¥+å–å‡ºï¼‰ï¼Œå¹¶ä¸”ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ã€‚\nè¿™ç§æƒ…å†µä¸‹ï¼Œè´ªå¿ƒç­–ç•¥ä¹Ÿä¸å†å¥½ä½¿äº†ã€‚åŸå› ä¹Ÿå¾ˆå®¹æ˜“ç†è§£ï¼šä¸€å…±åªæœ‰ä¸¤æ¬¡äº¤æ˜“æœºä¼šï¼Œä½ å¿…é¡»é€‰æ‹©åˆ©æ¶¦æœ€å¤§çš„ä¸¤ç¬”ï¼Œè€Œä¸æ˜¯â€œä¸€é«˜å°±å–â€ï¼Œéšæ„æŒ¥éœæœºä¼šã€‚\n\n\nä»£ç class Solution &#123;  public int maxProfit(int[] prices) &#123;   /**   * åœ¨ä»»æ„ä¸€å¤©ç»“æŸåï¼Œä¼šå¤„äºä»¥ä¸‹äº”ç§çŠ¶æ€ä¸­çš„ä¸€ç§ï¼š   * æœªè¿›è¡Œè¿‡ä»»ä½•æ“ä½œï¼Œæœ€å¤§åˆ©æ¶¦æ°¸è¿œæ˜¯0   * åªè¿›è¡Œè¿‡ä¸€æ¬¡ä¹°å…¥æ“ä½œï¼Œæœ€å¤§åˆ©æ¶¦ä»¥buy1è¡¨ç¤ºï¼›   * è¿›è¡Œè¿‡ä¸€æ¬¡ä¹°å…¥ã€ä¸€æ¬¡å–å‡ºæ“ä½œï¼Œæœ€å¤§åˆ©æ¶¦ä»¥sell1è¡¨ç¤ºï¼›   * è¿›è¡Œè¿‡ä¸¤æ¬¡ä¹°å…¥ã€ä¸€æ¬¡å–å‡ºæ“ä½œï¼Œæœ€å¤§åˆ©æ¶¦ä»¥buy2è¡¨ç¤ºï¼›   * è¿›è¡Œè¿‡ä¸¤æ¬¡ä¹°å…¥ã€ä¸¤æ¬¡å–å‡ºæ“ä½œï¼Œæœ€å¤§åˆ©æ¶¦ä»¥sell2è¡¨ç¤ºã€‚   */   int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;   for (int i = 1, n = prices.length; i &lt; n; i++) &#123;     buy1 = Math.max(buy1, -prices[i]);     sell1 = Math.max(sell1, buy1 + prices[i]);     buy2 = Math.max(buy2, sell1 - prices[i]);     sell2 = Math.max(sell2, buy2 + prices[i]);   &#125;   return sell2;  &#125;&#125;\n\n\n\né¢˜ç›®5 â€“ LeetCode.188ï¼šé¢˜é¢\nç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ k ç¬”äº¤æ˜“ã€‚æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚\n\nç¤ºä¾‹1ï¼š\n\nè¾“å…¥ï¼šk &#x3D; 2, prices &#x3D; [2,4,1]è¾“å‡ºï¼š2\n\nç¤ºä¾‹2ï¼š\n\nè¾“å…¥ï¼šk &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]è¾“å‡ºï¼š7\n\n\n\nåˆ†ææœ¬é¢˜ä¸ä¹‹å‰çš„ä¸åŒä¹‹å¤„åœ¨äºï¼šæœ€å¤šå…è®¸ ä¸¤æ¬¡ äº¤æ˜“ï¼ˆä¹°å…¥+å–å‡ºï¼‰ï¼Œå¹¶ä¸”ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ã€‚\næœ¬é¢˜å®è´¨ä¸Šï¼Œå°±æ˜¯ é¢˜ç›®4 â€“ LeetCode.123 çš„æ‰©å±•ç‰ˆæœ¬ï¼šç¡¬ç¼–ç  2 æ¬¡æœºä¼š --&gt;  ä»»æ„ç»™å®šçš„ k æ¬¡æœºä¼šã€‚\nåŒæ ·åœ°ï¼Œè¿™é‡Œä¹Ÿç†åº”æ— æ³•ä½¿ç”¨è´ªå¿ƒç­–ç•¥ã€‚\nä½†äº‹å®ä¸Šï¼Œç”±äº k çš„èŒƒå›´æ˜¯ä»»æ„çš„ï¼Œæ‰€ä»¥æƒ…å†µä¹Ÿä¸å®Œå…¨æ˜¯è¿™æ ·ã€‚ä¾‹å¦‚ï¼šk=9999999ï¼ˆæ­¤å¤„è‡ªè¡Œè„‘è¡¥ä¸€äº¿ä¸ª9â€¦ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è®¤ä¸º k æ˜¯æ— é™å¤§çš„ï¼Œæ­¤æ—¶äº¤æ˜“æ¬¡æ•°è§†ä¸ºï¼šä¸å—é™ã€‚\näº‹å®ä¸Šï¼Œåªè¦æœ‰ k &gt;= prices.length / 2 ï¼Œæ­¤æ—¶å°±å¯ä»¥ æ— è§†æ¬¡æ•°é™åˆ¶äº†ï¼Œå› ä¸ºä½ ä¸€å®šæ¥ä¸åŠç”¨å®Œæ‰€æœ‰çš„äº¤æ˜“æœºä¼šï¼å¦‚æœæ²¡æœ‰äº¤æ˜“æ¬¡æ•°é™åˆ¶ï¼Œé‚£ä¹ˆé—®é¢˜åˆå¯ä»¥é€€åŒ–ä¸ºâ€œè´ªå¿ƒç­–ç•¥â€äº†ã€‚ äºæ˜¯é—®é¢˜åˆå˜æˆäº† é¢˜ç›®2 â€“ LeetCode.122 ã€‚\né™¤æ­¤ä»¥å¤–ï¼Œæ™®éæƒ…å†µä¸‹è¿˜æ˜¯éœ€è¦ä½¿ç”¨ dpç­–ç•¥ ã€‚\n\n\nä»£ç class Solution &#123;  public int maxProfit(int k, int[] prices) &#123;    if (prices.length &lt; 2 || k == 0) &#123;      return 0;    &#125;    // å½“å¯æ“ä½œæ¬¡æ•°ä¸å°‘äºæ•°ç»„çš„ä¸€åŠé•¿åº¦æ—¶ï¼Œé—®é¢˜å¯ä»¥é€€åŒ–ä¸ºâ€œè´ªå¿ƒç­–ç•¥â€    if (k &gt;= (prices.length &gt;&gt; 1)) &#123;      return greedy(prices);    &#125;    // dp[i][0] -&gt; å®Œæˆiæ¬¡ä¹°å…¥åï¼Œå¯è·å¾—çš„æœ€å¤§åˆ©æ¶¦    // dp[i][1] -&gt; å®Œæˆiæ¬¡å–å‡ºåï¼Œå¯è·å¾—çš„æœ€å¤§åˆ©æ¶¦    int[][] dp = new int[k][2];    for (int i = 0; i &lt; k; i++) &#123;      dp[i][0] = -prices[0];    &#125;    for (int price : prices) &#123;      dp[0][0] = Math.max(dp[0][0], -price);      dp[0][1] = Math.max(dp[0][1], dp[0][0] + price);      for (int i = 1; i &lt; k; i++) &#123;        dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - price);        dp[i][1] = Math.max(dp[i][1], dp[i][0] + price);      &#125;    &#125;    return dp[k - 1][1];  &#125;  private int greedy(int[] prices) &#123;    int cost = prices[0], ans = 0;    for (int price : prices) &#123;      ans += Math.max(price - cost, 0);      cost = price;    &#125;    return ans;  &#125;&#125;","tags":["ç®—æ³•","åŠ¨æ€è§„åˆ’"]},{"title":"ã€Œæ ‘ã€æ ¹æ®ç»™å®šçš„å‰/ä¸­/ååºéå†ï¼Œä»¥æ¢å¤äºŒå‰æ ‘","url":"/2022/03/12/%E3%80%8C%E6%A0%91%E3%80%8D%E6%A0%B9%E6%8D%AE%E7%BB%99%E5%AE%9A%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"ä»Šå¤©æ¥è®°å½•ä¸¤é“ç»å…¸äºŒå‰æ ‘çš„é—®é¢˜ï¼š\n\nLeetCode.105 â€“ ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘\n\nLeetCode.106 â€“ ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘\n\n\n\né¦–å…ˆï¼Œä¸ºäº†æ„å»ºå‡ºè¿™æ£µäºŒå‰æ ‘ï¼Œæˆ‘ä»¬è‚¯å®šæ˜¯è‡ªé¡¶å‘ä¸‹ï¼Œä» ä½äºé¡¶ç«¯çš„æ ‘æ ¹èŠ‚ç‚¹ å‡ºå‘ï¼Œåœ¨æ¯ä¸ªæ­£ç¡®çš„ä½ç½®æ„é€ å‡ºæ­£ç¡®çš„èŠ‚ç‚¹ã€‚åœ¨æ¯æ¬¡å¤„ç†ä¸­ï¼Œæˆ‘ä»¬åªå…³æ³¨å¦‚ä½• æ„é€ å‡ºå½“å‰èŠ‚ç‚¹ ã€‚\nè€Œè¿™ä¸ª èŠ‚ç‚¹ ï¼š\n\nå¯¹äº å…ˆåºéå† ï¼Œå°±æ˜¯ ç¬¬ä¸€ä¸ª å…ƒç´  preorder[preLeft] ï¼›\n\nå¯¹äº ååºéå† ï¼Œå°±æ˜¯ æœ€åä¸€ä¸ª å…ƒç´  postorder[postRight]\n\n\nç°åœ¨ï¼Œè¿™ä¸ªæ ¹èŠ‚ç‚¹çš„ val å±æ€§å·²ç»ç¡®å®šäº†ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ å‡ºå½“å‰èŠ‚ç‚¹ï¼š TreeNode root = new TreeNode(val);\nä½†æ˜¯å…¶ left å’Œ right å±æ€§éƒ½æ˜¯ä¸ç¡®å®šçš„ï¼Œå®ƒä»¬ä½œä¸ºå­èŠ‚ç‚¹ï¼Œæ­¤æ—¶å¹¶ä¸å­˜åœ¨ã€‚éœ€è¦åœ¨ä¹‹åçš„å¤„ç†ä¸­å°†å®ƒä»¬æ„é€ å‡ºæ¥ (ä¹Ÿå°±æ˜¯é€’å½’è°ƒç”¨) ï¼š \nroot.left = buildTree();root.right = buildTree();\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å¼€å§‹åˆ©ç”¨ ä¸­åºéå†çš„æ€§è´¨ã€‚æ®å‰æ‰€è¿°ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ® å…ˆåºéå† (or ååºéå†) å¾—åˆ°å½“å‰çš„æ ¹èŠ‚ç‚¹ã€‚é‚£ä¹ˆï¼Œå®ƒåœ¨ ä¸­åºéå† ä¸­çš„ä½ç½®ï¼Œå…¶å®å°†æ•´æ£µæ ‘åˆ†ä¸ºäº†ä¸¤åŠã€‚\næˆ‘ä»¬å‡å®š è¯¥æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†ä¸­çš„ä½ç½® æ˜¯ rootIdx ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯çŸ¥ å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•° leftSize = rootIdx - inLeft ï¼Œç”±æ­¤å¯å¾—åˆ°å·¦å³å­æ ‘çš„åŒºé—´èŒƒå›´ï¼š\n\nå·¦å­æ ‘ï¼š\nå…ˆåºéå†ï¼š [preLeft + 1, preLeft + leftSize]\nä¸­åºéå†ï¼š [inLeft, rootIdx - 1]\nååºéå†ï¼š [postLeft, postLeft + leftSize - 1]\n\n\nå³å­æ ‘ï¼š\nå…ˆåºéå†ï¼š [preLeft + leftSize + 1, preRight]\nä¸­åºéå†ï¼š [rootIdx + 1, inRight]\nååºéå†ï¼š [postLeft + leftSize, postRight - 1]\n\n\n\nè‡³äºå¦‚ä½•èƒ½å¿«é€Ÿåœ°æ ¹æ®å…ˆåºéå†&#x2F;ååºéå†çš„å…ƒç´ å®šä½è‡³å®ƒåœ¨ä¸­åºéå†ä¸­çš„ä½ç½®ï¼Ÿ\nç­”æ¡ˆæ˜¯ï¼šåœ¨å¼€å§‹æ—¶ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨æ¥é¢„å¤„ç†å­˜å‚¨å…ˆ&#x2F;ååºéå†æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ä½ç½®ã€‚\n\n\nLeetCode.105 â€“ ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ä»£ç class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    this.n = preorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(preorder, 0, n - 1, inorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) &#123;    if (preLeft &gt; preRight || inLeft &gt; inRight) &#123;      return null;    &#125;    int rootVal = preorder[preLeft], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(preorder, preLeft + 1, preLeft + rootIdx - inLeft, inorder, inLeft, rootIdx - 1);    root.right = buildTree(preorder, preLeft + rootIdx - inLeft + 1, preRight, inorder, rootIdx + 1, inRight);    return root;  &#125;&#125;\n\n\n\nLeetCode.106 â€“ ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ä»£ç class Solution &#123;    private int n;  private Map&lt;Integer, Integer&gt; map;  public TreeNode buildTree(int[] inorder, int[] postorder) &#123;    this.n = inorder.length;    this.map = new HashMap&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;      map.put(inorder[i], i);    &#125;    return buildTree(inorder, 0, n - 1, postorder, 0, n - 1);  &#125;  private TreeNode buildTree(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft, int postRight) &#123;    if (inLeft &gt; inRight || postLeft &gt; postRight) &#123;      return null;    &#125;    int rootVal = postorder[postRight], rootIdx = map.get(rootVal);    TreeNode root = new TreeNode(rootVal);    root.left = buildTree(inorder, inLeft, rootIdx - 1, postorder, postLeft, postLeft + rootIdx - inLeft - 1);    root.right = buildTree(inorder, rootIdx + 1, inRight, postorder, postLeft + rootIdx - inLeft, postRight - 1);    return root;  &#125;&#125;","tags":["ç®—æ³•","äºŒå‰æ ‘"]},{"title":"ã€Œé“¾è¡¨ã€é“¾è¡¨é¢˜æ€»ç»“","url":"/2022/03/27/%E3%80%8C%E9%93%BE%E8%A1%A8%E3%80%8D%E9%93%BE%E8%A1%A8%E9%A2%98%E6%80%BB%E7%BB%93/","content":"é“¾è¡¨çš„åŸºæœ¬å¥—è·¯ï¼šé“¾è¡¨åè½¬public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  // ä¸‰æŒ‡é’ˆ  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\næ‰¾é“¾è¡¨çš„ä¸­ç‚¹public ListNode middleNode(ListNode head) &#123;  // å¿«æ…¢åŒæŒ‡é’ˆ  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // è‡³æ­¤ï¼Œslow ç§»åŠ¨è‡³é“¾è¡¨çš„ä¸­ç‚¹  // å¯¹äºé•¿åº¦ä¸ºå¥‡æ•°çš„é“¾è¡¨ï¼Œä¸­ç‚¹åªæœ‰ä¸€ä¸ª  // å¯¹äºé•¿åº¦ä¸ºå¶æ•°çš„é“¾è¡¨ï¼Œä¸­ç‚¹æœ‰ä¸¤ä¸ªã€‚æ­¤æ—¶ slow ä½äºç¬¬ä¸€ä¸ªä¸­ç‚¹  return slow;&#125;\n\n\næ‰¾é“¾è¡¨çš„å€’æ•°ç¬¬ K ä¸ªèŠ‚ç‚¹ (ä½¿ç”¨å‰ååŒæŒ‡é’ˆ former, latter )public ListNode kthToLast(ListNode head, int k) &#123;  ListNode former = head, latter = head;  // è®©å…ˆæŒ‡é’ˆ former å…ˆèµ° k æ­¥  for (int i = 0; i &lt; k; i++) &#123;    former = former.next;  &#125;  while (former != null) &#123;    former = former.next;    latter = latter.next;  &#125;  return latter;&#125;\n\n\nåˆ é™¤æŸèŠ‚ç‚¹// æ‰¾åˆ°å¾…åˆ é™¤èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ prevprev.next = prev.next.next\n\n\n\nå¾ˆå¤šé“¾è¡¨çš„ä¸­ç­‰é¢˜ç”šè‡³æ˜¯å›°éš¾é¢˜ï¼Œå…¶å®éƒ½æ˜¯å¯¹äºä¸Šè¿°åŸºæœ¬å¥—è·¯çš„ç¼åˆã€‚\nä¾‹å¦‚ï¼ŒLeetCode.234 â€“ åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ ã€‚\n\nå¾ˆç›´è§‚çš„ä¸€ä¸ªåšæ³•æ˜¯ï¼šä½¿ç”¨ æ ˆ çš„æ•°æ®ç»“æ„ï¼Œå…ˆå­˜å‚¨é“¾è¡¨çš„å‰åŠéƒ¨åˆ†ï¼Œç„¶åä¸ååŠéƒ¨åˆ†é€ä¸ªè¿›è¡Œæ¯”å¯¹ã€‚ä½†æ˜¯è¿™ä¹ˆåšçš„è¯ï¼Œç©ºé—´å¤æ‚åº¦å°±æ˜¯ O(n) äº†ã€‚\nå­˜åœ¨ä¸€ç§ç©ºé—´å¤æ‚åº¦ O(1) çš„åŸåœ°è§£æ³•ï¼Œå³ç”¨åˆ°æˆ‘ä»¬ä¸Šé¢æ‰€è¯´çš„åŸºæœ¬å¥—è·¯æ“ä½œã€‚\nå…·ä½“åšæ³•æ˜¯ï¼š\n\nä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå®šä½è‡³é“¾è¡¨çš„ä¸­ç‚¹\nåè½¬ååŠéƒ¨åˆ†çš„é“¾è¡¨\næ¯”è¾ƒå‰åŠéƒ¨åˆ†ä¸ååŠéƒ¨åˆ†çš„é“¾è¡¨æ˜¯å¦å®Œå…¨ä¸€è‡´public boolean isPalindrome(ListNode head) &#123;  // å®šä½è‡³é“¾è¡¨çš„ä¸­ç‚¹  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // åè½¬ååŠéƒ¨åˆ†çš„é“¾è¡¨  ListNode prev = null, cur = slow.next;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨  ListNode ptr1 = head, ptr2 = prev;  while (ptr2 != null) &#123;    if (ptr1.val != ptr2.val) &#123;      return false;    &#125;    ptr1 = ptr1.next;    ptr2 = ptr2.next;  &#125;  return true;&#125;\n\n\n\nå¸¸è§é“¾è¡¨é¢è¯•é¢˜åè½¬é“¾è¡¨public ListNode reverseList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = null, cur = head;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  return prev;&#125;\n\n\nKä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨public ListNode reverseKGroup(ListNode head, int k) &#123;  // åˆ¤æ–­å‰©ä½™èŠ‚ç‚¹ä¸ªæ•°æ˜¯å¦å¤Ÿ k ä¸ª  ListNode cur = head;  for (int i = 0; i &lt; k; i++) &#123;    if (cur == null) &#123;      return head;    &#125;    cur = cur.next;  &#125;  // ç¿»è½¬æ¥ä¸‹æ¥çš„ k ä¸ªèŠ‚ç‚¹  ListNode prev = null;  cur = head;  for (int i = 0; i &lt; k; i++) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // å°¾éƒ¨è¿æ¥  head.next = reverseKGroup(cur, k);  return prev;&#125;\n\n\nåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;  if (list1 == null) &#123;    return list2;  &#125;  if (list2 == null) &#123;    return list1;  &#125;  if (list1.val &lt;= list2.val) &#123;    list1.next = mergeTwoLists(list1.next, list2);    return list1;  &#125;  list2.next = mergeTwoLists(list1, list2.next);  return list2;&#125;\nå¦å¤–ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£æ³• (ç±»ä¼¼äºå½’å¹¶æ’åº) ã€‚\nåˆ¤æ–­æ˜¯å¦ä¸ºç¯å½¢é“¾è¡¨public boolean hasCycle(ListNode head) &#123;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      return true;    &#125;  &#125;  return false;&#125;\n\nå»¶ä¼¸é—®é¢˜ï¼š æ‰¾åˆ°ç¯çš„å…¥å£èŠ‚ç‚¹\n\npublic ListNode detectCycle(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  boolean hasCycle = false;  ListNode slow = head, fast = head;  while (fast != null &amp;&amp; fast.next != null) &#123;    slow = slow.next;    fast = fast.next.next;    if (slow == fast) &#123;      hasCycle = true;      break;    &#125;  &#125;  if (!hasCycle) &#123;    return null;  &#125;  slow = head;  while (slow != fast) &#123;    slow = slow.next;    fast = fast.next;  &#125;  return slow;&#125;\n\n\nç›¸äº¤é“¾è¡¨public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;  int lenA = getLen(headA), lenB = getLen(headB);  if (lenB &gt; lenA) &#123;    return getIntersectionNode(headB, headA);  &#125;  // ä¿è¯ä¸¤ä¸ªé“¾è¡¨çš„å‰©ä½™é•¿åº¦ä¸€è‡´  while (lenA &gt; lenB) &#123;    headA = headA.next;    lenA--;  &#125;  while (headA != headB) &#123;    headA = headA.next;    headB = headB.next;  &#125;  return headA;&#125;private int getLen(ListNode head) &#123;  int ans = 0;  while (head != null) &#123;    head = head.next;    ans++;  &#125;  return ans;&#125;\n\n\né“¾è¡¨ç›¸åŠ public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;  if (l1 == null) &#123;    return l2;  &#125;  // ä¸è¶³è¡¥0  if (l2 == null) &#123;    l2 = new ListNode(0);  &#125;  l1.val += l2.val;  // å­˜åœ¨è¿›ä½ç°è±¡  if (l1.val &gt;= 10) &#123;    l1.val -= 10;    if (l1.next == null) &#123;      l1.next = new ListNode(0);    &#125;    l1.next.val++;    &#125;  &#125;  l1.next = addTwoNumbers(l1.next, l2.next);  return l1;&#125;\n\n\né‡æ’é“¾è¡¨public void reorderList(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return;  &#125;  // æ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹  ListNode slow = head, fast = head;  while (fast.next != null &amp;&amp; fast.next.next != null) &#123;    slow = slow.next;    fast = fast.next.next;  &#125;  // ç”±æ­¤ï¼Œå°†æ•´ä¸ªé“¾è¡¨åˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚  // å‰åŠéƒ¨åˆ†æ˜¯ [head,mid] ï¼›ååŠéƒ¨åˆ†æ˜¯ [mid.next,end]  ListNode mid = slow, cur = mid.next;  mid.next = null;  // åè½¬ååŠéƒ¨åˆ†çš„é“¾è¡¨  ListNode prev = null;  while (cur != null) &#123;    ListNode temp = cur.next;    cur.next = prev;    prev = cur;    cur = temp;  &#125;  // åˆå¹¶ä¸¤ä¸ªé“¾è¡¨  ListNode ptr1 = head, ptr2 = prev;  while (ptr1 != null &amp;&amp; ptr2 != null) &#123;    ListNode temp1 = ptr1.next, temp2 = ptr2.next;    ptr1.next = ptr2;    ptr2.next = temp1;    ptr1 = temp1;    ptr2 = temp2;  &#125;&#125;\n\n\nåˆ é™¤é“¾è¡¨çš„é‡å¤å…ƒç´ public ListNode deleteDuplicates(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode prev = new ListNode(-200, head), cur = prev;  while (cur.next != null) &#123;    // å»é‡    if (cur.val == cur.next.val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return prev.next;&#125;\n\n\nä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹public ListNode swapPairs(ListNode head) &#123;  if (head == null || head.next == null) &#123;    return head;  &#125;  ListNode first = head, second = first.next, third = second.next;  second.next = first;  first.next = swapPairs(third);  return second;&#125;\n\n\né“¾è¡¨æ’åºpublic ListNode sortList(ListNode head) &#123;  if (head == null) &#123;    return null;  &#125;  return mergeSort(head);&#125;private ListNode mergeSort(ListNode head) &#123;  if (head.next == null) &#123;    return head;  &#125;  ListNode pre = null, ptr1 = head, ptr2 = head;  while (ptr2 != null &amp;&amp; ptr2.next != null) &#123;    pre = ptr1;    ptr1 = ptr1.next;    ptr2 = ptr2.next.next;  &#125;  pre.next = null;  ListNode left = mergeSort(head);  ListNode right = mergeSort(ptr1);  return merge(left, right);&#125;private ListNode merge(ListNode left, ListNode right) &#123;  ListNode dummy = new ListNode(-1), cur = dummy;  while (left != null &amp;&amp; right != null) &#123;    if (left.val &lt;= right.val) &#123;      cur.next = left;      cur = cur.next;      left = left.next;    &#125; else &#123;      cur.next = right;      cur = cur.next;      right = right.next;    &#125;  &#125;  if (left != null) &#123;    cur.next = left;  &#125;  if (right != null) &#123;    cur.next = right;  &#125;  return dummy.next;&#125;\n\n\nåˆ†éš”é“¾è¡¨public ListNode partition(ListNode head, int x) &#123;  ListNode dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);  ListNode ptr1 = dummy1, ptr2 = dummy2;  while (head != null) &#123;    if (head.val &lt; x) &#123;      ptr1.next = head;      head = head.next;      ptr1 = ptr1.next;      ptr1.next = null;    &#125; else &#123;      ptr2.next = head;      head = head.next;      ptr2 = ptr2.next;      ptr2.next = null;    &#125;  &#125;  ptr1.next = dummy2.next;  return dummy1.next;&#125;","tags":["ç®—æ³•","é“¾è¡¨"]}]