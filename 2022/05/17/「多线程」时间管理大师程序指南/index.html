<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="twq"><title>「多线程」 时间管理大师 | TwQ 的博客</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.jpg"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.ttwwq.top",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/favicon.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"保持热爱，保持记录 :D"},scroll:{progress_bar:{enable:!0},percent:{enable:!1}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"mac"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">TwQ 的博客</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页 🏠</a></li><li class="menu-item"><a href="/archives">归档 📄</a></li><li class="menu-item"><a href="/tags">标签 🏷️</a></li><li class="menu-item"><a href="/todo">待办 ✅</a></li><li class="menu-item"><a href="/board">留言板 💬</a></li><li class="menu-item"><a href="/about">关于 🥳</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页 🏠</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档 📄</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签 🏷️</a></li><li class="drawer-menu-item flex-center"><a href="/todo">待办 ✅</a></li><li class="drawer-menu-item flex-center"><a href="/board">留言板 💬</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于 🥳</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">「多线程」 时间管理大师</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">twq</span> <span class="author-label">Lv.2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-05-17 16:22:58</span> <span class="mobile">2022-05-17 16:22</span> </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Java/">Java</a>&nbsp;</li><li>| <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>6.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>21 分钟</span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的几种状态？"><a href="#线程的几种状态？" class="headerlink" title="线程的几种状态？"></a>线程的几种状态？</h2><ol><li>新建 New</li><li>就绪 Runnable</li><li>运行 Running</li><li>阻塞 Blocked<ul><li>I&#x2F;O ：阻塞态，仅释放CPU资源，但不会释放占有着的锁。如 <code>sleep()</code></li><li>Waiting ：等待态，会释放CPU资源和占有着的锁。如 <code>wait()</code></li><li>Timed Waiting ：带有超时的等待态</li></ul></li><li>结束 Terminated</li></ol><br><h2 id="线程和进程的区别是什么？"><a href="#线程和进程的区别是什么？" class="headerlink" title="线程和进程的区别是什么？"></a>线程和进程的区别是什么？</h2><ul><li><p>首先，可以从宏观的角度看待它们的关系：一个程序至少有一个进程，一个进程至少有一个线程。</p><p>进程是操作系统进行<strong>资源分配</strong>的最小单元，每个进程都有自己独立的内存空间。进程与进程之间是不共享资源的。如果需要，那么就要使用通信技术（socket、channel）。</p><p>线程是操作系统进行<strong>资源调度</strong>的最小单元。除了线程自己的函数堆栈等，线程与线程之间是共享资源的（这也是为什么会存在线程安全这一问题）。</p><p>打个比喻：进程是水杯，线程是水杯里的水。人喝的是水而不是水杯，但是如果没有水杯来装水也是不行的。</p></li><li><p>进程可以看作是<strong>重量级</strong>的线程。在多任务处理机的环境下，如果直接使用进程作为调度单元，那么在资源切换时的开销是比较大的。为了提高执行效率，所以引入了线程来取代进程的资源调度功能。</p></li></ul><br><h2 id="上下文切换是什么？"><a href="#上下文切换是什么？" class="headerlink" title="上下文切换是什么？"></a>上下文切换是什么？</h2><p>因为多线程是共用计算机上的CPU资源的，并且在一般情况下，线程数都是大于CPU核心数的。为了让所有线程都有执行的机会，所以需要进行线程之间的调度切换。这种切换就是上下文切换。在切换前，需要保存CPU的状态；在切换回来后，又需要恢复CPU的状态，使得线程能够正确地从中断处恢复执行。</p><p>在Java中，线程调度采用的是<strong>抢占式</strong>的方式。一个线程的时间片到后，操作系统会根据线程优先级、线程饥饿情况、CPU空闲率等多方面因素，选出下一个线程，并分配时间片给它。</p><p>可以通过 <code>setPriority()</code> 来设置线程的优先级。不过，你不能指望靠它来保证，因为最终权还是在底层的操作系统。但是，如果不是特别需求，就不要改动线程的优先级，因为这可能会因为设置不当，造成线程饥饿问题（当前线程被一个高优先级的线程吞噬掉了所有的CPU时间）。</p><br><h2 id="什么是线程饥饿？"><a href="#什么是线程饥饿？" class="headerlink" title="什么是线程饥饿？"></a>什么是线程饥饿？</h2><p>线程饥饿指的是：一个线程因为某种原因无法获得所需资源，导致一直无法执行下去。</p><br><p>听起来和死锁有点像：死锁是指两个及以上的线程在执行时，因互相需要对方的资源，却又不肯先释放自己持有的资源，导致全都永远等待在原地。</p><p>死锁和饥饿的相同点是：二者都是因为资源的竞争引起的问题。</p><p>死锁和饥饿的不同点是：</p><ul><li>在死锁中，资源的占有方和资源的拥有方互相请求对方的资源；在饥饿中，当前线程只是迟迟得不到所需资源，但是并不在乎这个资源是谁给的！</li><li>死锁一定涉及多个线程，而饥饿可能只有一个线程。</li><li>当饥饿发生时，除了饥饿线程得不到执行机会，其他线程都还是正常执行的；当死锁发生时，可能最终会使整个系统都陷入死锁并崩溃。</li></ul><br><h2 id="Callable-和-Future-的区别？"><a href="#Callable-和-Future-的区别？" class="headerlink" title="Callable 和 Future 的区别？"></a>Callable 和 Future 的区别？</h2><p>Callable 接口类似于 Runnable (从名字也可以看得出) ，不过 Runnable 不会返回执行结果，也无法抛出返回结果的异常。但是 Callable 就弥补了这一缺陷，可以认为是带有回调功能的 Runnable ：能够返回异步执行的结果，然后由 Future 接收到。</p><br><h2 id="线程之间如何进行通信？"><a href="#线程之间如何进行通信？" class="headerlink" title="线程之间如何进行通信？"></a>线程之间如何进行通信？</h2><ol><li>使用 Object 类中提供的 <code>wait()</code> &amp; <code>notify()/notifyAll()</code> 、<code>park()</code> &amp; <code>unpark()</code> 机制</li><li>使用 concurrent 包下的同步工具类，如 CountDownLatch 、CyclicBarrier 。</li></ol><br><h2 id="为什么要把-wait-、notify-这种方法定义在-Object-类中？"><a href="#为什么要把-wait-、notify-这种方法定义在-Object-类中？" class="headerlink" title="为什么要把 wait()、notify() 这种方法定义在 Object 类中？"></a>为什么要把 wait()、notify() 这种方法定义在 Object 类中？</h2><ol><li>Java 中的每个对象都有一个对应的 Monitor 对象。当该对象调用了 <code>wait()</code>、<code>notify()</code> 这些方法时，其实就是在向 Monitor 对象传达信息：等待对象的锁 &#x2F; 通知其他线程对象的 Monitor 是可用的。</li><li>在 Java 的线程中，并没有提供线程同步的方法。为了使得每个类都具有线程间通信的能力，所以给每个类都应该提供一个类似 <code>wait()</code> 、 <code>notify()/notifyAll()</code> 的方法。而 Object 作为所有类的父类，将这样的方法直接放在 Object 中也是十分合适的。</li></ol><br><h2 id="保证线程安全的方案？"><a href="#保证线程安全的方案？" class="headerlink" title="保证线程安全的方案？"></a>保证线程安全的方案？</h2><ol><li><p>使用 synchronized 关键字</p></li><li><p>使用 Lock 接口下的实现类</p></li><li><p>使用线程的本地局部变量 ThreadLocal</p><p>简单来说就是一种<strong>以空间换时间的数据隔离思想</strong>：在每个线程中，维护了一个 <strong>ThreadLocalMap</strong>，用 <code>set()</code> &#x2F; <code>get()</code> 来使用当前线程的数据，最后将这个 Map 挂到当前线程下，所以 Map 就只属于这个线程了。数据不再共享，自然就不存在线程安全的问题了。</p></li><li><p>将对象设置为不可变的 (即对象一旦被创建，就不能再改变了)</p><p>比如 String、基本类型的包装类，这些都是不可变类 (被 final 修饰) 。</p></li><li><p>另辟空间，在操作结束后替换引用地址 (如 CopyOnWriteArrayList)</p></li></ol><br><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="为什么要用线程池？直接-new-Thread-不好吗？"><a href="#为什么要用线程池？直接-new-Thread-不好吗？" class="headerlink" title="为什么要用线程池？直接 new Thread() 不好吗？"></a>为什么要用线程池？直接 new Thread() 不好吗？</h2><ol><li><p>创建线程对象是一个开销较大的操作，无论是对CPU还是对内存占用。所以，如果一个任务就开辟一个新线程，性价比实在是太低了。</p></li><li><p>通过 <code>new Thread()</code> 得到的线程是不易管理的（一般被称为野线程），甚至可以无限制的创建！如此一来，如果使用者使用不慎，可能就导致整个操作系统瘫痪了……🙃</p></li><li><p>通过 <code>new Thread()</code> 得到的线程也不易于扩展。比如，想要定时执行、定期执行的话，都是不容易实现的。</p></li></ol><br><p>因此，引入了一个名为线程池的思想，完美解决了上述缺点。</p><ol><li>复用已创建好的那些线程，从而降低了资源消耗，并且便于管理</li><li>可以很方便地进行功能扩展，达到定时执行等效果</li></ol><p>不过，如果阅读过阿里巴巴开发手册就会发现，<strong>不建议使用 Executors 来创建线程</strong>。主要原因是：用这样的方式来创建线程，使用者对于这个默认线程池的规则是不够了解的，这就有可能导致使用不当。</p><p>所以，<strong>一般建议使用 ThreadPoolExecutor 来创建线程池</strong>，并由使用者来设置线程池的一些核心参数，保证使用者对于这个自定义线程池的规则是了解的。</p><br><h2 id="常用的线程池"><a href="#常用的线程池" class="headerlink" title="常用的线程池"></a>常用的线程池</h2><ul><li><code>newCachedThreadPool()</code>：创建一个可缓存线程池，如果线程池的大小超过实际需要，在超时时间后会回收空闲线程。当任务数增加时，又可以动态地添加新线程来处理任务。</li><li><code>newFixedThreadPool()</code>：创建一个大小固定的线程池。每次提交一个任务就会创建一个线程，直至到达线程池的最大大小。超出的线程会在阻塞队列中等待。</li><li><code>newSingleThreadExecutor()</code>：创建一个单线程化的线程池，使用唯一的工作线程来执行所有任务。可以保证所有任务都是按照顺序来执行的。</li><li><code>newScheduledThreadPool()</code>：创建一个大小固定的线程池。支持定时及周期性任务执行。</li></ul><br><h2 id="解读一下线程池的7大核心参数？"><a href="#解读一下线程池的7大核心参数？" class="headerlink" title="解读一下线程池的7大核心参数？"></a>解读一下线程池的7大核心参数？</h2><ol><li>corePoolSize : 核心线程数</li><li>maximumPoolSize : 最大线程数 (核心线程数+救急线程数)</li><li>keepAliveTime : 空闲的救急线程的最大存活时间</li><li>TimeUnit : keepAliveTime 的时间单位</li><li>workQueue : 阻塞队列，用于存放那些待执行的任务</li><li>threadFactory : 创建线程池中的工作线程的线程工厂 (一般都是默认即可)</li><li>rejectedHandler : 拒绝策略。当线程池中的阻塞队列已满，且线程数已达到最大线程数时，执行拒绝策略。<ul><li>AbortPolicy : 拒绝新任务并抛出异常</li><li>DiscardPolicy : 拒绝新任务，但不抛出异常</li><li>CallerRunsPolicy : 使用当前调用的线程来执行此任务 (相当于为了让任务不失败，于是让它插队)</li><li>DiscardOldestPolicy : 抛弃阻塞队列头部 (最旧) 的一个任务，并执行当前任务</li></ul></li></ol><br><p>对于阻塞队列的使用，需要进行一点说明：</p><ul><li>如果使用的是 LinkedBlockingQueue 等无界队列，那么可以无限地向线程池中添加任务 (因为阻塞队列不会满) 而不会触发拒绝策略。并且，也不会触发救急线程。所以，相当于 maximumPoolSize, keepAliveTime, TimeUnit, rejectedHandler 都是无意义的参数。</li><li>如果使用的是 ArrayBlockingQueue 等有界队列，那么如果阻塞队列已满，就会触发救急线程。如果救急线程也达到了上限，那么再有新任务时就会触发拒绝策略。</li></ul><br><h2 id="线程池的执行流程？"><a href="#线程池的执行流程？" class="headerlink" title="线程池的执行流程？"></a>线程池的执行流程？</h2><ol><li>当线程数小于 corePoolSize 时，使用<strong>核心线程</strong>来执行任务</li><li>当线程数大于 corePoolSize 时，将多余的任务放入<strong>阻塞队列</strong></li><li>当阻塞队列已满时，启动<strong>救急线程</strong>来执行</li><li>当阻塞队列已满，且线程数已达到 maximumPoolSize 时，执行<strong>拒绝策略</strong></li><li>当阻塞队列不再满时，已创建的那些救急线程就进入空闲状态。如果它们的空闲时间超过 keepAliveTime ，就会<strong>回收</strong>这些救急线程</li></ol><br><h2 id="submit-和-execute-的区别？"><a href="#submit-和-execute-的区别？" class="headerlink" title="submit() 和 execute() 的区别？"></a>submit() 和 execute() 的区别？</h2><p>这两者都是用于向线程池提交任务的。</p><p>区别在于：</p><ul><li>execute() 没有返回值</li><li>submit() 返回值是一个 Future 对象，从而可以得到异步执行的结果</li></ul><br><h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h1><h2 id="synchronized-修饰在不同的位置，各代表什么？"><a href="#synchronized-修饰在不同的位置，各代表什么？" class="headerlink" title="synchronized 修饰在不同的位置，各代表什么？"></a>synchronized 修饰在不同的位置，各代表什么？</h2><ul><li>如果 synchronized 修饰的是一个实例方法，则上锁的是调用该方法的对象实例</li><li>如果 synchronized 修饰的是一个静态方法，则上锁的是所在类的Class实例</li><li>如果 synchronized 修饰的是一个代码块，则上锁的是传入 synchronized 括号内的对象实例</li></ul><p><strong>请知道一条原则：同步块的作用范围越小越好。</strong></p><br><h2 id="synchronized-的底层原理是什么？"><a href="#synchronized-的底层原理是什么？" class="headerlink" title="synchronized 的底层原理是什么？"></a>synchronized 的底层原理是什么？</h2><h3 id="前置知识点：Mark-Word-、Monitor-对象"><a href="#前置知识点：Mark-Word-、Monitor-对象" class="headerlink" title="前置知识点：Mark Word 、Monitor 对象"></a>前置知识点：Mark Word 、Monitor 对象</h3><ol><li><p>无论 synchronized 修饰的是什么，对应的锁都是一个实例对象。</p><p>一个对象，是由三部分组成的：对象头、对象实际内容、对齐填充字段。synchronized 的原理，就在于<strong>对象头</strong>之中的 <strong>Mark Word</strong> 部分。这部分就负责记录对象关于锁的信息。</p></li><li><p>另外，每个对象都会有一个 Monitor 对象，存储着当前持有该 (对象) 锁的线程，并维护一个阻塞等待该 (对象) 锁的等待队列。</p></li></ol><br><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>在JDK1.6之前，锁的操作都是重量级的：monitor对象直接存储持有着锁的线程的id，并设置 Mark Word 中的 monitor对象地址，把其他阻塞等待的线程都加入等待队列中。这个加锁的过程是依赖底层操作系统的 mutex 指令的，存在用户态与内核态之间的切换，所以性能损耗十分严重。</p><p>在JDK1.6之后，引入了偏向锁、轻量级锁的概念，它们是在JVM层面的规定，所以就不依赖于底层操作系统，性能得到大幅提升。</p><p>总体流程是：无锁 &#x3D;&#x3D;&gt; 偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁。并且，锁只有升级，不存在降级。</p><p>从使用层面看，至始至终都是关键字 synchronized，即：这种优化是内部的，对于使用者而言是无感知的。引入了偏向锁和轻量级锁这两个概念，就是为了能够尽可能地提高并发执行时的效率问题。</p><ul><li><p><strong>偏向锁</strong></p><p>JVM<strong>认为</strong>在同一时间，只会有一个线程来执行同步块中的代码，即：这是一个<strong>没有竞争</strong>的环境。</p><p>所以直接在 Mark Word 中记录该线程。如果一个线程想要获得锁，就直接比对线程ID与 Mark Word 中存放的是否一致，一致就可以直接获得这个锁；否则，用CAS来尝试修改 Mark Word，将记录改为当前线程ID。</p><p>如果CAS修改成功，那么线程仍旧可以获得这个锁；否则，说明当前环境是存在竞争的，于是升级为<strong>轻量级锁</strong>。</p></li><li><p><strong>轻量级锁</strong></p><p>当前线程会在栈帧下创建 Lock Record，把 Mark Word 的信息都拷贝进去。如果一个线程想要获得锁，先用CAS来尝试将 Mark Word 信息修改为该线程的 Lock Record。</p><p>如果CAS修改成功，那么线程就获取到了这个锁 (轻量级) ；否则，进行自旋重试。当自旋一定次数后仍不能获得锁，就升级为<strong>重量级锁</strong>。</p></li></ul><p><strong>总结：</strong></p><ol><li>只有一个线程进入临界区：偏向锁</li><li>多个线程交替进入临界区：轻量级锁</li><li>多个线程同时进入临界区：重量级锁</li></ol><br><h1 id="关于-java-util-concurrent"><a href="#关于-java-util-concurrent" class="headerlink" title="关于 java.util.concurrent"></a>关于 java.util.concurrent</h1><h2 id="乐观锁和悲观锁是如何理解的？"><a href="#乐观锁和悲观锁是如何理解的？" class="headerlink" title="乐观锁和悲观锁是如何理解的？"></a>乐观锁和悲观锁是如何理解的？</h2><ul><li><p>乐观锁：非常乐观，认为每次拿到的数据都没有被人修改过，所以不会上锁。</p><p>在进行更新的时候，使用的是CAS算法：先判断当前值是否是预期值，如果是，则可以进行写操作写入新值；否则，被告知这次竞争失败，然后进行再次尝试，直到成功。</p><p>乐观锁的缺点是：</p><ol><li><p>ABA 问题</p><p>线程1读取了某变量的值是A 。此时线程2也读取了该变量，并且线程2将它改为了B ，后又改回为A 。</p><p>然后线程1进行CAS操作，发现当前值与预期值一致，均为A ，于是放心地写入了新值。</p><p>以上过程，线程1的CAS操作是成功的，但这是有潜在隐患的。</p><p>从 JDK1.5 开始，提供了一个名为 AtomicStampedReference 的类来解决ABA问题，即增加了一个比对元素：版本号。每次操作后都会更新这个版本号。这样，即使是同一个值，如果版本号不一致，也被认为是CAS失败。</p></li><li><p>如果资源竞争十分激烈，那么CAS自旋的概率会很高，从而导致大多数时间都是在浪费CPU资源，效率反而不如 synchronized 。</p></li><li><p>只能保证对于一个变量的原子操作。如果需要保证对于多个变量的原子操作，那么就需要用锁了。</p></li></ol></li><li><p>悲观锁：非常悲观，总是做最坏的打算，认为每次拿到的数据都是被人修改过了的，所以每次在拿到数据时都会上锁，这样其他线程就拿不到了。</p><p>Java 的同步关键字 synchronized 就是悲观锁的。此外，传统的关系型数据库 (例如MySQL) 里面的行锁、表锁、读锁、写锁等，用到的也都是悲观锁的机制。</p><p>悲观锁是足够安全的，但是缺点也很明显：每次操作都要上锁，结束后再释放锁，比较耗时。</p></li></ul><p><strong>在大多数情况下 (竞争不是特别激烈) ，乐观锁的性能是好于悲观锁的。</strong></p><br><h2 id="Lock-接口是什么？对比传统的同步，有什么优势？"><a href="#Lock-接口是什么？对比传统的同步，有什么优势？" class="headerlink" title="Lock 接口是什么？对比传统的同步，有什么优势？"></a>Lock 接口是什么？对比传统的同步，有什么优势？</h2><p>Lock 接口是同步的扩展，使用起来更加**灵活 **。典型的实现类是 ReentrantLock 。</p><ul><li>支持公平&#x2F;非公平的模式选择 (出于性能考虑，一般都是默认非公平模式)</li><li>允许线程在等待锁时被中断</li><li>允许让线程去尝试获得锁，如果无法获得，可以选择立即返回不再等待或是等待一段时间 (带有超时时间)</li><li>配合条件变量 Condition 来使用，达到 wait&#x2F;notify 的效果，并且是支持中断、超时的</li></ul><p>不过，需要注意的是：使用 synchronized 无需考虑释放锁的操作，因为这是自动的；而 Lock 就必须要求使用者手动来释放锁资源。因此，最规范的写法就是在 finally 块中进行 <code>unlock()</code> 释放操作。</p><br><h2 id="公平锁和非公平锁的区别是什么？"><a href="#公平锁和非公平锁的区别是什么？" class="headerlink" title="公平锁和非公平锁的区别是什么？"></a>公平锁和非公平锁的区别是什么？</h2><p>简单来说，公平锁模式是讲究先来后到的顺序的；非公平锁模式是谁准备好了就谁来。</p><p>公平锁：在竞争环境下，先到达临界区的线程<strong>一定</strong>比后到达临界区的线程更早地获得锁。</p><p>非公平锁：在竞争环境下，先到达临界区的线程<strong>未必</strong>比后到达临界区的线程更早地获得锁。</p><p>所以，决定它们的因素就是：如果一个线程到达了临界区，它是否会直接尝试获得锁 (非公平) ，还是会直接进入等待队列 (公平) 。</p><br><h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><ol><li><p>CopyOnWriteArrayList (性能较差的同步容器是 Vector)</p><p>主要特点是：读写分离。</p><ol><li>实际的写操作发生在复制的数组上，而读操作还是在原始数组中进行，从而实现读写分离，互不影响。</li><li>在写操作时需要加锁，防止并发写入时导致写入数据丢失。</li><li>在写操作结束后，把原始数组的引用指向新的复制数组。</li></ol><p>缺点是：</p><ol><li>由于每次写操作都会复制出一个新的数组，所以是比较耗费内存的。</li><li>只能保证最终一致性，无法保证实时一致性。</li></ol><p>我们可以从中学到的线程安全解决思路是：通过另辟空间，来解决并发问题。</p></li><li><p>ConcurrentHashMap (性能较差的同步容器是 HashTable)</p><p>底层数据结构与普通的 HashMap 一样，同为数组+链表&#x2F;红黑树。</p><ol><li>在 <code>put()</code> 写操作时需要加锁，不过使用的是 CAS算法 (在JDK8之前，使用的是分段锁的方式)</li><li>在 <code>get()</code> 读操作时不加锁，value属性通过 volatile 关键字进行修饰，保证了内存可见性，即每次 <code>get()</code> 得到的都是最新值</li></ol></li></ol><br><h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><ol><li><p>CountDownLatch</p><p>在创建时传入一个参数 <code>new CountDownLatch(int initial)</code> 作为计数次数。</p><p>其他线程每调用一次 <code>countDown()</code> 方法，计数器减1。</p><p>当计数器被减为0时，主线程从 <code>latch.await()</code> 处重新被唤醒，然后继续执行后续代码。</p></li><li><p>CyclicBarrier</p><p>和 CountDownLatch 的作用一样，只不过 CountDownLatch 只能使用一次，使用之后就会失效，而 CyclicBarrier 可以反复使用。</p></li><li><p>Semaphore</p><p>在不超过设定上限的线程数的情况下，允许多个线程并行执行。主要用于限流之类的操作，限制某段代码块的并发数。打个比喻：Semaphore 就好比是一个停车场，允许同时停放多辆车辆，但也总有一个上限。</p><p>如果 Semaphore 的构造函数中传入的参数是 1 ，就相当于一个 synchronized 了。</p></li></ol><br><h2 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h2><p>全称是 AbstractQueuedSynchronizer 。作为一个抽象类，相当于是很多同步容器的框架模板，其中制定了很多用于保证线程安全的基本规则。</p><p>常用的实现类有 ReentrantLock, Semaphore, FutureTask 等。</p><br><h2 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h2><p>底层是使用一个双向链表来维护一个FIFO的等待队列，还有一个 state 的状态变量。</p><p>队列中存储的实体是 Node 节点，记录了当前的状态值、同步模式 (独占 &#x2F; 共享) 、前驱节点和后继节点。</p><p><strong>总体流程是：</strong>把需要等待的线程以 Node 节点的形式加入到等待队列中，用 state 变量来维护当前锁的状态。</p><p>当调用了 <code>lock()</code> 方法时：</p><ol><li><p>使用CAS来尝试获得锁。如果成功，那么就可以执行同步块中的代码；</p></li><li><p>否则，调用 <code>acquire()</code> 方法，判断 state 是否为0。<strong>如果等于0，说明没有其他线程持有这把锁，那么就再进行一次CAS尝试。</strong>如果成功，那么就可以执行同步块中的代码；</p></li><li><p>否则，说明有线程正在持有着这把锁。于是再判断当前线程是否持有着锁，如果是，那么更新 state 的值加1 (这里正是<strong>可重入</strong>的体现) ，然后就可以执行同步块中的代码；</p></li><li><p>否则，只能将当前线程加入等待队列中，然后将自己 <code>park()</code> 挂起，等待后续被唤醒后再继续进行CAS尝试……直至成功，然后执行同步块中的代码。</p><p>在加入等待队列的过程中，其实还有一些细节：</p><ol><li>节点入队后，会判断前驱节点是否为头节点。<strong>如果是头节点，那么就可以再进行一次CAS尝试。</strong>如果成功，那么就可以执行同步块中的代码；</li><li>否则，会把前驱节点的状态设置为 <strong>SIGNAL</strong> (-1) ，用以表示后续节点需要被唤醒，而这个任务就交给了前驱节点。</li></ol></li></ol><p>当调用了 <code>unlock()</code> 方法时，就非常简单了：把 state 置0，然后唤醒等待队列中第一个需要被唤醒的节点 (节点的 state 小于0) ，然后这个节点就会进行CAS尝试来获得锁。</p><br><h2 id="AQS的同步方式是什么？"><a href="#AQS的同步方式是什么？" class="headerlink" title="AQS的同步方式是什么？"></a>AQS的同步方式是什么？</h2><p>AQS支持两种同步方式：独占式和共享式。</p><p>独占式，锁只会被一个线程持有。如 ReentrantLock</p><p>共享式，多个线程可以同时执行。如 Semaphore, CountDownLatch</p><br><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h1><h2 id="volatile-的作用是什么？"><a href="#volatile-的作用是什么？" class="headerlink" title="volatile 的作用是什么？"></a>volatile 的作用是什么？</h2><ol><li><p>volatile 可以保证内存可见性。被 volatile 修饰的变量在进行写操作后，其他线程能马上读到最新值。</p><p>简单地说，就是在对一个 volatile 变量进行写操作前，JMM会插入一个写屏障，保证所有线程都可以马上看见这个新值；在对一个 volatile 变量进行读操作前，JMM会插入一个读屏障，保证任何数据的更新对所有线程都是可见的。</p></li><li><p>volatile 可以保证不会发生指令重排序的问题。最典型的使用场景就是懒汉式的DCL单例模式。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">/** 这里一定要使用 volatile 关键字来修饰单例实例，以防止指令重排序导致的线程不安全问题 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** 构造器使用 private 修饰，对外部进行屏蔽 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** 对外暴露的唯一公开静态方法，以此提供单例实例。这里使用 volatile+DCL 来保证线程安全 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	线程安全的单例模式还可以是静态内部类；亦或是直接使用饿汉式，在类加载时就创建，由jvm保证了线程安全性。</p><p>​	不过就不展开了，毕竟本文的主要内容不是设计模式 :-)</p><ol start="3"><li>与CAS操作结合，保证线程安全性。</li></ol><br><h2 id="为什么会发生指令重排序？"><a href="#为什么会发生指令重排序？" class="headerlink" title="为什么会发生指令重排序？"></a>为什么会发生指令重排序？</h2><p>这是出于性能最大化考虑，CPU常常会对指令进行重排序。当然，前提是不会改变程序的运行结果 🤣 否则编程就成为一个玄学问题了。</p><br><h1 id="一些编写多线程的最佳实践"><a href="#一些编写多线程的最佳实践" class="headerlink" title="一些编写多线程的最佳实践"></a>一些编写多线程的最佳实践</h1><ol><li>不要自己手动创建线程对象，而是使用线程池来管理线程对象，达到资源复用的效果。</li><li>给线程命名，并开启打印线程名的功能。这有助于进行调试。</li><li>尽可能最小化临界区的范围，而不是无脑地将整个方法进行同步。这有助于性能提升。</li><li>尽可能使用 <code>volatile</code> 而不是 <code>synchronized</code></li><li>当需要进行线程间通信时，使用 <code>concurrent</code> 包下的那些同步工具类（如 <code>CountDownLatch</code>, <code>Semaphore</code>），而不是使用 <code>wait() &amp; notify()</code>。</li><li>当需要使用线程安全的容器集合时，使用 <code>concurrent</code> 包下的那些并发容器类，而不是 <code>util</code> 包下的同步容器类。</li></ol></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：「多线程」 时间管理大师</li><li>本文作者：twq</li><li>创建时间：2022-05-17 16:22:58</li><li>本文链接：https://blog.ttwwq.top/2022/05/17/「多线程」时间管理大师程序指南/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Java/">#Java</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/05/18/%E3%80%8CGit%E3%80%8D%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">「Git」</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/"><span class="title flex-center"><span class="post-nav-title-item">「二分最值」 二分法还能这么用？！</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"7e8652081d0a43a84cb4",clientSecret:"09dedf7315b0bb397fda7165e8c883e1605706e3",repo:"blog-comments",owner:"twq2000",admin:["twq2000"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">twq</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;</span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">线程的几种状态？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">线程和进程的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">上下文切换是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E9%A5%A5%E9%A5%BF%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">什么是线程饥饿？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-%E5%92%8C-Future-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">Callable 和 Future 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">线程之间如何进行通信？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A-wait-%E3%80%81notify-%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">为什么要把 wait()、notify() 这种方法定义在 Object 类中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">保证线程安全的方案？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%9B%B4%E6%8E%A5-new-Thread-%E4%B8%8D%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">为什么要用线程池？直接 new Thread() 不好吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.2.</span> <span class="nav-text">常用的线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E8%AF%BB%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">解读一下线程池的7大核心参数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">线程池的执行流程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#submit-%E5%92%8C-execute-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">submit() 和 execute() 的区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E4%BF%AE%E9%A5%B0%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%90%84%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">synchronized 修饰在不同的位置，各代表什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">synchronized 的底层原理是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9AMark-Word-%E3%80%81Monitor-%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.1.</span> <span class="nav-text">前置知识点：Mark Word 、Monitor 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.2.</span> <span class="nav-text">锁的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-java-util-concurrent"><span class="nav-number">4.</span> <span class="nav-text">关于 java.util.concurrent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">乐观锁和悲观锁是如何理解的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">Lock 接口是什么？对比传统的同步，有什么优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">公平锁和非公平锁的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">并发容器类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.5.</span> <span class="nav-text">同步工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.6.</span> <span class="nav-text">AQS是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.7.</span> <span class="nav-text">AQS的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.8.</span> <span class="nav-text">AQS的同步方式是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">volatile 的作用是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">为什么会发生指令重排序？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">6.</span> <span class="nav-text">一些编写多线程的最佳实践</span></a></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>