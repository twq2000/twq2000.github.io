<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="twq"><title>「二分最值」 二分法还能这么用？！ | TwQ 的博客</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.jpg"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.ttwwq.top",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/favicon.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"保持热爱，保持记录 :D"},scroll:{progress_bar:{enable:!0},percent:{enable:!1}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"mac"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">TwQ 的博客</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页 🏠</a></li><li class="menu-item"><a href="/archives">归档 📄</a></li><li class="menu-item"><a href="/tags">标签 🏷️</a></li><li class="menu-item"><a href="/todo">待办 ✅</a></li><li class="menu-item"><a href="/board">留言板 💬</a></li><li class="menu-item"><a href="/about">关于 🥳</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页 🏠</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档 📄</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签 🏷️</a></li><li class="drawer-menu-item flex-center"><a href="/todo">待办 ✅</a></li><li class="drawer-menu-item flex-center"><a href="/board">留言板 💬</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于 🥳</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">「二分最值」 二分法还能这么用？！</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">twq</span> <span class="author-label">Lv.2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-05-14 22:09:18</span> <span class="mobile">2022-05-14 22:09</span> </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;</li><li>| <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>7.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的知识是建立于熟悉掌握二分法的思想与模板代码之上的。</p><p>因此，如果存在任何不确定&#x2F;疑问，可以先移步至此 👉 <a href="/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81">「二分法」二分最硬干货，就在这了！</a> ，其中给出了实用的二分查找模板代码。</p><p>如果已经温习完毕&#x2F;足够熟悉，那么，接下来就开始了~</p><br><h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>最核心的问题是，为什么这类题目可以使用二分法？又没有什么有序数组，也没有什么查找目标，这是干嘛呢？</p><p>原因在于<strong>这类最值问题的答案本身具有二段性。</strong></p><p>所谓<strong>二段性</strong>，翻译成大白话就是：假设我在 h 小时内到达 d 的最小速度是 s ，那么如果我以 s-1 的速度出发，就一定不能在 h 小时内到达 d 。</p><p>而我们使用二分查找，其实就是在查找这个临界最值，即答案。</p><ul><li>如果求的是<strong>在满足要求下的最小值</strong>，那么查询目标就是<strong>第一个满足要求</strong>的数值；</li><li>如果求的是<strong>在满足要求下的最大值</strong>，那么查询目标就是<strong>最后一个满足要求</strong>的数值。</li></ul><br><p>概括而言，可以将这类问题的解题步骤分为两部分：</p><ol><li>确定答案区间。左区间一般取0或1，而右区间取题目规定的最大数据范围。</li><li>根据题目所求，确定二分模板。</li><li>编写检验函数 <code>check()</code>。这也是最困难，最不确定的一部分。每个题目需要具体情况具体分析。</li></ol><br><h1 id="题单汇总-🏷️"><a href="#题单汇总-🏷️" class="headerlink" title="题单汇总 🏷️"></a>题单汇总 🏷️</h1><h2 id="显式最值问题"><a href="#显式最值问题" class="headerlink" title="显式最值问题"></a>显式最值问题</h2><h3 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h3><h4 id="LeetCode-1283-–-使结果不超过阈值的最小除数"><a href="#LeetCode-1283-–-使结果不超过阈值的最小除数" class="headerlink" title="LeetCode.1283 – 使结果不超过阈值的最小除数"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/">LeetCode.1283 – 使结果不超过阈值的最小除数<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</p><p>请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</p><p>每个数除以除数后都向上取整，比方说 7&#x2F;3 &#x3D; 3 ，10&#x2F;2 &#x3D; 5 。</p><p>题目保证一定有解。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,2,5,9], threshold &#x3D; 6<br>输出：5<br>解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。<br>如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。</p></blockquote><br><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestDivisor</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(nums, threshold, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/** 能否以 divisor 作为除数，使得结果不超过 threshold */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> threshold, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">      sum += num / divisor + (num % divisor == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &lt;= threshold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1300-–-转变数组后最接近目标值的数组和"><a href="#LeetCode-1300-–-转变数组后最接近目标值的数组和" class="headerlink" title="LeetCode.1300 – 转变数组后最接近目标值的数组和"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/">LeetCode.1300 – 转变数组后最接近目标值的数组和<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：arr &#x3D; [4,9,3], target &#x3D; 10<br>输出：3<br>解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</p></blockquote><br><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBestValue</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">      right = Math.max(right, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(arr, target, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> getSum(arr, left - <span class="number">1</span>), sum2 = getSum(arr, left);</span><br><span class="line">    <span class="keyword">return</span> target - sum1 &lt;= sum2 - target ? left - <span class="number">1</span> : left;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSum(arr, value) &gt;= target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">      sum += Math.min(num, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-875-–-爱吃香蕉的珂珂"><a href="#LeetCode-875-–-爱吃香蕉的珂珂" class="headerlink" title="LeetCode.875 – 爱吃香蕉的珂珂"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/koko-eating-bananas">LeetCode.875 – 爱吃香蕉的珂珂<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h5><blockquote><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：piles &#x3D; [3,6,7,11], h &#x3D; 8</p><p>输出：4</p></blockquote><br><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(piles, h, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/** 能否以 speed 的速度，在 h 小时内吃完所有香蕉 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h, <span class="type">int</span> speed)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">      cost += pile / speed + (pile % speed == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost &lt;= h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-2064-–-分配给商店的最多商品的最小值"><a href="#LeetCode-2064-–-分配给商店的最多商品的最小值" class="headerlink" title="LeetCode.2064 – 分配给商店的最多商品的最小值"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/">LeetCode.2064 – 分配给商店的最多商品的最小值<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。</p><p>你需要将 所有商品 分配到零售商店，并遵守这些规则：</p><p>一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。<br>分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。<br>请你返回最小的可能的 x 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：n &#x3D; 6, quantities &#x3D; [11,6]<br>输出：3<br>解释：一种最优方案为：</p><ul><li>11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。</li><li>6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。<br>分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) &#x3D; 3 。</li></ul></blockquote><br><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimizedMaximum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] quantities)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1870-–-准时到达的列车最小时速"><a href="#LeetCode-1870-–-准时到达的列车最小时速" class="headerlink" title="LeetCode.1870 – 准时到达的列车最小时速"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/">LeetCode.1870 – 准时到达的列车最小时速<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。</p><p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p><p>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。<br>返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。</p><p>生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：dist &#x3D; [1,3,2], hour &#x3D; 6<br>输出：1<br>解释：速度为 1 时：</p><ul><li>第 1 趟列车运行需要 1&#x2F;1 &#x3D; 1 小时。</li><li>由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3&#x2F;1 &#x3D; 3 小时。</li><li>由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2&#x2F;1 &#x3D; 2 小时。</li><li>你将会恰好在第 6 小时到达。</li></ul></blockquote><br><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSpeedOnTime</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">double</span> hour)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist.length - <span class="number">1</span> &gt; (<span class="type">int</span>) hour || (dist.length - <span class="number">1</span> == (<span class="type">int</span>) hour &amp;&amp; hour % (<span class="type">int</span>) hour == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(dist, hour, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否以 speed 的速度，在 hour 小时内到达终点 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">double</span> hour, <span class="type">int</span> speed)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dist.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      cost += dist[i] / speed + (dist[i] % speed == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost + (<span class="type">double</span>) dist[dist.length - <span class="number">1</span>] / speed &lt;= hour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-2187-–-完成旅途的最少时间"><a href="#LeetCode-2187-–-完成旅途的最少时间" class="headerlink" title="LeetCode.2187 – 完成旅途的最少时间"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-time-to-complete-trips/">LeetCode.2187 – 完成旅途的最少时间<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 <strong>一趟旅途</strong> 所需要花费的时间。</p><p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong> 下一趟旅途。每辆公交车 <strong>独立</strong> 运行，也就是说可以同时有多辆公交车在运行且<strong>互不影响</strong>。</p><p>给你一个整数 totalTrips ，表示所有公交车 <strong>总共</strong> 需要完成的旅途数目。请你返回完成 <strong>至少</strong> totalTrips 趟旅途需要花费的 <strong>最少</strong> 时间。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：time &#x3D; [1,2,3], totalTrips &#x3D; 5<br>输出：3<br>解释：</p><ul><li>时刻 t &#x3D; 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。<br>已完成的总旅途数为 1 + 0 + 0 &#x3D; 1 。</li><li>时刻 t &#x3D; 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。<br>已完成的总旅途数为 2 + 1 + 0 &#x3D; 3 。</li><li>时刻 t &#x3D; 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。<br>已完成的总旅途数为 3 + 1 + 1 &#x3D; 5 。<br>所以总共完成至少 5 趟旅途的最少时间为 3 。</li></ul></blockquote><br><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumTime</span><span class="params">(<span class="type">int</span>[] time, <span class="type">int</span> totalTrips)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1L</span>, right = (<span class="type">long</span>) <span class="number">1e14</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(time, (<span class="type">long</span>) totalTrips, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在 totalTime 的时间内，至少完成 totalTrips 次旅途 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] time, <span class="type">long</span> totalTrips, <span class="type">long</span> totalTime)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : time) &#123;</span><br><span class="line">      count += totalTime / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= totalTrips;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1760-–-袋子里最少数目的球"><a href="#LeetCode-1760-–-袋子里最少数目的球" class="headerlink" title="LeetCode.1760 – 袋子里最少数目的球"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/">LeetCode.1760 – 袋子里最少数目的球<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。</p><p>你可以进行如下操作至多 maxOperations 次：</p><p>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</p><p>请你返回进行上述操作后的最小开销。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [9], maxOperations &#x3D; 2<br>输出：3<br>解释：</p><ul><li>将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。</li><li>将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。<br>装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。</li></ul></blockquote><br><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSize</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxOperations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(nums, maxOperations, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在 maxOperations 次操作内实现 cost 的开销 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxOperations, <span class="type">int</span> cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">      <span class="comment">// 这里需要注意的细节是：</span></span><br><span class="line">      <span class="comment">// 如果正好可以分完，那么共需要 num/cost 个袋子</span></span><br><span class="line">      <span class="comment">// 不过算上本来就有的一个袋子，所以还需要 num/cost-1 个袋子</span></span><br><span class="line">      count += num / cost + (num % cost == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= maxOperations;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="历史标记"><a href="#历史标记" class="headerlink" title="历史标记"></a>历史标记</h3><h4 id="LeetCode-1552-–-两球之间的磁力"><a href="#LeetCode-1552-–-两球之间的磁力" class="headerlink" title="LeetCode.1552 – 两球之间的磁力"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/magnetic-force-between-two-balls/">LeetCode.1552 – 两球之间的磁力<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-7"><a href="#题面-7" class="headerlink" title="题面"></a>题面</h5><blockquote><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。</p><p>给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：position &#x3D; [1,2,3,4,7], m &#x3D; 3<br>输出：3<br>解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。</p></blockquote><br><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[] position, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    Arrays.sort(position);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = position[position.length - <span class="number">1</span>] - position[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(position, m, middle)) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在任意相邻小球的间隔不超过 dist 的情况下，放入 m 个球 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] position, <span class="type">int</span> m, <span class="type">int</span> dist)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, cur = position[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : position) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur + dist &lt;= p) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1482-–-制作-m-束花所需的最少天数"><a href="#LeetCode-1482-–-制作-m-束花所需的最少天数" class="headerlink" title="LeetCode.1482 – 制作 m 束花所需的最少天数"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/">LeetCode.1482 – 制作 m 束花所需的最少天数<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-8"><a href="#题面-8" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。</p><p>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。</p><p>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。</p><p>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1<br>输出：3<br>解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。<br>现在需要制作 3 束花，每束只需要 1 朵。<br>1 天后：[x, _, _, _, _] &#x2F;&#x2F; 只能制作 1 束花<br>2 天后：[x, _, _, _, x] &#x2F;&#x2F; 只能制作 2 束花<br>3 天后：[x, _, x, _, x] &#x2F;&#x2F; 可以制作 3 束花，答案为 3</p></blockquote><br><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDays</span><span class="params">(<span class="type">int</span>[] bloomDay, <span class="type">int</span> m, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bloomDay.length &lt; m * k) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(bloomDay, m, k, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在 waitingDay 天之内，制成 m 束花 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] bloomDay, <span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> waitingDay)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">combo</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> day : bloomDay) &#123;</span><br><span class="line">      combo = day &lt;= waitingDay ? combo + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (combo == k) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        combo = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1011-–-在-D-天内送达包裹的能力"><a href="#LeetCode-1011-–-在-D-天内送达包裹的能力" class="headerlink" title="LeetCode.1011 – 在 D 天内送达包裹的能力"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">LeetCode.1011 – 在 D 天内送达包裹的能力<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-9"><a href="#题面-9" class="headerlink" title="题面"></a>题面</h5><blockquote><p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</p><p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], days &#x3D; 5<br>输出：15<br>解释：<br>船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：<br>第 1 天：1, 2, 3, 4, 5<br>第 2 天：6, 7<br>第 3 天：8<br>第 4 天：9<br>第 5 天：10</p><p>请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</p></blockquote><br><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">500</span> * <span class="number">5</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(weights, days, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否以 capacity 的运量，在 days 天内运输完所有包裹 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : weights) &#123;</span><br><span class="line">      <span class="comment">// 单个包裹的重量不能够超过总运量</span></span><br><span class="line">      <span class="keyword">if</span> (w &gt; capacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sum += w;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; capacity) &#123;</span><br><span class="line">        sum = w;</span><br><span class="line">        cost++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cost++;</span><br><span class="line">    <span class="keyword">return</span> cost &lt;= days;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LCP-12-–-小张刷题计划"><a href="#LCP-12-–-小张刷题计划" class="headerlink" title="LCP.12 – 小张刷题计划"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/">LCP.12 – 小张刷题计划<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-10"><a href="#题面-10" class="headerlink" title="题面"></a>题面</h5><blockquote><p>为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。</p><p>在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。</p><p>我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：time &#x3D; [1,2,3,3], m &#x3D; 2</p><p>输出：3</p><p>解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。</p></blockquote><br><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minTime</span><span class="params">(<span class="type">int</span>[] time, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(time, m, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在一天耗时最多为 maxTime 的情况下，在 m 天内完成所有计划 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] time, <span class="type">int</span> m, <span class="type">int</span> maxTime)</span> &#123;</span><br><span class="line">    <span class="comment">// maxCost 记录当天花费最久的题目，将它交给场外求助</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">costTime</span> <span class="operator">=</span> <span class="number">0</span>, maxCost = <span class="number">0</span>, costDay = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">help</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : time) &#123;</span><br><span class="line">      costTime += t;</span><br><span class="line">      maxCost = Math.max(maxCost, t);</span><br><span class="line">      <span class="keyword">if</span> (costTime &gt; maxTime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!help) &#123;</span><br><span class="line">          costTime -= maxCost;</span><br><span class="line">          help = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (costTime &gt; maxTime) &#123;</span><br><span class="line">          costTime = maxCost = t;</span><br><span class="line">          costDay++;</span><br><span class="line">          help = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    costDay++;</span><br><span class="line">    <span class="keyword">return</span> costDay &lt;= m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="规律计算"><a href="#规律计算" class="headerlink" title="规律计算"></a>规律计算</h3><h4 id="LeetCode-1292-–-元素和小于等于阈值的正方形的最大边长"><a href="#LeetCode-1292-–-元素和小于等于阈值的正方形的最大边长" class="headerlink" title="LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/submissions/">LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-11"><a href="#题面-11" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。</p><p>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/12/15/e1.png" alt="img"></p><p>输入：mat &#x3D; [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold &#x3D; 4<br>输出：2<br>解释：总和小于或等于 4 的正方形的最大边长为 2，如上图所示。</p></blockquote><br><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSideLength</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">    m = mat.length;</span><br><span class="line">    n = mat[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// sum[i][j] -&gt; 以 (0,0) 为左上角，(i,j) 为右下角的矩形的元素和</span></span><br><span class="line">    <span class="type">int</span>[][] sum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="comment">// 根据容斥原理，构造二维前缀和数组</span></span><br><span class="line">        sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = Math.min(m, n);</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(sum, threshold, middle)) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 是否存在以 side 为边长的正方形，其元素和不超过 threshold */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] sum, <span class="type">int</span> threshold, <span class="type">int</span> side)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> side; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> side; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="comment">// 根据容斥原理，得到当前正方形的元素和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> sum[i][j] - sum[i - side][j] - sum[i][j - side] + sum[i - side][j - side];</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= threshold) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1954-–-收集足够苹果的最小花园周长"><a href="#LeetCode-1954-–-收集足够苹果的最小花园周长" class="headerlink" title="LeetCode.1954 – 收集足够苹果的最小花园周长"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/">LeetCode.1954 – 收集足够苹果的最小花园周长<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-12"><a href="#题面-12" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 abs(i) + abs(j) 个苹果。</p><p>你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。</p><p>给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p><img lazyload src="/images/loading.svg" data-src="https://pic.leetcode.cn/1627790803-qcBKFw-image.png" alt="img"></p><p>输入：neededApples &#x3D; 1<br>输出：8<br>解释：边长长度为 1 的正方形不包含任何苹果。<br>但是边长为 2 的正方形包含 12 个苹果（如上图所示）。<br>周长为 2 * 4 &#x3D; 8 。</p></blockquote><br><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumPerimeter</span><span class="params">(<span class="type">long</span> neededApples)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(neededApples, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left * <span class="number">8L</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">long</span> neededApples, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> len * (len + <span class="number">1L</span>) * (len + <span class="number">1L</span>) * <span class="number">4L</span> - <span class="number">2L</span> * len * (len + <span class="number">1L</span>) &gt;= neededApples;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1802-–-有界数组中指定下标处的最大值"><a href="#LeetCode-1802-–-有界数组中指定下标处的最大值" class="headerlink" title="LeetCode.1802 – 有界数组中指定下标处的最大值"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/">LeetCode.1802 – 有界数组中指定下标处的最大值<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-13"><a href="#题面-13" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p><ul><li>nums.length &#x3D;&#x3D; n</li><li>nums[i] 是 正整数 ，其中 0 &lt;&#x3D; i &lt; n</li><li>abs(nums[i] - nums[i+1]) &lt;&#x3D; 1 ，其中 0 &lt;&#x3D; i &lt; n-1</li><li>nums 中所有元素之和不超过 maxSum</li><li>nums[index] 的值被 最大化</li></ul><p>返回你所构造的数组中的 nums[index] 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：n &#x3D; 4, index &#x3D; 2, maxSum &#x3D; 6<br>输出：2<br>解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</p></blockquote><br><h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = maxSum;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(n, index, (<span class="type">long</span>) maxSum, middle)) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 判断该数组总和是否可以不超过 maxSum ，其中下标 index 处的元素值被确定为 x */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">long</span> maxSum, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 为了尽可能使得数组总和不超过 maxSum ，所以它应该是长这样的：</span></span><br><span class="line">    <span class="comment">// [1,1,2,3,...,x-2,x-1,x,x-1,x-2,...,3,2,1,1]</span></span><br><span class="line">    <span class="keyword">return</span> getSum(x, index + <span class="number">1</span>) + getSum(x, n - index) - x &lt;= maxSum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= len ? (<span class="number">2L</span> * x - len + <span class="number">1L</span>) * len / <span class="number">2L</span> : (<span class="number">1L</span> + x) * x / <span class="number">2L</span> + (len - x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="线性匹配"><a href="#线性匹配" class="headerlink" title="线性匹配"></a>线性匹配</h3><h4 id="LeetCode-1898-–-可移除字符的最大数目-1898-可移除字符的最大数目-力扣（LeetCode）"><a href="#LeetCode-1898-–-可移除字符的最大数目-1898-可移除字符的最大数目-力扣（LeetCode）" class="headerlink" title="[LeetCode.1898 – 可移除字符的最大数目](1898. 可移除字符的最大数目 - 力扣（LeetCode）)"></a>[LeetCode.1898 – 可移除字符的最大数目](<a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-removable-characters/">1898. 可移除字符的最大数目 - 力扣（LeetCode）<i class="fas fa-external-link-alt"></i></a>)</h4><h5 id="题面-14"><a href="#题面-14" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你两个字符串 s 和 p ，其中 p 是 s 的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 removable ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。</p><p>请你找出一个整数 k（0 &lt;&#x3D; k &lt;&#x3D; removable.length），选出 removable 中的 前 k 个下标，然后从 s 中移除这些下标对应的 k 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 0 &lt;&#x3D; i &lt; k ，先标记出位于 s[removable[i]] 的字符，接着移除所有标记过的字符，然后检查 p 是否仍然是 s 的一个子序列。</p><p>返回你可以找出的 最大 k ，满足在移除字符后 p 仍然是 s 的一个子序列。</p><p>字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：s &#x3D; “abcacb”, p &#x3D; “ab”, removable &#x3D; [3,1,0]<br>输出：2<br>解释：在移除下标 3 和 1 对应的字符后，”abcacb” 变成 “accb” 。<br>“ab” 是 “accb” 的一个子序列。<br>如果移除下标 3、1 和 0 对应的字符后，”abcacb” 变成 “ccb” ，那么 “ab” 就不再是 s 的一个子序列。<br>因此，最大的 k 是 2 。</p></blockquote><br><h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRemovals</span><span class="params">(String s, String p, <span class="type">int</span>[] removable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = removable.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(<span class="keyword">new</span> <span class="title class_">String</span>(s).toCharArray(), p, removable, middle)) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 能否在删除 len 个字符后，使得 p 是 s 的一个子序列 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[] s, String p, <span class="type">int</span>[] removable, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      s[removable[i]] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == p.charAt(j)) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j == p.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="隐式二分问题"><a href="#隐式二分问题" class="headerlink" title="隐式二分问题"></a>隐式二分问题</h2><h4 id="LeetCode-287-–-寻找重复数"><a href="#LeetCode-287-–-寻找重复数" class="headerlink" title="LeetCode.287 – 寻找重复数"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">LeetCode.287 – 寻找重复数<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-15"><a href="#题面-15" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,3,4,2,2]</p><p>输出：2</p></blockquote><br><h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个满足 小于等于 i 的元素个数超过了 i 个，那么 i 就是重复的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(nums, middle)) &#123;</span><br><span class="line">        right = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 判断小于等于 guess 的元素个数是否超过了 guess 个 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> guess)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= guess) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; guess;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-1648-–-销售价值减少的颜色球"><a href="#LeetCode-1648-–-销售价值减少的颜色球" class="headerlink" title="LeetCode.1648 – 销售价值减少的颜色球"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/">LeetCode.1648 – 销售价值减少的颜色球<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-16"><a href="#题面-16" class="headerlink" title="题面"></a>题面</h5><blockquote><p>你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。</p><p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）</p><p>给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。</p><p>请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/11/08/jj.gif" alt="img"></p><p>输入：inventory &#x3D; [2,5], orders &#x3D; 4<br>输出：14<br>解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。<br>最大总和为 2 + 5 + 4 + 3 &#x3D; 14 。</p></blockquote><br><h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo</span></span><br></pre></td></tr></table></figure><br><h4 id="LeetCode-274-–-H-指数"><a href="#LeetCode-274-–-H-指数" class="headerlink" title="LeetCode.274 – H 指数"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode.cn/problems/h-index/">LeetCode.274 – H 指数<i class="fas fa-external-link-alt"></i></a></h4><h5 id="题面-17"><a href="#题面-17" class="headerlink" title="题面"></a>题面</h5><blockquote><p>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</p><p>根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。</p><p>如果 h 有多种可能的值，h 指数 是其中最大的那个。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：citations &#x3D; [3,0,6,1,5]<br>输出：3<br>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。<br>由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</p></blockquote><br><h5 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = citations.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (check(citations, middle)) &#123;</span><br><span class="line">        left = middle;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 判断是否有至少 h 篇论文被引用了至少 h 次 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] citations, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : citations) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c &gt;= h) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：「二分最值」 二分法还能这么用？！</li><li>本文作者：twq</li><li>创建时间：2022-05-14 22:09:18</li><li>本文链接：https://blog.ttwwq.top/2022/05/14/「二分最值」二分法还能这么用？！/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">#二分查找</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/05/17/%E3%80%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8D%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88%E7%A8%8B%E5%BA%8F%E6%8C%87%E5%8D%97/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">「多线程」 时间管理大师</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/04/18/%E3%80%8CJava%E5%9F%BA%E7%A1%80%E3%80%8D%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%89%A2%EF%BC%8C%E5%9C%B0%E5%8A%A8%E5%B1%B1%E6%91%87%EF%BC%81/"><span class="title flex-center"><span class="post-nav-title-item">「Java基础」 基础不牢，地动山摇！</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"7e8652081d0a43a84cb4",clientSecret:"09dedf7315b0bb397fda7165e8c883e1605706e3",repo:"blog-comments",owner:"twq2000",admin:["twq2000"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">twq</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="nav-number">2.</span> <span class="nav-text">总体思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E5%8D%95%E6%B1%87%E6%80%BB-%F0%9F%8F%B7%EF%B8%8F"><span class="nav-number">3.</span> <span class="nav-text">题单汇总 🏷️</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">显式最值问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">简单计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1283-%E2%80%93-%E4%BD%BF%E7%BB%93%E6%9E%9C%E4%B8%8D%E8%B6%85%E8%BF%87%E9%98%88%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E9%99%A4%E6%95%B0"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">LeetCode.1283 – 使结果不超过阈值的最小除数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2"><span class="nav-number">3.1.1.1.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.1.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1300-%E2%80%93-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">LeetCode.1300 – 转变数组后最接近目标值的数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-1"><span class="nav-number">3.1.1.2.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">3.1.1.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-875-%E2%80%93-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">LeetCode.875 – 爱吃香蕉的珂珂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-2"><span class="nav-number">3.1.1.3.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="nav-number">3.1.1.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-2064-%E2%80%93-%E5%88%86%E9%85%8D%E7%BB%99%E5%95%86%E5%BA%97%E7%9A%84%E6%9C%80%E5%A4%9A%E5%95%86%E5%93%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">LeetCode.2064 – 分配给商店的最多商品的最小值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-3"><span class="nav-number">3.1.1.4.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="nav-number">3.1.1.4.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1870-%E2%80%93-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F"><span class="nav-number">3.1.1.5.</span> <span class="nav-text">LeetCode.1870 – 准时到达的列车最小时速</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-4"><span class="nav-number">3.1.1.5.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="nav-number">3.1.1.5.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-2187-%E2%80%93-%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4"><span class="nav-number">3.1.1.6.</span> <span class="nav-text">LeetCode.2187 – 完成旅途的最少时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-5"><span class="nav-number">3.1.1.6.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="nav-number">3.1.1.6.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1760-%E2%80%93-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83"><span class="nav-number">3.1.1.7.</span> <span class="nav-text">LeetCode.1760 – 袋子里最少数目的球</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-6"><span class="nav-number">3.1.1.7.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="nav-number">3.1.1.7.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">历史标记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1552-%E2%80%93-%E4%B8%A4%E7%90%83%E4%B9%8B%E9%97%B4%E7%9A%84%E7%A3%81%E5%8A%9B"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">LeetCode.1552 – 两球之间的磁力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-7"><span class="nav-number">3.1.2.1.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="nav-number">3.1.2.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1482-%E2%80%93-%E5%88%B6%E4%BD%9C-m-%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">LeetCode.1482 – 制作 m 束花所需的最少天数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-8"><span class="nav-number">3.1.2.2.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="nav-number">3.1.2.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1011-%E2%80%93-%E5%9C%A8-D-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">LeetCode.1011 – 在 D 天内送达包裹的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-9"><span class="nav-number">3.1.2.3.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="nav-number">3.1.2.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCP-12-%E2%80%93-%E5%B0%8F%E5%BC%A0%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">LCP.12 – 小张刷题计划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-10"><span class="nav-number">3.1.2.4.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="nav-number">3.1.2.4.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%BE%8B%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.3.</span> <span class="nav-text">规律计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1292-%E2%80%93-%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">LeetCode.1292 – 元素和小于等于阈值的正方形的最大边长</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-11"><span class="nav-number">3.1.3.1.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="nav-number">3.1.3.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1954-%E2%80%93-%E6%94%B6%E9%9B%86%E8%B6%B3%E5%A4%9F%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E5%9B%AD%E5%91%A8%E9%95%BF"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">LeetCode.1954 – 收集足够苹果的最小花园周长</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-12"><span class="nav-number">3.1.3.2.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="nav-number">3.1.3.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1802-%E2%80%93-%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">LeetCode.1802 – 有界数组中指定下标处的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-13"><span class="nav-number">3.1.3.3.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="nav-number">3.1.3.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%B9%E9%85%8D"><span class="nav-number">3.1.4.</span> <span class="nav-text">线性匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1898-%E2%80%93-%E5%8F%AF%E7%A7%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE-1898-%E5%8F%AF%E7%A7%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">[LeetCode.1898 – 可移除字符的最大数目](1898. 可移除字符的最大数目 - 力扣（LeetCode）)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-14"><span class="nav-number">3.1.4.1.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="nav-number">3.1.4.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">隐式二分问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-287-%E2%80%93-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">LeetCode.287 – 寻找重复数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-15"><span class="nav-number">3.2.0.1.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="nav-number">3.2.0.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-1648-%E2%80%93-%E9%94%80%E5%94%AE%E4%BB%B7%E5%80%BC%E5%87%8F%E5%B0%91%E7%9A%84%E9%A2%9C%E8%89%B2%E7%90%83"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">LeetCode.1648 – 销售价值减少的颜色球</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-16"><span class="nav-number">3.2.0.2.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="nav-number">3.2.0.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LeetCode-274-%E2%80%93-H-%E6%8C%87%E6%95%B0"><span class="nav-number">3.2.0.3.</span> <span class="nav-text">LeetCode.274 – H 指数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%98%E9%9D%A2-17"><span class="nav-number">3.2.0.3.1.</span> <span class="nav-text">题面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="nav-number">3.2.0.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>