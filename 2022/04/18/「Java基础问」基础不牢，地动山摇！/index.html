<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="twq"><title>「Java基础问」 基础不牢，地动山摇！ | TwQ 的博客</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon.jpg"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.ttwwq.top",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/avatar.png",favicon:"/images/favicon.jpg",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"保持热爱，保持记录 :D"},scroll:{progress_bar:{enable:!0},percent:{enable:!1}}},local_search:{enable:!0,preload:!1},code_copy:{enable:!0,style:"mac"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">TwQ 的博客</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页 🏠</a></li><li class="menu-item"><a href="/archives">归档 📄</a></li><li class="menu-item"><a href="/tags">标签 🏷️</a></li><li class="menu-item"><a href="/todo">待办 ✅</a></li><li class="menu-item"><a href="/board">留言板 💬</a></li><li class="menu-item"><a href="/about">关于 🥳</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页 🏠</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档 📄</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签 🏷️</a></li><li class="drawer-menu-item flex-center"><a href="/todo">待办 ✅</a></li><li class="drawer-menu-item flex-center"><a href="/board">留言板 💬</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于 🥳</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">「Java基础问」 基础不牢，地动山摇！</span></div><div class="article-header"><div class="avatar"><img src="/images/avatar.png"></div><div class="info"><div class="author"><span class="name">twq</span> <span class="author-label">Lv.2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2022-04-18 19:12:09</span> <span class="mobile">2022-04-18 19:12</span> </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Java/">Java</a>&nbsp;</li><li>| <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>11 分钟</span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="四种访问修饰符的作用范围？"><a href="#四种访问修饰符的作用范围？" class="headerlink" title="四种访问修饰符的作用范围？"></a>四种访问修饰符的作用范围？</h1><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包下</th><th align="center">子类</th><th align="center">其他包下</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">protected</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td></tr><tr><td align="center">default</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">private</td><td align="center">✔️</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table><br><h1 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h1><ul><li>向上转型没有任何问题。如 <code>long b = 1;</code></li><li>向下转向会造成精度损失，因此如果需要，必须显式地进行强制转换。如 <code>float f = (float) 2.3;</code></li></ul><p>打个比喻：小杯的水倒进一个大杯里肯定没问题。但大杯的水倒进小杯就不行了，可能会溢出。</p><br><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><p>Java的基本类型的包装类大部分都实现了常量池技术。</p><table><thead><tr><th align="center">Byte</th><th align="center">Short</th><th align="center">Integer</th><th align="center">Long</th><th align="center">Character</th><th align="center">Boolean</th></tr></thead><tbody><tr><td align="center">[-128,127]</td><td align="center">[-128,127]</td><td align="center">[-128,127]</td><td align="center">[-128,127]</td><td align="center">[0,127]</td><td align="center">True&#x2F;False</td></tr></tbody></table><p>Float 和 Double 没有使用常量池技术。</p><p>简单地说，如果使用的对象的字面量的值在常量池的范围之内，那么就不会创建新的包装类型对象，而是直接引用常量池中的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>, b = <span class="number">100</span>, c = <span class="number">1000</span>, d = <span class="number">1000</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true</span></span><br><span class="line">System.out.println(c == d);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><p>同样地，String 也有对应的常量池，称为字符串常量池。不过这和上面提到的包装类型的常量池有些不同的是，字符串常量池事先不会缓存任何内容，而是在每次创建字符串时进行判断：如果已经在常量池中存在，那么就直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。维护字符串常量池的全局表叫做 <code>StringTable</code>，其实就是一个 <code>HashSet&lt;String&gt;</code>。它在JVM中仅有一份实例，并被所有类共享使用。</p><p>在Java中，有两种创建字符串对象的方式：</p><ol><li><p><code>String str = &quot;hello&quot;;</code></p><p>这种方式下，由于是通过字面量直接创建，所以在编译的时候对于JVM而言是可以确定的。如果 “hello” 已存在于常量池中，那么直接返回常量池中的对象引用；否则就先创建一份放入常量池，再返回。</p></li><li><p><code>String str = new String(&quot;hello&quot;);</code></p><p>这种方式下，是通过构造器创建对象，在运行时在堆中创建的。所以它不仅会在常量池中创建一个 “hello” 实例，还会在堆中创建一个 String 对象。</p></li></ol><p>可以认为，后者包含了前者。</p><br><h1 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h1><ul><li><p>重载 <code>Overload</code> 是发生在同一个类中的：</p><p>同名的方法，但是有着不同的参数列表 (参数类型不同&#x2F;参数个数不同)。</p></li><li><p>重写 <code>Override</code> 是发生在父类与子类之间的：</p><p>子类对父类中提供的某方法进行逻辑的重新定义。</p><p>规定子类被重写方法和父类被重写方法的返回值必须相同，且不能比父类被重写方法声明更多的异常。</p></li></ul><br><h1 id="为什么说重写-equals-就要重写-hashCode-？"><a href="#为什么说重写-equals-就要重写-hashCode-？" class="headerlink" title="为什么说重写 equals() 就要重写 hashCode() ？"></a>为什么说重写 equals() 就要重写 hashCode() ？</h1><p>这其实是一种规定。</p><p><strong>换句话说，如果我们不遵守这样的规定，那么最直接的影响是使用哈希结构的容器就可能出现重大问题，</strong>因为它们的底层依赖的正是对象的 <code>hashCode()</code> 方法，而你却没有重写它。例如，<code>HashSet</code> 本身是具有去重功能的，但是现在就出问题了：逻辑上明明相同的两个对象，理应只会有一个存在于容器中，事实却是它们都会存在。</p><br><p>另外提一句：<code>equals()</code> 相等的两个对象，<code>hashCode()</code> <strong>要保证</strong>一定相等；但是 <code>hashCode()</code> 相等的两个对象，<code>equals()</code> 并不一定要相等。</p><p>理由也很简单：因为 <code>hashCode()</code> 相等也有可能是哈希冲突导致的，实质上是两个不相干的对象。</p><br><h1 id="JVM-加载-class-文件的过程？"><a href="#JVM-加载-class-文件的过程？" class="headerlink" title="JVM 加载 class 文件的过程？"></a>JVM 加载 class 文件的过程？</h1><p>JVM中的类加载过程，都是由类加载器来实现的。当Java程序需要使用某个类时，JVM需要确保这个类已经被加载进内存中，并被成功初始化。</p><ol><li><p>加载：</p><p>在经过编译后，会生成 <code>.class</code> 的字节码文件。通常是使用字节数组来读入字节码文件，并在内存中产生与之对应的 <code>Class</code> 对象。</p></li><li><p>检验：</p><p>经过了加载的步骤，其实 <code>Class</code> 对象还是不完整的。还需要进行一些检验操作：</p><ol><li>该类是否存在父类？如果存在，那么必须要确保父类也已经初始化完毕。</li><li>该类是否存在初始化语句块？如果存在，那么需要依次执行这些代码。</li></ol></li></ol><p>总体顺序是这样的：</p><ol><li>父类到子类依次执行静态初始代码块</li><li>父类执行非静态初始代码块和构造器方法，然后子类执行非静态初始代码块和构造器方法</li></ol><br><p>JVM的类加载器包括：</p><ol><li><code>BootstrapClassLoader</code> 根加载器：负责加载JVM的基础核心类库</li><li><code>ExtensionClassLoader</code> 扩展加载器：负责加载JVM的扩展类库</li><li><code>ApplicationClassLoader</code> 应用类加载器：负责加载 classpath 下的类文件，即使用者编写的代码</li></ol><p>为了确保同一份字节码文件不会被多个类加载器重复加载，所以 JVM 还推出了一个叫做「<strong>双亲委派</strong>」的机制：当来了一个需要被加载的字节码文件时，当前类加载器不会直接加载它，而是<strong>向上抛给它的父加载器</strong>。只有当父加载器无法处理时，才返回由当前类加载器进行处理。这样就保证了一份字节码文件仅会被一个类加载器所处理。</p><br><h1 id="创建对象的几种方式？"><a href="#创建对象的几种方式？" class="headerlink" title="创建对象的几种方式？"></a>创建对象的几种方式？</h1><ol><li><code>new</code> 创建新对象</li><li>使用反射机制</li><li>使用 <code>clone</code> 机制</li><li>通过反序列化方式</li></ol><br><h1 id="关键字-final-的作用？"><a href="#关键字-final-的作用？" class="headerlink" title="关键字 final 的作用？"></a>关键字 final 的作用？</h1><p><code>final</code> 表示不可变的意思，可用于修饰类、属性和方法。</p><ul><li><p>被 <code>final</code> 修饰的类不可以被继承。</p></li><li><p>被 <code>final</code> 修饰的方法不可以被重写。</p></li><li><p>被 <code>final</code> 修饰的属性不可变，并且必须被显式地指定初始值。</p><p>另外，这里的不可变指的是引用不可变，而不是引用指向的内容的不可变。</p><p>例如 <code>final int[] nums = new int[3];</code> 但是数组内部的元素是可以随意修改的啊。</p></li></ul><br><h1 id="方法参数传递到底是引用传递还是值传递？"><a href="#方法参数传递到底是引用传递还是值传递？" class="headerlink" title="方法参数传递到底是引用传递还是值传递？"></a>方法参数传递到底是引用传递还是值传递？</h1><p>值传递。</p><p>如果参数是一个基本类型的数据，那么传递的是数据的字面值本身。</p><p>如果参数是一个引用类型的对象，那么传递的是对象的引用地址值。在被调用的过程中，对象的属性可以被修改，并影响到调用者；对象的引用也可以被修改，但是不会影响到调用者。</p><br><h1 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h1><p>String 作为不可变类，它是只读的，对象的内容是无法被改变的。如果需要修改内容，那么只能再通过创建一个新的字符串对象。如果在修改操作十分频繁的场景下，性能就显得十分低下了。</p><p>因此，JDK5开始，引入了 StringBuilder&#x2F;StringBuffer 类，专门用于字符串拼接、删除、插入等修改操作。两者的区别在于线程安全性，由于后者的所有方法都被 synchronized 修饰，因此是线程安全的，但是效率就不如前者了。</p><br><p>在JDK8以前，如果在两个字符串对象之间使用 “+” 进行拼接，会生成中间对象。不过，在Java8开始，JVM在编译期对 “+” 进行了优化，变成了基于 StringBuilder 的 <code>append()</code> 方法。所以，经过编译器的处理，加号拼接的性能和 StringBuilder 是一样的！</p><p>当然，如果是循环里进行拼接操作，那么还是建议用 StringBuilder 来显式地调用，否则每循环一次就会创建一个新的 StringBuilder 对象，这肯定不如把 StringBuilder 显式地放在循环外部来得好。</p><br><h1 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h1><ul><li><p>相同点：</p><ol><li>它们天生的作用就是被继承&#x2F;实现。不可以被实例化，即不能通过 new 来创建对象。</li><li>可以使用抽象类&#x2F;接口类的引用。如 <code>UserService service = new UserServiceImpl();</code></li><li>一个类如果继承&#x2F;实现了抽象类&#x2F;接口，那么它就需要对其中的所有抽象方法进行 <code>@Override</code> 重写实现。</li></ol></li><li><p>不同点：</p><p>抽象类和普通类的区别就在于：它<strong>可以</strong>声明抽象方法 (注意我这里的用词是<strong>可以</strong>，不是<strong>必须</strong>)。换句话说，<strong>抽象类不一定都要有抽象方法，但具有抽象方法的都一定是抽象类。</strong></p><ol><li>接口比抽象类更加“抽象”：抽象类可以存在非抽象方法，但是接口中的方法都必须是抽象的。</li><li>抽象类作为一种类，可以定义构造器、成员变量，并且可以用 <code>public, protected, default, private</code> 来修饰；接口不能定义构造器，成员变量只能用 <code>public</code> 来修饰 (而且，这种变量实质上都是常量)。</li></ol></li></ul><br><h1 id="try…catch…finally-坑爹题"><a href="#try…catch…finally-坑爹题" class="headerlink" title="try…catch…finally 坑爹题"></a>try…catch…finally 坑爹题</h1><ol><li><p>请问以下代码的输出是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(test());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：31</p><p>在 try 返回前，会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的结果 1。</p></li><li><p>请问以下代码的输出是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(test());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：3</p><p>在 try 返回前，会先执行 finally 语句块。然而这里的 finally 却不按套路出牌，直接 return 了。</p></li></ol><br><h1 id="I-x2F-O流有哪些？"><a href="#I-x2F-O流有哪些？" class="headerlink" title="I&#x2F;O流有哪些？"></a>I&#x2F;O流有哪些？</h1><ul><li>按照流向：输入流、输出流</li><li>按照操作单元：字节流、字符流</li></ul><p>InputStream&#x2F;Reader：所有输入流的基类。前者是字节输入流，后者是字符输入流。</p><p>OutputStream&#x2F;Writer：所有输出流的基类。前者是字节输出流，后者是字符输出流。</p><br><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="什么是序列化-x2F-反序列化？"><a href="#什么是序列化-x2F-反序列化？" class="headerlink" title="什么是序列化&#x2F;反序列化？"></a>什么是序列化&#x2F;反序列化？</h2><p>序列化：把Java对象转为二进制流，以方便在网络中进行传输。</p><p>反序列化：把二进制流恢复为Java对象。</p><p>好比生活中对一些大件物品的运输，在运输时将它拆分再打包，使用时再重新组装。</p><br><h2 id="如何实现序列化？"><a href="#如何实现序列化？" class="headerlink" title="如何实现序列化？"></a>如何实现序列化？</h2><p>需要让该Java对象所属的类实现 <code>Serializable</code> 接口。</p><p><code>Serializable</code> 接口没有什么具体的作用，它只是一个标识性接口。但是如果不实现这个接口，在一些序列化场景下会出错。</p><p>所以一般建议，创建的JavaBean类都实现 <code>Serializable</code> 接口。</p><br><h2 id="可以不参与序列化吗？"><a href="#可以不参与序列化吗？" class="headerlink" title="可以不参与序列化吗？"></a>可以不参与序列化吗？</h2><p>可以。对于那些不想进行序列化的变量，可以使用关键字 <code>transient</code> 进行修饰。</p><br><h2 id="常见的序列化手段？"><a href="#常见的序列化手段？" class="headerlink" title="常见的序列化手段？"></a>常见的序列化手段？</h2><ul><li>Java对象流：一般是对象输出流 <code>ObjectOutputStream</code> 和对象输入流 <code>ObjectInputStream</code></li><li>JSON：很多第三方JSON技术，如Jackson、FastJson、GSON</li><li>ProtoBuff：一种轻便高效的结构化数据存储格式，可以大大减少数据传输大小，提高系统性能。</li></ul><br><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型擦除是什么？"><a href="#泛型擦除是什么？" class="headerlink" title="泛型擦除是什么？"></a>泛型擦除是什么？</h2><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。也就是说，在运行的时候是没有泛型的。</p><p>这样做的目的，主要是为了能够使JVM向下兼容，因为在JDK5之前是没有泛型的。</p><br><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>普通的创建对象，是通过 <code>new</code> 的方式。这种方式相当于在编译时已经确定了类型信息。</p><p>但是如果想<strong>在运行时动态地获取类信息</strong>，然后再创建对应的类型实例，那么就需要使用反射了。</p><br><p>通过反射，可以获取任意一个类的所有属性和方法 (没错，即使 <code>private</code> 也可以获取到)，并调用它们。</p><p><img lazyload src="/images/loading.svg" data-src="https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcIiax6uNmr7uTS0NCvfiaxlkBmkad3icpgcDXOpY9gnRr0GLZUmIp0C9icWo0902ibyNLic1QiahNzpAic1A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><br><h2 id="反射的原理是什么？"><a href="#反射的原理是什么？" class="headerlink" title="反射的原理是什么？"></a>反射的原理是什么？</h2><p>在类加载时期，JVM使用类加载器将字节码文件加载入内存。反射就是在这个期间获取类信息，然后进行各种操作。</p><br><h2 id="反射有哪些使用场景？"><a href="#反射有哪些使用场景？" class="headerlink" title="反射有哪些使用场景？"></a>反射有哪些使用场景？</h2><p>一般而言，我们很少会直接接触并编写反射代码。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，才能这么轻松地使用各种框架。比如Spring框架中，就大量使用了反射机制。</p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：「Java基础问」 基础不牢，地动山摇！</li><li>本文作者：twq</li><li>创建时间：2022-04-18 19:12:09</li><li>本文链接：https://blog.ttwwq.top/2022/04/18/「Java基础问」基础不牢，地动山摇！/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Java/">#Java</a>&nbsp;</li><li class="tag-item"><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2022/05/14/%E3%80%8C%E4%BA%8C%E5%88%86%E6%9C%80%E5%80%BC%E3%80%8D%E4%BA%8C%E5%88%86%E6%B3%95%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BC%81/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">「二分最值」 二分法还能这么用？！</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2022/04/02/%E3%80%8C%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%8D%E4%BA%8C%E5%88%86%E6%9C%80%E7%A1%AC%E5%B9%B2%E8%B4%A7%EF%BC%8C%E5%B0%B1%E5%9C%A8%E8%BF%99%E4%BA%86%EF%BC%81/"><span class="title flex-center"><span class="post-nav-title-item">「二分法」最硬干货，速进！</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div id="gitalk-container"></div><script data-pjax src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script><script data-pjax>function loadGitalk(){let e=decodeURI(location.pathname);e.length>50&&(e=e.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"7e8652081d0a43a84cb4",clientSecret:"09dedf7315b0bb397fda7165e8c883e1605706e3",repo:"blog-comments",owner:"twq2000",admin:["twq2000"],id:e,language:"zh-CN"}).render("gitalk-container")}catch(e){window.Gitalk=null}}{const e=setTimeout(()=>{loadGitalk(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2021</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">twq</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">四种访问修饰符的作用范围？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">基本类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">3.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">重载和重写的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E9%87%8D%E5%86%99-equals-%E5%B0%B1%E8%A6%81%E9%87%8D%E5%86%99-hashCode-%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">为什么说重写 equals() 就要重写 hashCode() ？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E5%8A%A0%E8%BD%BD-class-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">JVM 加载 class 文件的过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">创建对象的几种方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-final-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">关键字 final 的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">方法参数传递到底是引用传递还是值传递？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">字符串拼接问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">抽象类和接口的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try%E2%80%A6catch%E2%80%A6finally-%E5%9D%91%E7%88%B9%E9%A2%98"><span class="nav-number">12.</span> <span class="nav-text">try…catch…finally 坑爹题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-x2F-O%E6%B5%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">I&#x2F;O流有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">14.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96-x2F-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">什么是序列化&#x2F;反序列化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">14.2.</span> <span class="nav-text">如何实现序列化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%82%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-number">14.3.</span> <span class="nav-text">可以不参与序列化吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="nav-number">14.4.</span> <span class="nav-text">常见的序列化手段？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">15.1.</span> <span class="nav-text">泛型擦除是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">16.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="nav-number">16.1.</span> <span class="nav-text">什么是反射？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.2.</span> <span class="nav-text">反射的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">16.3.</span> <span class="nav-text">反射有哪些使用场景？</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>